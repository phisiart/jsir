// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

// IWYU pragma: begin_keep
// NOLINTBEGIN(whitespace/line_length)
// clang-format off

#include "maldoca/js/ir/conversion/jsir_to_ast.h"

#include <memory>
#include <optional>
#include <string>
#include <utility>
#include <variant>
#include <vector>

#include "llvm/ADT/APFloat.h"
#include "llvm/ADT/TypeSwitch.h"
#include "llvm/Support/Casting.h"
#include "mlir/IR/Attributes.h"
#include "mlir/IR/Block.h"
#include "mlir/IR/Builders.h"
#include "mlir/IR/BuiltinAttributes.h"
#include "mlir/IR/BuiltinTypes.h"
#include "mlir/IR/Operation.h"
#include "mlir/IR/Region.h"
#include "mlir/IR/Value.h"
#include "absl/cleanup/cleanup.h"
#include "absl/log/check.h"
#include "absl/log/log.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/str_cat.h"
#include "absl/types/optional.h"
#include "absl/types/variant.h"
#include "maldoca/base/status_macros.h"
#include "maldoca/js/ast/ast.generated.h"
#include "maldoca/js/ir/ir.h"

namespace maldoca {

absl::StatusOr<std::unique_ptr<JsStatement>>
JsirToAst::VisitStatement(JsirStatementOpInterface op) {
  using Ret = absl::StatusOr<std::unique_ptr<JsStatement>>;
  return llvm::TypeSwitch<mlir::Operation*, Ret>(op)
    .Case([&](JsirExpressionStatementOp op) {
      return VisitExpressionStatement(op);
    })
    .Case([&](JshirBlockStatementOp op) {
      return VisitBlockStatement(op);
    })
    .Case([&](JsirEmptyStatementOp op) {
      return VisitEmptyStatement(op);
    })
    .Case([&](JsirDebuggerStatementOp op) {
      return VisitDebuggerStatement(op);
    })
    .Case([&](JshirWithStatementOp op) {
      return VisitWithStatement(op);
    })
    .Case([&](JsirReturnStatementOp op) {
      return VisitReturnStatement(op);
    })
    .Case([&](JshirLabeledStatementOp op) {
      return VisitLabeledStatement(op);
    })
    .Case([&](JshirBreakStatementOp op) {
      return VisitBreakStatement(op);
    })
    .Case([&](JshirContinueStatementOp op) {
      return VisitContinueStatement(op);
    })
    .Case([&](JshirIfStatementOp op) {
      return VisitIfStatement(op);
    })
    .Case([&](JshirSwitchStatementOp op) {
      return VisitSwitchStatement(op);
    })
    .Case([&](JsirThrowStatementOp op) {
      return VisitThrowStatement(op);
    })
    .Case([&](JshirTryStatementOp op) {
      return VisitTryStatement(op);
    })
    .Case([&](JshirWhileStatementOp op) {
      return VisitWhileStatement(op);
    })
    .Case([&](JshirDoWhileStatementOp op) {
      return VisitDoWhileStatement(op);
    })
    .Case([&](JshirForStatementOp op) {
      return VisitForStatement(op);
    })
    .Case([&](JshirForInStatementOp op) {
      return VisitForInStatement(op);
    })
    .Case([&](JshirForOfStatementOp op) {
      return VisitForOfStatement(op);
    })
    .Case([&](JsirFunctionDeclarationOp op) {
      return VisitFunctionDeclaration(op);
    })
    .Case([&](JsirVariableDeclarationOp op) {
      return VisitVariableDeclaration(op);
    })
    .Case([&](JsirClassDeclarationOp op) {
      return VisitClassDeclaration(op);
    })
    .Default([&](mlir::Operation* op) {
      return absl::InvalidArgumentError("Unrecognized op");
    });
}

absl::StatusOr<std::unique_ptr<JsModuleDeclaration>>
JsirToAst::VisitModuleDeclaration(JsirModuleDeclarationOpInterface op) {
  using Ret = absl::StatusOr<std::unique_ptr<JsModuleDeclaration>>;
  return llvm::TypeSwitch<mlir::Operation*, Ret>(op)
    .Case([&](JsirImportDeclarationOp op) {
      return VisitImportDeclaration(op);
    })
    .Case([&](JsirExportNamedDeclarationOp op) {
      return VisitExportNamedDeclaration(op);
    })
    .Case([&](JsirExportDefaultDeclarationOp op) {
      return VisitExportDefaultDeclaration(op);
    })
    .Case([&](JsirExportAllDeclarationOp op) {
      return VisitExportAllDeclaration(op);
    })
    .Default([&](mlir::Operation* op) {
      return absl::InvalidArgumentError("Unrecognized op");
    });
}

absl::StatusOr<std::unique_ptr<JsDirectiveLiteral>>
JsirToAst::VisitDirectiveLiteral(JsirDirectiveLiteralOp op) {
  std::string value = op.getValueAttr().str();
  std::optional<std::unique_ptr<JsDirectiveLiteralExtra>> extra;
  if (op.getExtraAttr() != nullptr) {
    MALDOCA_ASSIGN_OR_RETURN(extra, VisitDirectiveLiteralExtraAttr(op.getExtraAttr()));
  }
  return Create<JsDirectiveLiteral>(
      op,
      std::move(value),
      std::move(extra));
}

absl::StatusOr<std::unique_ptr<JsDirective>>
JsirToAst::VisitDirective(JsirDirectiveOp op) {
  auto value_op = llvm::dyn_cast<JsirDirectiveLiteralOp>(op.getValue().getDefiningOp());
  if (value_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirDirectiveLiteralOp, got ",
                     op.getValue().getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsDirectiveLiteral> value, VisitDirectiveLiteral(value_op));
  return Create<JsDirective>(
      op,
      std::move(value));
}

absl::StatusOr<std::unique_ptr<JsProgram>>
JsirToAst::VisitProgram(JsirProgramOp op) {
  std::optional<std::unique_ptr<JsInterpreterDirective>> interpreter;
  if (op.getInterpreterAttr() != nullptr) {
    MALDOCA_ASSIGN_OR_RETURN(interpreter, VisitInterpreterDirectiveAttr(op.getInterpreterAttr()));
  }
  std::string source_type = op.getSourceTypeAttr().str();
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_body_block, GetStmtsRegionBlock(op.getBody()));
  std::vector<std::variant<std::unique_ptr<JsStatement>, std::unique_ptr<JsModuleDeclaration>>> body;
  for (mlir::Operation& mlir_body_element_unchecked : *mlir_body_block) {
    std::variant<std::unique_ptr<JsStatement>, std::unique_ptr<JsModuleDeclaration>> body_element;
    if (auto mlir_body_element = llvm::dyn_cast<JsirStatementOpInterface>(mlir_body_element_unchecked)) {
      MALDOCA_ASSIGN_OR_RETURN(body_element, VisitStatement(mlir_body_element));
    } else if (auto mlir_body_element = llvm::dyn_cast<JsirModuleDeclarationOpInterface>(mlir_body_element_unchecked)) {
      MALDOCA_ASSIGN_OR_RETURN(body_element, VisitModuleDeclaration(mlir_body_element));
    } else {
      continue;
    }
    body.push_back(std::move(body_element));
  }
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_directives_block, GetStmtsRegionBlock(op.getDirectives()));
  std::vector<std::unique_ptr<JsDirective>> directives;
  for (mlir::Operation& mlir_directives_element_unchecked : *mlir_directives_block) {
    auto directives_element_op = llvm::dyn_cast<JsirDirectiveOp>(mlir_directives_element_unchecked);
    if (directives_element_op == nullptr) {
      continue;
    }
    MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsDirective> directives_element, VisitDirective(directives_element_op));
    directives.push_back(std::move(directives_element));
  }
  return Create<JsProgram>(
      op,
      std::move(interpreter),
      std::move(source_type),
      std::move(body),
      std::move(directives));
}

absl::StatusOr<std::unique_ptr<JsFile>>
JsirToAst::VisitFile(JsirFileOp op) {
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_program_operation, GetStmtRegionOperation(op.getProgram()));
  auto program_op = llvm::dyn_cast<JsirProgramOp>(mlir_program_operation);
  if (program_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirProgramOp, got ",
                     mlir_program_operation->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsProgram> program, VisitProgram(program_op));
  std::optional<std::vector<std::unique_ptr<JsComment>>> comments;
  if (op.getCommentsAttr() != nullptr) {
    std::vector<std::unique_ptr<JsComment>> comments_value;
    for (mlir::Attribute mlir_comments_element_unchecked : op.getCommentsAttr().getValue()) {
      auto comments_element_attr = llvm::dyn_cast<JsirCommentAttrInterface>(mlir_comments_element_unchecked);
      if (comments_element_attr == nullptr) {
        return absl::InvalidArgumentError("Invalid attribute.");
      }
      MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsComment> comments_element, VisitCommentAttr(comments_element_attr));
      comments_value.push_back(std::move(comments_element));
    }
    comments = std::move(comments_value);
  }
  return Create<JsFile>(
      op,
      std::move(program),
      std::move(comments));
}

absl::StatusOr<std::unique_ptr<JsExpression>>
JsirToAst::VisitExpression(JsirExpressionOpInterface op) {
  using Ret = absl::StatusOr<std::unique_ptr<JsExpression>>;
  return llvm::TypeSwitch<mlir::Operation*, Ret>(op)
    .Case([&](JsirIdentifierOp op) {
      return VisitIdentifier(op);
    })
    .Case([&](JsirRegExpLiteralOp op) {
      return VisitRegExpLiteral(op);
    })
    .Case([&](JsirNullLiteralOp op) {
      return VisitNullLiteral(op);
    })
    .Case([&](JsirStringLiteralOp op) {
      return VisitStringLiteral(op);
    })
    .Case([&](JsirBooleanLiteralOp op) {
      return VisitBooleanLiteral(op);
    })
    .Case([&](JsirNumericLiteralOp op) {
      return VisitNumericLiteral(op);
    })
    .Case([&](JsirBigIntLiteralOp op) {
      return VisitBigIntLiteral(op);
    })
    .Case([&](JsirThisExpressionOp op) {
      return VisitThisExpression(op);
    })
    .Case([&](JsirArrowFunctionExpressionOp op) {
      return VisitArrowFunctionExpression(op);
    })
    .Case([&](JsirYieldExpressionOp op) {
      return VisitYieldExpression(op);
    })
    .Case([&](JsirAwaitExpressionOp op) {
      return VisitAwaitExpression(op);
    })
    .Case([&](JsirArrayExpressionOp op) {
      return VisitArrayExpression(op);
    })
    .Case([&](JsirObjectExpressionOp op) {
      return VisitObjectExpression(op);
    })
    .Case([&](JsirFunctionExpressionOp op) {
      return VisitFunctionExpression(op);
    })
    .Case([&](JsirUnaryExpressionOp op) {
      return VisitUnaryExpression(op);
    })
    .Case([&](JsirUpdateExpressionOp op) {
      return VisitUpdateExpression(op);
    })
    .Case([&](JsirBinaryExpressionOp op) {
      return VisitBinaryExpression(op);
    })
    .Case([&](JsirAssignmentExpressionOp op) {
      return VisitAssignmentExpression(op);
    })
    .Case([&](JshirLogicalExpressionOp op) {
      return VisitLogicalExpression(op);
    })
    .Case([&](JsirMemberExpressionOp op) {
      return VisitMemberExpression(op);
    })
    .Case([&](JsirOptionalMemberExpressionOp op) {
      return VisitOptionalMemberExpression(op);
    })
    .Case([&](JshirConditionalExpressionOp op) {
      return VisitConditionalExpression(op);
    })
    .Case([&](JsirCallExpressionOp op) {
      return VisitCallExpression(op);
    })
    .Case([&](JsirOptionalCallExpressionOp op) {
      return VisitOptionalCallExpression(op);
    })
    .Case([&](JsirNewExpressionOp op) {
      return VisitNewExpression(op);
    })
    .Case([&](JsirSequenceExpressionOp op) {
      return VisitSequenceExpression(op);
    })
    .Case([&](JsirParenthesizedExpressionOp op) {
      return VisitParenthesizedExpression(op);
    })
    .Case([&](JsirTemplateLiteralOp op) {
      return VisitTemplateLiteral(op);
    })
    .Case([&](JsirTaggedTemplateExpressionOp op) {
      return VisitTaggedTemplateExpression(op);
    })
    .Case([&](JsirClassExpressionOp op) {
      return VisitClassExpression(op);
    })
    .Case([&](JsirMetaPropertyOp op) {
      return VisitMetaProperty(op);
    })
    .Default([&](mlir::Operation* op) {
      return absl::InvalidArgumentError("Unrecognized op");
    });
}

absl::StatusOr<std::unique_ptr<JsPattern>>
JsirToAst::VisitPatternRef(JsirPatternRefOpInterface op) {
  using Ret = absl::StatusOr<std::unique_ptr<JsPattern>>;
  return llvm::TypeSwitch<mlir::Operation*, Ret>(op)
    .Case([&](JsirIdentifierRefOp op) {
      return VisitIdentifierRef(op);
    })
    .Case([&](JsirMemberExpressionRefOp op) {
      return VisitMemberExpressionRef(op);
    })
    .Case([&](JsirParenthesizedExpressionRefOp op) {
      return VisitParenthesizedExpressionRef(op);
    })
    .Case([&](JsirObjectPatternRefOp op) {
      return VisitObjectPatternRef(op);
    })
    .Case([&](JsirArrayPatternRefOp op) {
      return VisitArrayPatternRef(op);
    })
    .Case([&](JsirRestElementRefOp op) {
      return VisitRestElementRef(op);
    })
    .Case([&](JsirAssignmentPatternRefOp op) {
      return VisitAssignmentPatternRef(op);
    })
    .Default([&](mlir::Operation* op) {
      return absl::InvalidArgumentError("Unrecognized op");
    });
}

absl::StatusOr<std::unique_ptr<JsLVal>>
JsirToAst::VisitLValRef(JsirLValRefOpInterface op) {
  using Ret = absl::StatusOr<std::unique_ptr<JsLVal>>;
  return llvm::TypeSwitch<mlir::Operation*, Ret>(op)
    .Case([&](JsirIdentifierRefOp op) {
      return VisitIdentifierRef(op);
    })
    .Case([&](JsirMemberExpressionRefOp op) {
      return VisitMemberExpressionRef(op);
    })
    .Case([&](JsirParenthesizedExpressionRefOp op) {
      return VisitParenthesizedExpressionRef(op);
    })
    .Case([&](JsirObjectPatternRefOp op) {
      return VisitObjectPatternRef(op);
    })
    .Case([&](JsirArrayPatternRefOp op) {
      return VisitArrayPatternRef(op);
    })
    .Case([&](JsirRestElementRefOp op) {
      return VisitRestElementRef(op);
    })
    .Case([&](JsirAssignmentPatternRefOp op) {
      return VisitAssignmentPatternRef(op);
    })
    .Default([&](mlir::Operation* op) {
      return absl::InvalidArgumentError("Unrecognized op");
    });
}

absl::StatusOr<std::unique_ptr<JsIdentifier>>
JsirToAst::VisitIdentifier(JsirIdentifierOp op) {
  std::string name = op.getNameAttr().str();
  return Create<JsIdentifier>(
      op,
      std::move(name));
}

absl::StatusOr<std::unique_ptr<JsIdentifier>>
JsirToAst::VisitIdentifierRef(JsirIdentifierRefOp op) {
  std::string name = op.getNameAttr().str();
  return Create<JsIdentifier>(
      op,
      std::move(name));
}

absl::StatusOr<std::unique_ptr<JsPrivateName>>
JsirToAst::VisitPrivateName(JsirPrivateNameOp op) {
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsIdentifier> id, VisitIdentifierAttr(op.getIdAttr()));
  return Create<JsPrivateName>(
      op,
      std::move(id));
}

absl::StatusOr<std::unique_ptr<JsLiteral>>
JsirToAst::VisitLiteral(JsirLiteralOpInterface op) {
  using Ret = absl::StatusOr<std::unique_ptr<JsLiteral>>;
  return llvm::TypeSwitch<mlir::Operation*, Ret>(op)
    .Case([&](JsirRegExpLiteralOp op) {
      return VisitRegExpLiteral(op);
    })
    .Case([&](JsirNullLiteralOp op) {
      return VisitNullLiteral(op);
    })
    .Case([&](JsirStringLiteralOp op) {
      return VisitStringLiteral(op);
    })
    .Case([&](JsirBooleanLiteralOp op) {
      return VisitBooleanLiteral(op);
    })
    .Case([&](JsirNumericLiteralOp op) {
      return VisitNumericLiteral(op);
    })
    .Case([&](JsirBigIntLiteralOp op) {
      return VisitBigIntLiteral(op);
    })
    .Default([&](mlir::Operation* op) {
      return absl::InvalidArgumentError("Unrecognized op");
    });
}

absl::StatusOr<std::unique_ptr<JsRegExpLiteral>>
JsirToAst::VisitRegExpLiteral(JsirRegExpLiteralOp op) {
  std::string pattern = op.getPatternAttr().str();
  std::string flags = op.getFlagsAttr().str();
  std::optional<std::unique_ptr<JsRegExpLiteralExtra>> extra;
  if (op.getExtraAttr() != nullptr) {
    MALDOCA_ASSIGN_OR_RETURN(extra, VisitRegExpLiteralExtraAttr(op.getExtraAttr()));
  }
  return Create<JsRegExpLiteral>(
      op,
      std::move(pattern),
      std::move(flags),
      std::move(extra));
}

absl::StatusOr<std::unique_ptr<JsNullLiteral>>
JsirToAst::VisitNullLiteral(JsirNullLiteralOp op) {
  return Create<JsNullLiteral>(
      op);
}

absl::StatusOr<std::unique_ptr<JsStringLiteral>>
JsirToAst::VisitStringLiteral(JsirStringLiteralOp op) {
  std::string value = op.getValueAttr().str();
  std::optional<std::unique_ptr<JsStringLiteralExtra>> extra;
  if (op.getExtraAttr() != nullptr) {
    MALDOCA_ASSIGN_OR_RETURN(extra, VisitStringLiteralExtraAttr(op.getExtraAttr()));
  }
  return Create<JsStringLiteral>(
      op,
      std::move(value),
      std::move(extra));
}

absl::StatusOr<std::unique_ptr<JsBooleanLiteral>>
JsirToAst::VisitBooleanLiteral(JsirBooleanLiteralOp op) {
  bool value = op.getValueAttr().getValue();
  return Create<JsBooleanLiteral>(
      op,
      std::move(value));
}

absl::StatusOr<std::unique_ptr<JsNumericLiteral>>
JsirToAst::VisitNumericLiteral(JsirNumericLiteralOp op) {
  double value = op.getValueAttr().getValueAsDouble();
  std::optional<std::unique_ptr<JsNumericLiteralExtra>> extra;
  if (op.getExtraAttr() != nullptr) {
    MALDOCA_ASSIGN_OR_RETURN(extra, VisitNumericLiteralExtraAttr(op.getExtraAttr()));
  }
  return Create<JsNumericLiteral>(
      op,
      std::move(value),
      std::move(extra));
}

absl::StatusOr<std::unique_ptr<JsBigIntLiteral>>
JsirToAst::VisitBigIntLiteral(JsirBigIntLiteralOp op) {
  std::string value = op.getValueAttr().str();
  std::optional<std::unique_ptr<JsBigIntLiteralExtra>> extra;
  if (op.getExtraAttr() != nullptr) {
    MALDOCA_ASSIGN_OR_RETURN(extra, VisitBigIntLiteralExtraAttr(op.getExtraAttr()));
  }
  return Create<JsBigIntLiteral>(
      op,
      std::move(value),
      std::move(extra));
}

absl::StatusOr<std::unique_ptr<JsBlockStatement>>
JsirToAst::VisitBlockStatement(JshirBlockStatementOp op) {
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_body_block, GetStmtsRegionBlock(op.getBody()));
  std::vector<std::unique_ptr<JsStatement>> body;
  for (mlir::Operation& mlir_body_element_unchecked : *mlir_body_block) {
    auto body_element_op = llvm::dyn_cast<JsirStatementOpInterface>(mlir_body_element_unchecked);
    if (body_element_op == nullptr) {
      continue;
    }
    MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsStatement> body_element, VisitStatement(body_element_op));
    body.push_back(std::move(body_element));
  }
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_directives_block, GetStmtsRegionBlock(op.getDirectives()));
  std::vector<std::unique_ptr<JsDirective>> directives;
  for (mlir::Operation& mlir_directives_element_unchecked : *mlir_directives_block) {
    auto directives_element_op = llvm::dyn_cast<JsirDirectiveOp>(mlir_directives_element_unchecked);
    if (directives_element_op == nullptr) {
      continue;
    }
    MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsDirective> directives_element, VisitDirective(directives_element_op));
    directives.push_back(std::move(directives_element));
  }
  return Create<JsBlockStatement>(
      op,
      std::move(body),
      std::move(directives));
}

absl::StatusOr<std::unique_ptr<JsExpressionStatement>>
JsirToAst::VisitExpressionStatement(JsirExpressionStatementOp op) {
  auto expression_op = llvm::dyn_cast<JsirExpressionOpInterface>(op.getExpression().getDefiningOp());
  if (expression_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirExpressionOpInterface, got ",
                     op.getExpression().getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsExpression> expression, VisitExpression(expression_op));
  return Create<JsExpressionStatement>(
      op,
      std::move(expression));
}

absl::StatusOr<std::unique_ptr<JsEmptyStatement>>
JsirToAst::VisitEmptyStatement(JsirEmptyStatementOp op) {
  return Create<JsEmptyStatement>(
      op);
}

absl::StatusOr<std::unique_ptr<JsDebuggerStatement>>
JsirToAst::VisitDebuggerStatement(JsirDebuggerStatementOp op) {
  return Create<JsDebuggerStatement>(
      op);
}

absl::StatusOr<std::unique_ptr<JsWithStatement>>
JsirToAst::VisitWithStatement(JshirWithStatementOp op) {
  auto object_op = llvm::dyn_cast<JsirExpressionOpInterface>(op.getObject().getDefiningOp());
  if (object_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirExpressionOpInterface, got ",
                     op.getObject().getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsExpression> object, VisitExpression(object_op));
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_body_operation, GetStmtRegionOperation(op.getBody()));
  auto body_op = llvm::dyn_cast<JsirStatementOpInterface>(mlir_body_operation);
  if (body_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirStatementOpInterface, got ",
                     mlir_body_operation->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsStatement> body, VisitStatement(body_op));
  return Create<JsWithStatement>(
      op,
      std::move(object),
      std::move(body));
}

absl::StatusOr<std::unique_ptr<JsReturnStatement>>
JsirToAst::VisitReturnStatement(JsirReturnStatementOp op) {
  std::optional<std::unique_ptr<JsExpression>> argument;
  if (op.getArgument() != nullptr) {
    auto argument_op = llvm::dyn_cast<JsirExpressionOpInterface>(op.getArgument().getDefiningOp());
    if (argument_op == nullptr) {
      return absl::InvalidArgumentError(
          absl::StrCat("Expected JsirExpressionOpInterface, got ",
                       op.getArgument().getDefiningOp()->getName().getStringRef().str(), "."));
    }
    MALDOCA_ASSIGN_OR_RETURN(argument, VisitExpression(argument_op));
  }
  return Create<JsReturnStatement>(
      op,
      std::move(argument));
}

absl::StatusOr<std::unique_ptr<JsLabeledStatement>>
JsirToAst::VisitLabeledStatement(JshirLabeledStatementOp op) {
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsIdentifier> label, VisitIdentifierAttr(op.getLabelAttr()));
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_body_operation, GetStmtRegionOperation(op.getBody()));
  auto body_op = llvm::dyn_cast<JsirStatementOpInterface>(mlir_body_operation);
  if (body_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirStatementOpInterface, got ",
                     mlir_body_operation->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsStatement> body, VisitStatement(body_op));
  return Create<JsLabeledStatement>(
      op,
      std::move(label),
      std::move(body));
}

absl::StatusOr<std::unique_ptr<JsIfStatement>>
JsirToAst::VisitIfStatement(JshirIfStatementOp op) {
  auto test_op = llvm::dyn_cast<JsirExpressionOpInterface>(op.getTest().getDefiningOp());
  if (test_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirExpressionOpInterface, got ",
                     op.getTest().getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsExpression> test, VisitExpression(test_op));
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_consequent_operation, GetStmtRegionOperation(op.getConsequent()));
  auto consequent_op = llvm::dyn_cast<JsirStatementOpInterface>(mlir_consequent_operation);
  if (consequent_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirStatementOpInterface, got ",
                     mlir_consequent_operation->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsStatement> consequent, VisitStatement(consequent_op));
  std::optional<std::unique_ptr<JsStatement>> alternate;
  if (!op.getAlternate().empty()) {
    MALDOCA_ASSIGN_OR_RETURN(auto mlir_alternate_operation, GetStmtRegionOperation(op.getAlternate()));
    auto alternate_op = llvm::dyn_cast<JsirStatementOpInterface>(mlir_alternate_operation);
    if (alternate_op == nullptr) {
      return absl::InvalidArgumentError(
          absl::StrCat("Expected JsirStatementOpInterface, got ",
                       mlir_alternate_operation->getName().getStringRef().str(), "."));
    }
    MALDOCA_ASSIGN_OR_RETURN(alternate, VisitStatement(alternate_op));
  }
  return Create<JsIfStatement>(
      op,
      std::move(test),
      std::move(consequent),
      std::move(alternate));
}

absl::StatusOr<std::unique_ptr<JsSwitchCase>>
JsirToAst::VisitSwitchCase(JshirSwitchCaseOp op) {
  std::optional<std::unique_ptr<JsExpression>> test;
  if (!op.getTest().empty()) {
    MALDOCA_ASSIGN_OR_RETURN(auto mlir_test_value, GetExprRegionValue(op.getTest()));
    auto test_op = llvm::dyn_cast<JsirExpressionOpInterface>(mlir_test_value.getDefiningOp());
    if (test_op == nullptr) {
      return absl::InvalidArgumentError(
          absl::StrCat("Expected JsirExpressionOpInterface, got ",
                       mlir_test_value.getDefiningOp()->getName().getStringRef().str(), "."));
    }
    MALDOCA_ASSIGN_OR_RETURN(test, VisitExpression(test_op));
  }
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_consequent_block, GetStmtsRegionBlock(op.getConsequent()));
  std::vector<std::unique_ptr<JsStatement>> consequent;
  for (mlir::Operation& mlir_consequent_element_unchecked : *mlir_consequent_block) {
    auto consequent_element_op = llvm::dyn_cast<JsirStatementOpInterface>(mlir_consequent_element_unchecked);
    if (consequent_element_op == nullptr) {
      continue;
    }
    MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsStatement> consequent_element, VisitStatement(consequent_element_op));
    consequent.push_back(std::move(consequent_element));
  }
  return Create<JsSwitchCase>(
      op,
      std::move(test),
      std::move(consequent));
}

absl::StatusOr<std::unique_ptr<JsSwitchStatement>>
JsirToAst::VisitSwitchStatement(JshirSwitchStatementOp op) {
  auto discriminant_op = llvm::dyn_cast<JsirExpressionOpInterface>(op.getDiscriminant().getDefiningOp());
  if (discriminant_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirExpressionOpInterface, got ",
                     op.getDiscriminant().getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsExpression> discriminant, VisitExpression(discriminant_op));
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_cases_block, GetStmtsRegionBlock(op.getCases()));
  std::vector<std::unique_ptr<JsSwitchCase>> cases;
  for (mlir::Operation& mlir_cases_element_unchecked : *mlir_cases_block) {
    auto cases_element_op = llvm::dyn_cast<JshirSwitchCaseOp>(mlir_cases_element_unchecked);
    if (cases_element_op == nullptr) {
      continue;
    }
    MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsSwitchCase> cases_element, VisitSwitchCase(cases_element_op));
    cases.push_back(std::move(cases_element));
  }
  return Create<JsSwitchStatement>(
      op,
      std::move(discriminant),
      std::move(cases));
}

absl::StatusOr<std::unique_ptr<JsThrowStatement>>
JsirToAst::VisitThrowStatement(JsirThrowStatementOp op) {
  auto argument_op = llvm::dyn_cast<JsirExpressionOpInterface>(op.getArgument().getDefiningOp());
  if (argument_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirExpressionOpInterface, got ",
                     op.getArgument().getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsExpression> argument, VisitExpression(argument_op));
  return Create<JsThrowStatement>(
      op,
      std::move(argument));
}

absl::StatusOr<std::unique_ptr<JsCatchClause>>
JsirToAst::VisitCatchClause(JshirCatchClauseOp op) {
  std::optional<std::unique_ptr<JsPattern>> param;
  if (op.getParam() != nullptr) {
    auto param_op = llvm::dyn_cast<JsirPatternRefOpInterface>(op.getParam().getDefiningOp());
    if (param_op == nullptr) {
      return absl::InvalidArgumentError(
          absl::StrCat("Expected JsirPatternRefOpInterface, got ",
                       op.getParam().getDefiningOp()->getName().getStringRef().str(), "."));
    }
    MALDOCA_ASSIGN_OR_RETURN(param, VisitPatternRef(param_op));
  }
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_body_operation, GetStmtRegionOperation(op.getBody()));
  auto body_op = llvm::dyn_cast<JshirBlockStatementOp>(mlir_body_operation);
  if (body_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JshirBlockStatementOp, got ",
                     mlir_body_operation->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsBlockStatement> body, VisitBlockStatement(body_op));
  return Create<JsCatchClause>(
      op,
      std::move(param),
      std::move(body));
}

absl::StatusOr<std::unique_ptr<JsTryStatement>>
JsirToAst::VisitTryStatement(JshirTryStatementOp op) {
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_block_operation, GetStmtRegionOperation(op.getBlock()));
  auto block_op = llvm::dyn_cast<JshirBlockStatementOp>(mlir_block_operation);
  if (block_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JshirBlockStatementOp, got ",
                     mlir_block_operation->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsBlockStatement> block, VisitBlockStatement(block_op));
  std::optional<std::unique_ptr<JsCatchClause>> handler;
  if (!op.getHandler().empty()) {
    MALDOCA_ASSIGN_OR_RETURN(auto mlir_handler_operation, GetStmtRegionOperation(op.getHandler()));
    auto handler_op = llvm::dyn_cast<JshirCatchClauseOp>(mlir_handler_operation);
    if (handler_op == nullptr) {
      return absl::InvalidArgumentError(
          absl::StrCat("Expected JshirCatchClauseOp, got ",
                       mlir_handler_operation->getName().getStringRef().str(), "."));
    }
    MALDOCA_ASSIGN_OR_RETURN(handler, VisitCatchClause(handler_op));
  }
  std::optional<std::unique_ptr<JsBlockStatement>> finalizer;
  if (!op.getFinalizer().empty()) {
    MALDOCA_ASSIGN_OR_RETURN(auto mlir_finalizer_operation, GetStmtRegionOperation(op.getFinalizer()));
    auto finalizer_op = llvm::dyn_cast<JshirBlockStatementOp>(mlir_finalizer_operation);
    if (finalizer_op == nullptr) {
      return absl::InvalidArgumentError(
          absl::StrCat("Expected JshirBlockStatementOp, got ",
                       mlir_finalizer_operation->getName().getStringRef().str(), "."));
    }
    MALDOCA_ASSIGN_OR_RETURN(finalizer, VisitBlockStatement(finalizer_op));
  }
  return Create<JsTryStatement>(
      op,
      std::move(block),
      std::move(handler),
      std::move(finalizer));
}

absl::StatusOr<std::unique_ptr<JsWhileStatement>>
JsirToAst::VisitWhileStatement(JshirWhileStatementOp op) {
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_test_value, GetExprRegionValue(op.getTest()));
  auto test_op = llvm::dyn_cast<JsirExpressionOpInterface>(mlir_test_value.getDefiningOp());
  if (test_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirExpressionOpInterface, got ",
                     mlir_test_value.getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsExpression> test, VisitExpression(test_op));
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_body_operation, GetStmtRegionOperation(op.getBody()));
  auto body_op = llvm::dyn_cast<JsirStatementOpInterface>(mlir_body_operation);
  if (body_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirStatementOpInterface, got ",
                     mlir_body_operation->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsStatement> body, VisitStatement(body_op));
  return Create<JsWhileStatement>(
      op,
      std::move(test),
      std::move(body));
}

absl::StatusOr<std::unique_ptr<JsDoWhileStatement>>
JsirToAst::VisitDoWhileStatement(JshirDoWhileStatementOp op) {
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_body_operation, GetStmtRegionOperation(op.getBody()));
  auto body_op = llvm::dyn_cast<JsirStatementOpInterface>(mlir_body_operation);
  if (body_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirStatementOpInterface, got ",
                     mlir_body_operation->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsStatement> body, VisitStatement(body_op));
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_test_value, GetExprRegionValue(op.getTest()));
  auto test_op = llvm::dyn_cast<JsirExpressionOpInterface>(mlir_test_value.getDefiningOp());
  if (test_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirExpressionOpInterface, got ",
                     mlir_test_value.getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsExpression> test, VisitExpression(test_op));
  return Create<JsDoWhileStatement>(
      op,
      std::move(body),
      std::move(test));
}

absl::StatusOr<std::unique_ptr<JsDeclaration>>
JsirToAst::VisitDeclaration(JsirDeclarationOpInterface op) {
  using Ret = absl::StatusOr<std::unique_ptr<JsDeclaration>>;
  return llvm::TypeSwitch<mlir::Operation*, Ret>(op)
    .Case([&](JsirFunctionDeclarationOp op) {
      return VisitFunctionDeclaration(op);
    })
    .Case([&](JsirVariableDeclarationOp op) {
      return VisitVariableDeclaration(op);
    })
    .Case([&](JsirClassDeclarationOp op) {
      return VisitClassDeclaration(op);
    })
    .Default([&](mlir::Operation* op) {
      return absl::InvalidArgumentError("Unrecognized op");
    });
}

absl::StatusOr<std::unique_ptr<JsVariableDeclarator>>
JsirToAst::VisitVariableDeclarator(JsirVariableDeclaratorOp op) {
  auto id_op = llvm::dyn_cast<JsirLValRefOpInterface>(op.getId().getDefiningOp());
  if (id_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirLValRefOpInterface, got ",
                     op.getId().getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsLVal> id, VisitLValRef(id_op));
  std::optional<std::unique_ptr<JsExpression>> init;
  if (op.getInit() != nullptr) {
    auto init_op = llvm::dyn_cast<JsirExpressionOpInterface>(op.getInit().getDefiningOp());
    if (init_op == nullptr) {
      return absl::InvalidArgumentError(
          absl::StrCat("Expected JsirExpressionOpInterface, got ",
                       op.getInit().getDefiningOp()->getName().getStringRef().str(), "."));
    }
    MALDOCA_ASSIGN_OR_RETURN(init, VisitExpression(init_op));
  }
  return Create<JsVariableDeclarator>(
      op,
      std::move(id),
      std::move(init));
}

absl::StatusOr<std::unique_ptr<JsVariableDeclaration>>
JsirToAst::VisitVariableDeclaration(JsirVariableDeclarationOp op) {
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_declarations_values, GetExprsRegionValues(op.getDeclarations()));
  std::vector<std::unique_ptr<JsVariableDeclarator>> declarations;
  for (mlir::Value mlir_declarations_element_unchecked : mlir_declarations_values) {
    auto declarations_element_op = llvm::dyn_cast<JsirVariableDeclaratorOp>(mlir_declarations_element_unchecked.getDefiningOp());
    if (declarations_element_op == nullptr) {
      return absl::InvalidArgumentError(
          absl::StrCat("Expected JsirVariableDeclaratorOp, got ",
                       mlir_declarations_element_unchecked.getDefiningOp()->getName().getStringRef().str(), "."));
    }
    MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsVariableDeclarator> declarations_element, VisitVariableDeclarator(declarations_element_op));
    declarations.push_back(std::move(declarations_element));
  }
  std::string kind = op.getKindAttr().str();
  return Create<JsVariableDeclaration>(
      op,
      std::move(declarations),
      std::move(kind));
}

absl::StatusOr<std::unique_ptr<JsFunctionDeclaration>>
JsirToAst::VisitFunctionDeclaration(JsirFunctionDeclarationOp op) {
  std::optional<std::unique_ptr<JsIdentifier>> id;
  if (op.getIdAttr() != nullptr) {
    MALDOCA_ASSIGN_OR_RETURN(id, VisitIdentifierAttr(op.getIdAttr()));
  }
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_params_values, GetExprsRegionValues(op.getParams()));
  std::vector<std::unique_ptr<JsPattern>> params;
  for (mlir::Value mlir_params_element_unchecked : mlir_params_values) {
    auto params_element_op = llvm::dyn_cast<JsirPatternRefOpInterface>(mlir_params_element_unchecked.getDefiningOp());
    if (params_element_op == nullptr) {
      return absl::InvalidArgumentError(
          absl::StrCat("Expected JsirPatternRefOpInterface, got ",
                       mlir_params_element_unchecked.getDefiningOp()->getName().getStringRef().str(), "."));
    }
    MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsPattern> params_element, VisitPatternRef(params_element_op));
    params.push_back(std::move(params_element));
  }
  bool generator = op.getGeneratorAttr().getValue();
  bool async = op.getAsyncAttr().getValue();
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_body_operation, GetStmtRegionOperation(op.getBody()));
  auto body_op = llvm::dyn_cast<JshirBlockStatementOp>(mlir_body_operation);
  if (body_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JshirBlockStatementOp, got ",
                     mlir_body_operation->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsBlockStatement> body, VisitBlockStatement(body_op));
  return Create<JsFunctionDeclaration>(
      op,
      std::move(id),
      std::move(params),
      std::move(generator),
      std::move(async),
      std::move(body));
}

absl::StatusOr<std::unique_ptr<JsSuper>>
JsirToAst::VisitSuper(JsirSuperOp op) {
  return Create<JsSuper>(
      op);
}

absl::StatusOr<std::unique_ptr<JsImport>>
JsirToAst::VisitImport(JsirImportOp op) {
  return Create<JsImport>(
      op);
}

absl::StatusOr<std::unique_ptr<JsThisExpression>>
JsirToAst::VisitThisExpression(JsirThisExpressionOp op) {
  return Create<JsThisExpression>(
      op);
}

absl::StatusOr<std::unique_ptr<JsYieldExpression>>
JsirToAst::VisitYieldExpression(JsirYieldExpressionOp op) {
  std::optional<std::unique_ptr<JsExpression>> argument;
  if (op.getArgument() != nullptr) {
    auto argument_op = llvm::dyn_cast<JsirExpressionOpInterface>(op.getArgument().getDefiningOp());
    if (argument_op == nullptr) {
      return absl::InvalidArgumentError(
          absl::StrCat("Expected JsirExpressionOpInterface, got ",
                       op.getArgument().getDefiningOp()->getName().getStringRef().str(), "."));
    }
    MALDOCA_ASSIGN_OR_RETURN(argument, VisitExpression(argument_op));
  }
  bool delegate = op.getDelegateAttr().getValue();
  return Create<JsYieldExpression>(
      op,
      std::move(argument),
      std::move(delegate));
}

absl::StatusOr<std::unique_ptr<JsAwaitExpression>>
JsirToAst::VisitAwaitExpression(JsirAwaitExpressionOp op) {
  std::optional<std::unique_ptr<JsExpression>> argument;
  if (op.getArgument() != nullptr) {
    auto argument_op = llvm::dyn_cast<JsirExpressionOpInterface>(op.getArgument().getDefiningOp());
    if (argument_op == nullptr) {
      return absl::InvalidArgumentError(
          absl::StrCat("Expected JsirExpressionOpInterface, got ",
                       op.getArgument().getDefiningOp()->getName().getStringRef().str(), "."));
    }
    MALDOCA_ASSIGN_OR_RETURN(argument, VisitExpression(argument_op));
  }
  return Create<JsAwaitExpression>(
      op,
      std::move(argument));
}

absl::StatusOr<std::unique_ptr<JsSpreadElement>>
JsirToAst::VisitSpreadElement(JsirSpreadElementOp op) {
  auto argument_op = llvm::dyn_cast<JsirExpressionOpInterface>(op.getArgument().getDefiningOp());
  if (argument_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirExpressionOpInterface, got ",
                     op.getArgument().getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsExpression> argument, VisitExpression(argument_op));
  return Create<JsSpreadElement>(
      op,
      std::move(argument));
}

absl::StatusOr<std::unique_ptr<JsArrayExpression>>
JsirToAst::VisitArrayExpression(JsirArrayExpressionOp op) {
  std::vector<std::optional<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>>> elements;
  for (mlir::Value mlir_elements_element_unchecked : op.getElements()) {
    std::optional<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>> elements_element;
    if (!llvm::isa<JsirNoneOp>(mlir_elements_element_unchecked.getDefiningOp())) {
      if (auto mlir_elements_element = llvm::dyn_cast<JsirExpressionOpInterface>(mlir_elements_element_unchecked.getDefiningOp())) {
        MALDOCA_ASSIGN_OR_RETURN(elements_element, VisitExpression(mlir_elements_element));
      } else if (auto mlir_elements_element = llvm::dyn_cast<JsirSpreadElementOp>(mlir_elements_element_unchecked.getDefiningOp())) {
        MALDOCA_ASSIGN_OR_RETURN(elements_element, VisitSpreadElement(mlir_elements_element));
      } else {
        return absl::InvalidArgumentError("mlir_elements_element_unchecked.getDefiningOp() has invalid type.");
      }
    }
    elements.push_back(std::move(elements_element));
  }
  return Create<JsArrayExpression>(
      op,
      std::move(elements));
}

absl::StatusOr<std::unique_ptr<JsFunctionExpression>>
JsirToAst::VisitFunctionExpression(JsirFunctionExpressionOp op) {
  std::optional<std::unique_ptr<JsIdentifier>> id;
  if (op.getIdAttr() != nullptr) {
    MALDOCA_ASSIGN_OR_RETURN(id, VisitIdentifierAttr(op.getIdAttr()));
  }
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_params_values, GetExprsRegionValues(op.getParams()));
  std::vector<std::unique_ptr<JsPattern>> params;
  for (mlir::Value mlir_params_element_unchecked : mlir_params_values) {
    auto params_element_op = llvm::dyn_cast<JsirPatternRefOpInterface>(mlir_params_element_unchecked.getDefiningOp());
    if (params_element_op == nullptr) {
      return absl::InvalidArgumentError(
          absl::StrCat("Expected JsirPatternRefOpInterface, got ",
                       mlir_params_element_unchecked.getDefiningOp()->getName().getStringRef().str(), "."));
    }
    MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsPattern> params_element, VisitPatternRef(params_element_op));
    params.push_back(std::move(params_element));
  }
  bool generator = op.getGeneratorAttr().getValue();
  bool async = op.getAsyncAttr().getValue();
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_body_operation, GetStmtRegionOperation(op.getBody()));
  auto body_op = llvm::dyn_cast<JshirBlockStatementOp>(mlir_body_operation);
  if (body_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JshirBlockStatementOp, got ",
                     mlir_body_operation->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsBlockStatement> body, VisitBlockStatement(body_op));
  return Create<JsFunctionExpression>(
      op,
      std::move(id),
      std::move(params),
      std::move(generator),
      std::move(async),
      std::move(body));
}

absl::StatusOr<std::unique_ptr<JsUnaryExpression>>
JsirToAst::VisitUnaryExpression(JsirUnaryExpressionOp op) {
  MALDOCA_ASSIGN_OR_RETURN(JsUnaryOperator operator_, StringToJsUnaryOperator(op.getOperator_Attr().str()));
  bool prefix = op.getPrefixAttr().getValue();
  auto argument_op = llvm::dyn_cast<JsirExpressionOpInterface>(op.getArgument().getDefiningOp());
  if (argument_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirExpressionOpInterface, got ",
                     op.getArgument().getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsExpression> argument, VisitExpression(argument_op));
  return Create<JsUnaryExpression>(
      op,
      std::move(operator_),
      std::move(prefix),
      std::move(argument));
}

absl::StatusOr<std::unique_ptr<JsUpdateExpression>>
JsirToAst::VisitUpdateExpression(JsirUpdateExpressionOp op) {
  MALDOCA_ASSIGN_OR_RETURN(JsUpdateOperator operator_, StringToJsUpdateOperator(op.getOperator_Attr().str()));
  auto argument_op = llvm::dyn_cast<JsirLValRefOpInterface>(op.getArgument().getDefiningOp());
  if (argument_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirLValRefOpInterface, got ",
                     op.getArgument().getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsLVal> argument, VisitLValRef(argument_op));
  bool prefix = op.getPrefixAttr().getValue();
  return Create<JsUpdateExpression>(
      op,
      std::move(operator_),
      std::move(argument),
      std::move(prefix));
}

absl::StatusOr<std::unique_ptr<JsBinaryExpression>>
JsirToAst::VisitBinaryExpression(JsirBinaryExpressionOp op) {
  MALDOCA_ASSIGN_OR_RETURN(JsBinaryOperator operator_, StringToJsBinaryOperator(op.getOperator_Attr().str()));
  std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsPrivateName>> left;
  if (auto mlir_left = llvm::dyn_cast<JsirExpressionOpInterface>(op.getLeft().getDefiningOp())) {
    MALDOCA_ASSIGN_OR_RETURN(left, VisitExpression(mlir_left));
  } else if (auto mlir_left = llvm::dyn_cast<JsirPrivateNameOp>(op.getLeft().getDefiningOp())) {
    MALDOCA_ASSIGN_OR_RETURN(left, VisitPrivateName(mlir_left));
  } else {
    return absl::InvalidArgumentError("op.getLeft().getDefiningOp() has invalid type.");
  }
  auto right_op = llvm::dyn_cast<JsirExpressionOpInterface>(op.getRight().getDefiningOp());
  if (right_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirExpressionOpInterface, got ",
                     op.getRight().getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsExpression> right, VisitExpression(right_op));
  return Create<JsBinaryExpression>(
      op,
      std::move(operator_),
      std::move(left),
      std::move(right));
}

absl::StatusOr<std::unique_ptr<JsAssignmentExpression>>
JsirToAst::VisitAssignmentExpression(JsirAssignmentExpressionOp op) {
  MALDOCA_ASSIGN_OR_RETURN(JsAssignmentOperator operator_, StringToJsAssignmentOperator(op.getOperator_Attr().str()));
  auto left_op = llvm::dyn_cast<JsirLValRefOpInterface>(op.getLeft().getDefiningOp());
  if (left_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirLValRefOpInterface, got ",
                     op.getLeft().getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsLVal> left, VisitLValRef(left_op));
  auto right_op = llvm::dyn_cast<JsirExpressionOpInterface>(op.getRight().getDefiningOp());
  if (right_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirExpressionOpInterface, got ",
                     op.getRight().getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsExpression> right, VisitExpression(right_op));
  return Create<JsAssignmentExpression>(
      op,
      std::move(operator_),
      std::move(left),
      std::move(right));
}

absl::StatusOr<std::unique_ptr<JsLogicalExpression>>
JsirToAst::VisitLogicalExpression(JshirLogicalExpressionOp op) {
  MALDOCA_ASSIGN_OR_RETURN(JsLogicalOperator operator_, StringToJsLogicalOperator(op.getOperator_Attr().str()));
  auto left_op = llvm::dyn_cast<JsirExpressionOpInterface>(op.getLeft().getDefiningOp());
  if (left_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirExpressionOpInterface, got ",
                     op.getLeft().getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsExpression> left, VisitExpression(left_op));
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_right_value, GetExprRegionValue(op.getRight()));
  auto right_op = llvm::dyn_cast<JsirExpressionOpInterface>(mlir_right_value.getDefiningOp());
  if (right_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirExpressionOpInterface, got ",
                     mlir_right_value.getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsExpression> right, VisitExpression(right_op));
  return Create<JsLogicalExpression>(
      op,
      std::move(operator_),
      std::move(left),
      std::move(right));
}

absl::StatusOr<std::unique_ptr<JsConditionalExpression>>
JsirToAst::VisitConditionalExpression(JshirConditionalExpressionOp op) {
  auto test_op = llvm::dyn_cast<JsirExpressionOpInterface>(op.getTest().getDefiningOp());
  if (test_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirExpressionOpInterface, got ",
                     op.getTest().getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsExpression> test, VisitExpression(test_op));
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_alternate_value, GetExprRegionValue(op.getAlternate()));
  auto alternate_op = llvm::dyn_cast<JsirExpressionOpInterface>(mlir_alternate_value.getDefiningOp());
  if (alternate_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirExpressionOpInterface, got ",
                     mlir_alternate_value.getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsExpression> alternate, VisitExpression(alternate_op));
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_consequent_value, GetExprRegionValue(op.getConsequent()));
  auto consequent_op = llvm::dyn_cast<JsirExpressionOpInterface>(mlir_consequent_value.getDefiningOp());
  if (consequent_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirExpressionOpInterface, got ",
                     mlir_consequent_value.getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsExpression> consequent, VisitExpression(consequent_op));
  return Create<JsConditionalExpression>(
      op,
      std::move(test),
      std::move(alternate),
      std::move(consequent));
}

absl::StatusOr<std::unique_ptr<JsCallExpression>>
JsirToAst::VisitCallExpression(JsirCallExpressionOp op) {
  std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSuper>, std::unique_ptr<JsImport>> callee;
  if (auto mlir_callee = llvm::dyn_cast<JsirExpressionOpInterface>(op.getCallee().getDefiningOp())) {
    MALDOCA_ASSIGN_OR_RETURN(callee, VisitExpression(mlir_callee));
  } else if (auto mlir_callee = llvm::dyn_cast<JsirSuperOp>(op.getCallee().getDefiningOp())) {
    MALDOCA_ASSIGN_OR_RETURN(callee, VisitSuper(mlir_callee));
  } else if (auto mlir_callee = llvm::dyn_cast<JsirImportOp>(op.getCallee().getDefiningOp())) {
    MALDOCA_ASSIGN_OR_RETURN(callee, VisitImport(mlir_callee));
  } else {
    return absl::InvalidArgumentError("op.getCallee().getDefiningOp() has invalid type.");
  }
  std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>> arguments;
  for (mlir::Value mlir_arguments_element_unchecked : op.getArguments()) {
    std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>> arguments_element;
    if (auto mlir_arguments_element = llvm::dyn_cast<JsirExpressionOpInterface>(mlir_arguments_element_unchecked.getDefiningOp())) {
      MALDOCA_ASSIGN_OR_RETURN(arguments_element, VisitExpression(mlir_arguments_element));
    } else if (auto mlir_arguments_element = llvm::dyn_cast<JsirSpreadElementOp>(mlir_arguments_element_unchecked.getDefiningOp())) {
      MALDOCA_ASSIGN_OR_RETURN(arguments_element, VisitSpreadElement(mlir_arguments_element));
    } else {
      return absl::InvalidArgumentError("mlir_arguments_element_unchecked.getDefiningOp() has invalid type.");
    }
    arguments.push_back(std::move(arguments_element));
  }
  return Create<JsCallExpression>(
      op,
      std::move(callee),
      std::move(arguments));
}

absl::StatusOr<std::unique_ptr<JsOptionalCallExpression>>
JsirToAst::VisitOptionalCallExpression(JsirOptionalCallExpressionOp op) {
  auto callee_op = llvm::dyn_cast<JsirExpressionOpInterface>(op.getCallee().getDefiningOp());
  if (callee_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirExpressionOpInterface, got ",
                     op.getCallee().getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsExpression> callee, VisitExpression(callee_op));
  std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>> arguments;
  for (mlir::Value mlir_arguments_element_unchecked : op.getArguments()) {
    std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>> arguments_element;
    if (auto mlir_arguments_element = llvm::dyn_cast<JsirExpressionOpInterface>(mlir_arguments_element_unchecked.getDefiningOp())) {
      MALDOCA_ASSIGN_OR_RETURN(arguments_element, VisitExpression(mlir_arguments_element));
    } else if (auto mlir_arguments_element = llvm::dyn_cast<JsirSpreadElementOp>(mlir_arguments_element_unchecked.getDefiningOp())) {
      MALDOCA_ASSIGN_OR_RETURN(arguments_element, VisitSpreadElement(mlir_arguments_element));
    } else {
      return absl::InvalidArgumentError("mlir_arguments_element_unchecked.getDefiningOp() has invalid type.");
    }
    arguments.push_back(std::move(arguments_element));
  }
  bool optional = op.getOptionalAttr().getValue();
  return Create<JsOptionalCallExpression>(
      op,
      std::move(callee),
      std::move(arguments),
      std::move(optional));
}

absl::StatusOr<std::unique_ptr<JsNewExpression>>
JsirToAst::VisitNewExpression(JsirNewExpressionOp op) {
  std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSuper>, std::unique_ptr<JsImport>> callee;
  if (auto mlir_callee = llvm::dyn_cast<JsirExpressionOpInterface>(op.getCallee().getDefiningOp())) {
    MALDOCA_ASSIGN_OR_RETURN(callee, VisitExpression(mlir_callee));
  } else if (auto mlir_callee = llvm::dyn_cast<JsirSuperOp>(op.getCallee().getDefiningOp())) {
    MALDOCA_ASSIGN_OR_RETURN(callee, VisitSuper(mlir_callee));
  } else if (auto mlir_callee = llvm::dyn_cast<JsirImportOp>(op.getCallee().getDefiningOp())) {
    MALDOCA_ASSIGN_OR_RETURN(callee, VisitImport(mlir_callee));
  } else {
    return absl::InvalidArgumentError("op.getCallee().getDefiningOp() has invalid type.");
  }
  std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>> arguments;
  for (mlir::Value mlir_arguments_element_unchecked : op.getArguments()) {
    std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>> arguments_element;
    if (auto mlir_arguments_element = llvm::dyn_cast<JsirExpressionOpInterface>(mlir_arguments_element_unchecked.getDefiningOp())) {
      MALDOCA_ASSIGN_OR_RETURN(arguments_element, VisitExpression(mlir_arguments_element));
    } else if (auto mlir_arguments_element = llvm::dyn_cast<JsirSpreadElementOp>(mlir_arguments_element_unchecked.getDefiningOp())) {
      MALDOCA_ASSIGN_OR_RETURN(arguments_element, VisitSpreadElement(mlir_arguments_element));
    } else {
      return absl::InvalidArgumentError("mlir_arguments_element_unchecked.getDefiningOp() has invalid type.");
    }
    arguments.push_back(std::move(arguments_element));
  }
  return Create<JsNewExpression>(
      op,
      std::move(callee),
      std::move(arguments));
}

absl::StatusOr<std::unique_ptr<JsSequenceExpression>>
JsirToAst::VisitSequenceExpression(JsirSequenceExpressionOp op) {
  std::vector<std::unique_ptr<JsExpression>> expressions;
  for (mlir::Value mlir_expressions_element_unchecked : op.getExpressions()) {
    auto expressions_element_op = llvm::dyn_cast<JsirExpressionOpInterface>(mlir_expressions_element_unchecked.getDefiningOp());
    if (expressions_element_op == nullptr) {
      return absl::InvalidArgumentError(
          absl::StrCat("Expected JsirExpressionOpInterface, got ",
                       mlir_expressions_element_unchecked.getDefiningOp()->getName().getStringRef().str(), "."));
    }
    MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsExpression> expressions_element, VisitExpression(expressions_element_op));
    expressions.push_back(std::move(expressions_element));
  }
  return Create<JsSequenceExpression>(
      op,
      std::move(expressions));
}

absl::StatusOr<std::unique_ptr<JsTemplateElementValue>>
JsirToAst::VisitTemplateElementValue(JsirTemplateElementValueOp op) {
  std::optional<std::string> cooked;
  if (op.getCookedAttr() != nullptr) {
    cooked = op.getCookedAttr().str();
  }
  std::string raw = op.getRawAttr().str();
  return Create<JsTemplateElementValue>(
      op,
      std::move(cooked),
      std::move(raw));
}

absl::StatusOr<std::unique_ptr<JsTemplateElement>>
JsirToAst::VisitTemplateElement(JsirTemplateElementOp op) {
  bool tail = op.getTailAttr().getValue();
  auto value_op = llvm::dyn_cast<JsirTemplateElementValueOp>(op.getValue().getDefiningOp());
  if (value_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirTemplateElementValueOp, got ",
                     op.getValue().getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsTemplateElementValue> value, VisitTemplateElementValue(value_op));
  return Create<JsTemplateElement>(
      op,
      std::move(tail),
      std::move(value));
}

absl::StatusOr<std::unique_ptr<JsTemplateLiteral>>
JsirToAst::VisitTemplateLiteral(JsirTemplateLiteralOp op) {
  std::vector<std::unique_ptr<JsTemplateElement>> quasis;
  for (mlir::Value mlir_quasis_element_unchecked : op.getQuasis()) {
    auto quasis_element_op = llvm::dyn_cast<JsirTemplateElementOp>(mlir_quasis_element_unchecked.getDefiningOp());
    if (quasis_element_op == nullptr) {
      return absl::InvalidArgumentError(
          absl::StrCat("Expected JsirTemplateElementOp, got ",
                       mlir_quasis_element_unchecked.getDefiningOp()->getName().getStringRef().str(), "."));
    }
    MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsTemplateElement> quasis_element, VisitTemplateElement(quasis_element_op));
    quasis.push_back(std::move(quasis_element));
  }
  std::vector<std::unique_ptr<JsExpression>> expressions;
  for (mlir::Value mlir_expressions_element_unchecked : op.getExpressions()) {
    auto expressions_element_op = llvm::dyn_cast<JsirExpressionOpInterface>(mlir_expressions_element_unchecked.getDefiningOp());
    if (expressions_element_op == nullptr) {
      return absl::InvalidArgumentError(
          absl::StrCat("Expected JsirExpressionOpInterface, got ",
                       mlir_expressions_element_unchecked.getDefiningOp()->getName().getStringRef().str(), "."));
    }
    MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsExpression> expressions_element, VisitExpression(expressions_element_op));
    expressions.push_back(std::move(expressions_element));
  }
  return Create<JsTemplateLiteral>(
      op,
      std::move(quasis),
      std::move(expressions));
}

absl::StatusOr<std::unique_ptr<JsTaggedTemplateExpression>>
JsirToAst::VisitTaggedTemplateExpression(JsirTaggedTemplateExpressionOp op) {
  auto tag_op = llvm::dyn_cast<JsirExpressionOpInterface>(op.getTag().getDefiningOp());
  if (tag_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirExpressionOpInterface, got ",
                     op.getTag().getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsExpression> tag, VisitExpression(tag_op));
  auto quasi_op = llvm::dyn_cast<JsirTemplateLiteralOp>(op.getQuasi().getDefiningOp());
  if (quasi_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirTemplateLiteralOp, got ",
                     op.getQuasi().getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsTemplateLiteral> quasi, VisitTemplateLiteral(quasi_op));
  return Create<JsTaggedTemplateExpression>(
      op,
      std::move(tag),
      std::move(quasi));
}

absl::StatusOr<std::unique_ptr<JsRestElement>>
JsirToAst::VisitRestElementRef(JsirRestElementRefOp op) {
  auto argument_op = llvm::dyn_cast<JsirLValRefOpInterface>(op.getArgument().getDefiningOp());
  if (argument_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirLValRefOpInterface, got ",
                     op.getArgument().getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsLVal> argument, VisitLValRef(argument_op));
  return Create<JsRestElement>(
      op,
      std::move(argument));
}

absl::StatusOr<std::unique_ptr<JsObjectPattern>>
JsirToAst::VisitObjectPatternRef(JsirObjectPatternRefOp op) {
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_properties_values, GetExprsRegionValues(op.getProperties_()));
  std::vector<std::variant<std::unique_ptr<JsObjectProperty>, std::unique_ptr<JsRestElement>>> properties_;
  for (mlir::Value mlir_properties_element_unchecked : mlir_properties_values) {
    std::variant<std::unique_ptr<JsObjectProperty>, std::unique_ptr<JsRestElement>> properties_element;
    if (auto mlir_properties_element = llvm::dyn_cast<JsirObjectPropertyRefOp>(mlir_properties_element_unchecked.getDefiningOp())) {
      MALDOCA_ASSIGN_OR_RETURN(properties_element, VisitObjectPropertyRef(mlir_properties_element));
    } else if (auto mlir_properties_element = llvm::dyn_cast<JsirRestElementRefOp>(mlir_properties_element_unchecked.getDefiningOp())) {
      MALDOCA_ASSIGN_OR_RETURN(properties_element, VisitRestElementRef(mlir_properties_element));
    } else {
      return absl::InvalidArgumentError("mlir_properties_element_unchecked.getDefiningOp() has invalid type.");
    }
    properties_.push_back(std::move(properties_element));
  }
  return Create<JsObjectPattern>(
      op,
      std::move(properties_));
}

absl::StatusOr<std::unique_ptr<JsArrayPattern>>
JsirToAst::VisitArrayPatternRef(JsirArrayPatternRefOp op) {
  std::vector<std::optional<std::unique_ptr<JsPattern>>> elements;
  for (mlir::Value mlir_elements_element_unchecked : op.getElements()) {
    std::optional<std::unique_ptr<JsPattern>> elements_element;
    if (!llvm::isa<JsirNoneOp>(mlir_elements_element_unchecked.getDefiningOp())) {
      auto elements_element_op = llvm::dyn_cast<JsirPatternRefOpInterface>(mlir_elements_element_unchecked.getDefiningOp());
      if (elements_element_op == nullptr) {
        return absl::InvalidArgumentError(
            absl::StrCat("Expected JsirPatternRefOpInterface, got ",
                         mlir_elements_element_unchecked.getDefiningOp()->getName().getStringRef().str(), "."));
      }
      MALDOCA_ASSIGN_OR_RETURN(elements_element, VisitPatternRef(elements_element_op));
    }
    elements.push_back(std::move(elements_element));
  }
  return Create<JsArrayPattern>(
      op,
      std::move(elements));
}

absl::StatusOr<std::unique_ptr<JsAssignmentPattern>>
JsirToAst::VisitAssignmentPatternRef(JsirAssignmentPatternRefOp op) {
  auto left_op = llvm::dyn_cast<JsirPatternRefOpInterface>(op.getLeft().getDefiningOp());
  if (left_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirPatternRefOpInterface, got ",
                     op.getLeft().getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsPattern> left, VisitPatternRef(left_op));
  auto right_op = llvm::dyn_cast<JsirExpressionOpInterface>(op.getRight().getDefiningOp());
  if (right_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirExpressionOpInterface, got ",
                     op.getRight().getDefiningOp()->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsExpression> right, VisitExpression(right_op));
  return Create<JsAssignmentPattern>(
      op,
      std::move(left),
      std::move(right));
}

absl::StatusOr<std::unique_ptr<JsClassPrivateProperty>>
JsirToAst::VisitClassPrivateProperty(JsirClassPrivatePropertyOp op) {
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsPrivateName> key, VisitPrivateNameAttr(op.getKeyAttr()));
  std::optional<std::unique_ptr<JsExpression>> value;
  if (!op.getValue().empty()) {
    MALDOCA_ASSIGN_OR_RETURN(auto mlir_value_value, GetExprRegionValue(op.getValue()));
    auto value_op = llvm::dyn_cast<JsirExpressionOpInterface>(mlir_value_value.getDefiningOp());
    if (value_op == nullptr) {
      return absl::InvalidArgumentError(
          absl::StrCat("Expected JsirExpressionOpInterface, got ",
                       mlir_value_value.getDefiningOp()->getName().getStringRef().str(), "."));
    }
    MALDOCA_ASSIGN_OR_RETURN(value, VisitExpression(value_op));
  }
  bool static_ = op.getStatic_Attr().getValue();
  return Create<JsClassPrivateProperty>(
      op,
      std::move(key),
      std::move(value),
      std::move(static_));
}

absl::StatusOr<std::unique_ptr<JsClassBody>>
JsirToAst::VisitClassBody(JsirClassBodyOp op) {
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_body_block, GetStmtsRegionBlock(op.getBody()));
  std::vector<std::variant<std::unique_ptr<JsClassMethod>, std::unique_ptr<JsClassPrivateMethod>, std::unique_ptr<JsClassProperty>, std::unique_ptr<JsClassPrivateProperty>>> body;
  for (mlir::Operation& mlir_body_element_unchecked : *mlir_body_block) {
    std::variant<std::unique_ptr<JsClassMethod>, std::unique_ptr<JsClassPrivateMethod>, std::unique_ptr<JsClassProperty>, std::unique_ptr<JsClassPrivateProperty>> body_element;
    if (auto mlir_body_element = llvm::dyn_cast<JsirClassMethodOp>(mlir_body_element_unchecked)) {
      MALDOCA_ASSIGN_OR_RETURN(body_element, VisitClassMethod(mlir_body_element));
    } else if (auto mlir_body_element = llvm::dyn_cast<JsirClassPrivateMethodOp>(mlir_body_element_unchecked)) {
      MALDOCA_ASSIGN_OR_RETURN(body_element, VisitClassPrivateMethod(mlir_body_element));
    } else if (auto mlir_body_element = llvm::dyn_cast<JsirClassPropertyOp>(mlir_body_element_unchecked)) {
      MALDOCA_ASSIGN_OR_RETURN(body_element, VisitClassProperty(mlir_body_element));
    } else if (auto mlir_body_element = llvm::dyn_cast<JsirClassPrivatePropertyOp>(mlir_body_element_unchecked)) {
      MALDOCA_ASSIGN_OR_RETURN(body_element, VisitClassPrivateProperty(mlir_body_element));
    } else {
      continue;
    }
    body.push_back(std::move(body_element));
  }
  return Create<JsClassBody>(
      op,
      std::move(body));
}

absl::StatusOr<std::unique_ptr<JsClassDeclaration>>
JsirToAst::VisitClassDeclaration(JsirClassDeclarationOp op) {
  std::optional<std::unique_ptr<JsExpression>> super_class;
  if (op.getSuperClass() != nullptr) {
    auto super_class_op = llvm::dyn_cast<JsirExpressionOpInterface>(op.getSuperClass().getDefiningOp());
    if (super_class_op == nullptr) {
      return absl::InvalidArgumentError(
          absl::StrCat("Expected JsirExpressionOpInterface, got ",
                       op.getSuperClass().getDefiningOp()->getName().getStringRef().str(), "."));
    }
    MALDOCA_ASSIGN_OR_RETURN(super_class, VisitExpression(super_class_op));
  }
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_body_operation, GetStmtRegionOperation(op.getBody()));
  auto body_op = llvm::dyn_cast<JsirClassBodyOp>(mlir_body_operation);
  if (body_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirClassBodyOp, got ",
                     mlir_body_operation->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsClassBody> body, VisitClassBody(body_op));
  std::optional<std::unique_ptr<JsIdentifier>> id;
  if (op.getIdAttr() != nullptr) {
    MALDOCA_ASSIGN_OR_RETURN(id, VisitIdentifierAttr(op.getIdAttr()));
  }
  return Create<JsClassDeclaration>(
      op,
      std::move(super_class),
      std::move(body),
      std::move(id));
}

absl::StatusOr<std::unique_ptr<JsClassExpression>>
JsirToAst::VisitClassExpression(JsirClassExpressionOp op) {
  std::optional<std::unique_ptr<JsExpression>> super_class;
  if (op.getSuperClass() != nullptr) {
    auto super_class_op = llvm::dyn_cast<JsirExpressionOpInterface>(op.getSuperClass().getDefiningOp());
    if (super_class_op == nullptr) {
      return absl::InvalidArgumentError(
          absl::StrCat("Expected JsirExpressionOpInterface, got ",
                       op.getSuperClass().getDefiningOp()->getName().getStringRef().str(), "."));
    }
    MALDOCA_ASSIGN_OR_RETURN(super_class, VisitExpression(super_class_op));
  }
  MALDOCA_ASSIGN_OR_RETURN(auto mlir_body_operation, GetStmtRegionOperation(op.getBody()));
  auto body_op = llvm::dyn_cast<JsirClassBodyOp>(mlir_body_operation);
  if (body_op == nullptr) {
    return absl::InvalidArgumentError(
        absl::StrCat("Expected JsirClassBodyOp, got ",
                     mlir_body_operation->getName().getStringRef().str(), "."));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsClassBody> body, VisitClassBody(body_op));
  std::optional<std::unique_ptr<JsIdentifier>> id;
  if (op.getIdAttr() != nullptr) {
    MALDOCA_ASSIGN_OR_RETURN(id, VisitIdentifierAttr(op.getIdAttr()));
  }
  return Create<JsClassExpression>(
      op,
      std::move(super_class),
      std::move(body),
      std::move(id));
}

absl::StatusOr<std::unique_ptr<JsMetaProperty>>
JsirToAst::VisitMetaProperty(JsirMetaPropertyOp op) {
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsIdentifier> meta, VisitIdentifierAttr(op.getMetaAttr()));
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsIdentifier> property, VisitIdentifierAttr(op.getPropertyAttr()));
  return Create<JsMetaProperty>(
      op,
      std::move(meta),
      std::move(property));
}

absl::StatusOr<std::unique_ptr<JsModuleSpecifier>>
JsirToAst::VisitModuleSpecifierAttr(JsirModuleSpecifierAttrInterface attr) {
  using Ret = absl::StatusOr<std::unique_ptr<JsModuleSpecifier>>;
  return llvm::TypeSwitch<mlir::Attribute, Ret>(attr)
    .Case([&](JsirImportSpecifierAttr attr) {
      return VisitImportSpecifierAttr(attr);
    })
    .Case([&](JsirImportDefaultSpecifierAttr attr) {
      return VisitImportDefaultSpecifierAttr(attr);
    })
    .Case([&](JsirImportNamespaceSpecifierAttr attr) {
      return VisitImportNamespaceSpecifierAttr(attr);
    })
    .Case([&](JsirExportSpecifierAttr attr) {
      return VisitExportSpecifierAttr(attr);
    })
    .Default([&](mlir::Attribute op) {
      return absl::InvalidArgumentError("Unrecognized op");
    });
}

absl::StatusOr<std::unique_ptr<JsImportDeclaration>>
JsirToAst::VisitImportDeclaration(JsirImportDeclarationOp op) {
  std::vector<std::variant<std::unique_ptr<JsImportSpecifier>, std::unique_ptr<JsImportDefaultSpecifier>, std::unique_ptr<JsImportNamespaceSpecifier>>> specifiers;
  for (mlir::Attribute mlir_specifiers_element_unchecked : op.getSpecifiersAttr().getValue()) {
    std::variant<std::unique_ptr<JsImportSpecifier>, std::unique_ptr<JsImportDefaultSpecifier>, std::unique_ptr<JsImportNamespaceSpecifier>> specifiers_element;
    if (auto mlir_specifiers_element = llvm::dyn_cast<JsirImportSpecifierAttr>(mlir_specifiers_element_unchecked)) {
      MALDOCA_ASSIGN_OR_RETURN(specifiers_element, VisitImportSpecifierAttr(mlir_specifiers_element));
    } else if (auto mlir_specifiers_element = llvm::dyn_cast<JsirImportDefaultSpecifierAttr>(mlir_specifiers_element_unchecked)) {
      MALDOCA_ASSIGN_OR_RETURN(specifiers_element, VisitImportDefaultSpecifierAttr(mlir_specifiers_element));
    } else if (auto mlir_specifiers_element = llvm::dyn_cast<JsirImportNamespaceSpecifierAttr>(mlir_specifiers_element_unchecked)) {
      MALDOCA_ASSIGN_OR_RETURN(specifiers_element, VisitImportNamespaceSpecifierAttr(mlir_specifiers_element));
    } else {
      return absl::InvalidArgumentError("mlir_specifiers_element_unchecked has invalid type.");
    }
    specifiers.push_back(std::move(specifiers_element));
  }
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsStringLiteral> source, VisitStringLiteralAttr(op.getSourceAttr()));
  std::optional<std::unique_ptr<JsImportAttribute>> assertions;
  if (op.getAssertionsAttr() != nullptr) {
    MALDOCA_ASSIGN_OR_RETURN(assertions, VisitImportAttributeAttr(op.getAssertionsAttr()));
  }
  return Create<JsImportDeclaration>(
      op,
      std::move(specifiers),
      std::move(source),
      std::move(assertions));
}

absl::StatusOr<std::unique_ptr<JsExportNamedDeclaration>>
JsirToAst::VisitExportNamedDeclaration(JsirExportNamedDeclarationOp op) {
  std::optional<std::unique_ptr<JsDeclaration>> declaration;
  if (!op.getDeclaration().empty()) {
    MALDOCA_ASSIGN_OR_RETURN(auto mlir_declaration_operation, GetStmtRegionOperation(op.getDeclaration()));
    auto declaration_op = llvm::dyn_cast<JsirDeclarationOpInterface>(mlir_declaration_operation);
    if (declaration_op == nullptr) {
      return absl::InvalidArgumentError(
          absl::StrCat("Expected JsirDeclarationOpInterface, got ",
                       mlir_declaration_operation->getName().getStringRef().str(), "."));
    }
    MALDOCA_ASSIGN_OR_RETURN(declaration, VisitDeclaration(declaration_op));
  }
  std::vector<std::unique_ptr<JsExportSpecifier>> specifiers;
  for (mlir::Attribute mlir_specifiers_element_unchecked : op.getSpecifiersAttr().getValue()) {
    auto specifiers_element_attr = llvm::dyn_cast<JsirExportSpecifierAttr>(mlir_specifiers_element_unchecked);
    if (specifiers_element_attr == nullptr) {
      return absl::InvalidArgumentError("Invalid attribute.");
    }
    MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsExportSpecifier> specifiers_element, VisitExportSpecifierAttr(specifiers_element_attr));
    specifiers.push_back(std::move(specifiers_element));
  }
  std::optional<std::unique_ptr<JsStringLiteral>> source;
  if (op.getSourceAttr() != nullptr) {
    MALDOCA_ASSIGN_OR_RETURN(source, VisitStringLiteralAttr(op.getSourceAttr()));
  }
  std::optional<std::vector<std::unique_ptr<JsImportAttribute>>> assertions;
  if (op.getAssertionsAttr() != nullptr) {
    std::vector<std::unique_ptr<JsImportAttribute>> assertions_value;
    for (mlir::Attribute mlir_assertions_element_unchecked : op.getAssertionsAttr().getValue()) {
      auto assertions_element_attr = llvm::dyn_cast<JsirImportAttributeAttr>(mlir_assertions_element_unchecked);
      if (assertions_element_attr == nullptr) {
        return absl::InvalidArgumentError("Invalid attribute.");
      }
      MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsImportAttribute> assertions_element, VisitImportAttributeAttr(assertions_element_attr));
      assertions_value.push_back(std::move(assertions_element));
    }
    assertions = std::move(assertions_value);
  }
  return Create<JsExportNamedDeclaration>(
      op,
      std::move(declaration),
      std::move(specifiers),
      std::move(source),
      std::move(assertions));
}

absl::StatusOr<std::unique_ptr<JsExportAllDeclaration>>
JsirToAst::VisitExportAllDeclaration(JsirExportAllDeclarationOp op) {
  MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsStringLiteral> source, VisitStringLiteralAttr(op.getSourceAttr()));
  std::optional<std::vector<std::unique_ptr<JsImportAttribute>>> assertions;
  if (op.getAssertionsAttr() != nullptr) {
    std::vector<std::unique_ptr<JsImportAttribute>> assertions_value;
    for (mlir::Attribute mlir_assertions_element_unchecked : op.getAssertionsAttr().getValue()) {
      auto assertions_element_attr = llvm::dyn_cast<JsirImportAttributeAttr>(mlir_assertions_element_unchecked);
      if (assertions_element_attr == nullptr) {
        return absl::InvalidArgumentError("Invalid attribute.");
      }
      MALDOCA_ASSIGN_OR_RETURN(std::unique_ptr<JsImportAttribute> assertions_element, VisitImportAttributeAttr(assertions_element_attr));
      assertions_value.push_back(std::move(assertions_element));
    }
    assertions = std::move(assertions_value);
  }
  return Create<JsExportAllDeclaration>(
      op,
      std::move(source),
      std::move(assertions));
}

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca
