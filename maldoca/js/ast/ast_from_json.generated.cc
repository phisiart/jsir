// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

// NOLINTBEGIN(whitespace/line_length)
// clang-format off
// IWYU pragma: begin_keep

#include <cstdint>
#include <memory>
#include <optional>
#include <string>
#include <utility>
#include <variant>
#include <vector>

#include "absl/container/flat_hash_set.h"
#include "absl/memory/memory.h"
#include "absl/status/status.h"
#include "absl/status/statusor.h"
#include "absl/strings/str_cat.h"
#include "absl/strings/string_view.h"
#include "nlohmann/json.hpp"
#include "maldoca/base/status_macros.h"
#include "maldoca/js/ast/ast.generated.h"

namespace maldoca {

static absl::StatusOr<std::string> GetType(const nlohmann::json& json) {
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return absl::InvalidArgumentError("`type` is undefined.");
  }
  const nlohmann::json& json_type = type_it.value();
  if (json_type.is_null()) {
    return absl::InvalidArgumentError("json_type is null.");
  }
  if (!json_type.is_string()) {
    return absl::InvalidArgumentError("`json_type` expected to be string.");
  }
  return json_type.get<std::string>();
}

// =============================================================================
// JsPosition
// =============================================================================

absl::StatusOr<int64_t>
JsPosition::GetLine(const nlohmann::json& json) {
  auto line_it = json.find("line");
  if (line_it == json.end()) {
    return absl::InvalidArgumentError("`line` is undefined.");
  }
  const nlohmann::json& json_line = line_it.value();

  if (json_line.is_null()) {
    return absl::InvalidArgumentError("json_line is null.");
  }
  if (!json_line.is_number_integer()) {
    return absl::InvalidArgumentError("Expecting json_line.is_number_integer().");
  }
  return json_line.get<int64_t>();
}

absl::StatusOr<int64_t>
JsPosition::GetColumn(const nlohmann::json& json) {
  auto column_it = json.find("column");
  if (column_it == json.end()) {
    return absl::InvalidArgumentError("`column` is undefined.");
  }
  const nlohmann::json& json_column = column_it.value();

  if (json_column.is_null()) {
    return absl::InvalidArgumentError("json_column is null.");
  }
  if (!json_column.is_number_integer()) {
    return absl::InvalidArgumentError("Expecting json_column.is_number_integer().");
  }
  return json_column.get<int64_t>();
}

absl::StatusOr<std::unique_ptr<JsPosition>>
JsPosition::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto line, JsPosition::GetLine(json));
  MALDOCA_ASSIGN_OR_RETURN(auto column, JsPosition::GetColumn(json));

  return absl::make_unique<JsPosition>(
      std::move(line),
      std::move(column));
}

// =============================================================================
// JsSourceLocation
// =============================================================================

absl::StatusOr<std::unique_ptr<JsPosition>>
JsSourceLocation::GetStart(const nlohmann::json& json) {
  auto start_it = json.find("start");
  if (start_it == json.end()) {
    return absl::InvalidArgumentError("`start` is undefined.");
  }
  const nlohmann::json& json_start = start_it.value();

  if (json_start.is_null()) {
    return absl::InvalidArgumentError("json_start is null.");
  }
  return JsPosition::FromJson(json_start);
}

absl::StatusOr<std::unique_ptr<JsPosition>>
JsSourceLocation::GetEnd(const nlohmann::json& json) {
  auto end_it = json.find("end");
  if (end_it == json.end()) {
    return absl::InvalidArgumentError("`end` is undefined.");
  }
  const nlohmann::json& json_end = end_it.value();

  if (json_end.is_null()) {
    return absl::InvalidArgumentError("json_end is null.");
  }
  return JsPosition::FromJson(json_end);
}

absl::StatusOr<std::optional<std::string>>
JsSourceLocation::GetIdentifierName(const nlohmann::json& json) {
  auto identifier_name_it = json.find("identifierName");
  if (identifier_name_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_identifier_name = identifier_name_it.value();

  if (json_identifier_name.is_null()) {
    return absl::InvalidArgumentError("json_identifier_name is null.");
  }
  if (!json_identifier_name.is_string()) {
    return absl::InvalidArgumentError("Expecting json_identifier_name.is_string().");
  }
  return json_identifier_name.get<std::string>();
}

absl::StatusOr<std::unique_ptr<JsSourceLocation>>
JsSourceLocation::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto start, JsSourceLocation::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsSourceLocation::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto identifier_name, JsSourceLocation::GetIdentifierName(json));

  return absl::make_unique<JsSourceLocation>(
      std::move(start),
      std::move(end),
      std::move(identifier_name));
}

// =============================================================================
// JsComment
// =============================================================================

absl::StatusOr<std::unique_ptr<JsSourceLocation>>
JsComment::GetLoc(const nlohmann::json& json) {
  auto loc_it = json.find("loc");
  if (loc_it == json.end()) {
    return absl::InvalidArgumentError("`loc` is undefined.");
  }
  const nlohmann::json& json_loc = loc_it.value();

  if (json_loc.is_null()) {
    return absl::InvalidArgumentError("json_loc is null.");
  }
  return JsSourceLocation::FromJson(json_loc);
}

absl::StatusOr<std::string>
JsComment::GetValue(const nlohmann::json& json) {
  auto value_it = json.find("value");
  if (value_it == json.end()) {
    return absl::InvalidArgumentError("`value` is undefined.");
  }
  const nlohmann::json& json_value = value_it.value();

  if (json_value.is_null()) {
    return absl::InvalidArgumentError("json_value is null.");
  }
  if (!json_value.is_string()) {
    return absl::InvalidArgumentError("Expecting json_value.is_string().");
  }
  return json_value.get<std::string>();
}

absl::StatusOr<int64_t>
JsComment::GetStart(const nlohmann::json& json) {
  auto start_it = json.find("start");
  if (start_it == json.end()) {
    return absl::InvalidArgumentError("`start` is undefined.");
  }
  const nlohmann::json& json_start = start_it.value();

  if (json_start.is_null()) {
    return absl::InvalidArgumentError("json_start is null.");
  }
  if (!json_start.is_number_integer()) {
    return absl::InvalidArgumentError("Expecting json_start.is_number_integer().");
  }
  return json_start.get<int64_t>();
}

absl::StatusOr<int64_t>
JsComment::GetEnd(const nlohmann::json& json) {
  auto end_it = json.find("end");
  if (end_it == json.end()) {
    return absl::InvalidArgumentError("`end` is undefined.");
  }
  const nlohmann::json& json_end = end_it.value();

  if (json_end.is_null()) {
    return absl::InvalidArgumentError("json_end is null.");
  }
  if (!json_end.is_number_integer()) {
    return absl::InvalidArgumentError("Expecting json_end.is_number_integer().");
  }
  return json_end.get<int64_t>();
}

absl::StatusOr<std::unique_ptr<JsComment>>
JsComment::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(std::string type, GetType(json));

  if (type == "CommentBlock") {
    return JsCommentBlock::FromJson(json);
  } else if (type == "CommentLine") {
    return JsCommentLine::FromJson(json);
  }
  return absl::InvalidArgumentError(absl::StrCat("Invalid type: ", type));
}

// =============================================================================
// JsCommentBlock
// =============================================================================

absl::StatusOr<std::unique_ptr<JsCommentBlock>>
JsCommentBlock::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsComment::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto value, JsComment::GetValue(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsComment::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsComment::GetEnd(json));

  return absl::make_unique<JsCommentBlock>(
      std::move(loc),
      std::move(value),
      std::move(start),
      std::move(end));
}

// =============================================================================
// JsCommentLine
// =============================================================================

absl::StatusOr<std::unique_ptr<JsCommentLine>>
JsCommentLine::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsComment::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto value, JsComment::GetValue(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsComment::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsComment::GetEnd(json));

  return absl::make_unique<JsCommentLine>(
      std::move(loc),
      std::move(value),
      std::move(start),
      std::move(end));
}

// =============================================================================
// JsSymbolId
// =============================================================================

absl::StatusOr<std::string>
JsSymbolId::GetName(const nlohmann::json& json) {
  auto name_it = json.find("name");
  if (name_it == json.end()) {
    return absl::InvalidArgumentError("`name` is undefined.");
  }
  const nlohmann::json& json_name = name_it.value();

  if (json_name.is_null()) {
    return absl::InvalidArgumentError("json_name is null.");
  }
  if (!json_name.is_string()) {
    return absl::InvalidArgumentError("Expecting json_name.is_string().");
  }
  return json_name.get<std::string>();
}

absl::StatusOr<std::optional<int64_t>>
JsSymbolId::GetDefScopeUid(const nlohmann::json& json) {
  auto def_scope_uid_it = json.find("defScopeUid");
  if (def_scope_uid_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_def_scope_uid = def_scope_uid_it.value();

  if (json_def_scope_uid.is_null()) {
    return absl::InvalidArgumentError("json_def_scope_uid is null.");
  }
  if (!json_def_scope_uid.is_number_integer()) {
    return absl::InvalidArgumentError("Expecting json_def_scope_uid.is_number_integer().");
  }
  return json_def_scope_uid.get<int64_t>();
}

absl::StatusOr<std::unique_ptr<JsSymbolId>>
JsSymbolId::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto name, JsSymbolId::GetName(json));
  MALDOCA_ASSIGN_OR_RETURN(auto def_scope_uid, JsSymbolId::GetDefScopeUid(json));

  return absl::make_unique<JsSymbolId>(
      std::move(name),
      std::move(def_scope_uid));
}

// =============================================================================
// JsNode
// =============================================================================

absl::StatusOr<std::optional<std::unique_ptr<JsSourceLocation>>>
JsNode::GetLoc(const nlohmann::json& json) {
  auto loc_it = json.find("loc");
  if (loc_it == json.end()) {
    return absl::InvalidArgumentError("`loc` is undefined.");
  }
  const nlohmann::json& json_loc = loc_it.value();

  if (json_loc.is_null()) {
    return std::nullopt;
  }
  return JsSourceLocation::FromJson(json_loc);
}

absl::StatusOr<std::optional<int64_t>>
JsNode::GetStart(const nlohmann::json& json) {
  auto start_it = json.find("start");
  if (start_it == json.end()) {
    return absl::InvalidArgumentError("`start` is undefined.");
  }
  const nlohmann::json& json_start = start_it.value();

  if (json_start.is_null()) {
    return std::nullopt;
  }
  if (!json_start.is_number_integer()) {
    return absl::InvalidArgumentError("Expecting json_start.is_number_integer().");
  }
  return json_start.get<int64_t>();
}

absl::StatusOr<std::optional<int64_t>>
JsNode::GetEnd(const nlohmann::json& json) {
  auto end_it = json.find("end");
  if (end_it == json.end()) {
    return absl::InvalidArgumentError("`end` is undefined.");
  }
  const nlohmann::json& json_end = end_it.value();

  if (json_end.is_null()) {
    return std::nullopt;
  }
  if (!json_end.is_number_integer()) {
    return absl::InvalidArgumentError("Expecting json_end.is_number_integer().");
  }
  return json_end.get<int64_t>();
}

absl::StatusOr<std::optional<std::vector<std::unique_ptr<JsComment>>>>
JsNode::GetLeadingComments(const nlohmann::json& json) {
  auto leading_comments_it = json.find("leadingComments");
  if (leading_comments_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_leading_comments = leading_comments_it.value();

  if (json_leading_comments.is_null()) {
    return absl::InvalidArgumentError("json_leading_comments is null.");
  }
  if (!json_leading_comments.is_array()) {
    return absl::InvalidArgumentError("json_leading_comments expected to be array.");
  }

  std::vector<std::unique_ptr<JsComment>> leading_comments;
  for (const nlohmann::json& json_leading_comments_element : json_leading_comments) {
    if (json_leading_comments_element.is_null()) {
      return absl::InvalidArgumentError("json_leading_comments_element is null.");
    }
    MALDOCA_ASSIGN_OR_RETURN(auto leading_comments_element, JsComment::FromJson(json_leading_comments_element));
    leading_comments.push_back(std::move(leading_comments_element));
  }
  return leading_comments;
}

absl::StatusOr<std::optional<std::vector<std::unique_ptr<JsComment>>>>
JsNode::GetTrailingComments(const nlohmann::json& json) {
  auto trailing_comments_it = json.find("trailingComments");
  if (trailing_comments_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_trailing_comments = trailing_comments_it.value();

  if (json_trailing_comments.is_null()) {
    return absl::InvalidArgumentError("json_trailing_comments is null.");
  }
  if (!json_trailing_comments.is_array()) {
    return absl::InvalidArgumentError("json_trailing_comments expected to be array.");
  }

  std::vector<std::unique_ptr<JsComment>> trailing_comments;
  for (const nlohmann::json& json_trailing_comments_element : json_trailing_comments) {
    if (json_trailing_comments_element.is_null()) {
      return absl::InvalidArgumentError("json_trailing_comments_element is null.");
    }
    MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments_element, JsComment::FromJson(json_trailing_comments_element));
    trailing_comments.push_back(std::move(trailing_comments_element));
  }
  return trailing_comments;
}

absl::StatusOr<std::optional<std::vector<std::unique_ptr<JsComment>>>>
JsNode::GetInnerComments(const nlohmann::json& json) {
  auto inner_comments_it = json.find("innerComments");
  if (inner_comments_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_inner_comments = inner_comments_it.value();

  if (json_inner_comments.is_null()) {
    return absl::InvalidArgumentError("json_inner_comments is null.");
  }
  if (!json_inner_comments.is_array()) {
    return absl::InvalidArgumentError("json_inner_comments expected to be array.");
  }

  std::vector<std::unique_ptr<JsComment>> inner_comments;
  for (const nlohmann::json& json_inner_comments_element : json_inner_comments) {
    if (json_inner_comments_element.is_null()) {
      return absl::InvalidArgumentError("json_inner_comments_element is null.");
    }
    MALDOCA_ASSIGN_OR_RETURN(auto inner_comments_element, JsComment::FromJson(json_inner_comments_element));
    inner_comments.push_back(std::move(inner_comments_element));
  }
  return inner_comments;
}

absl::StatusOr<std::optional<int64_t>>
JsNode::GetScopeUid(const nlohmann::json& json) {
  auto scope_uid_it = json.find("scopeUid");
  if (scope_uid_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_scope_uid = scope_uid_it.value();

  if (json_scope_uid.is_null()) {
    return absl::InvalidArgumentError("json_scope_uid is null.");
  }
  if (!json_scope_uid.is_number_integer()) {
    return absl::InvalidArgumentError("Expecting json_scope_uid.is_number_integer().");
  }
  return json_scope_uid.get<int64_t>();
}

absl::StatusOr<std::optional<std::unique_ptr<JsSymbolId>>>
JsNode::GetReferencedSymbol(const nlohmann::json& json) {
  auto referenced_symbol_it = json.find("referencedSymbol");
  if (referenced_symbol_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_referenced_symbol = referenced_symbol_it.value();

  if (json_referenced_symbol.is_null()) {
    return absl::InvalidArgumentError("json_referenced_symbol is null.");
  }
  return JsSymbolId::FromJson(json_referenced_symbol);
}

absl::StatusOr<std::optional<std::vector<std::unique_ptr<JsSymbolId>>>>
JsNode::GetDefinedSymbols(const nlohmann::json& json) {
  auto defined_symbols_it = json.find("definedSymbols");
  if (defined_symbols_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_defined_symbols = defined_symbols_it.value();

  if (json_defined_symbols.is_null()) {
    return absl::InvalidArgumentError("json_defined_symbols is null.");
  }
  if (!json_defined_symbols.is_array()) {
    return absl::InvalidArgumentError("json_defined_symbols expected to be array.");
  }

  std::vector<std::unique_ptr<JsSymbolId>> defined_symbols;
  for (const nlohmann::json& json_defined_symbols_element : json_defined_symbols) {
    if (json_defined_symbols_element.is_null()) {
      return absl::InvalidArgumentError("json_defined_symbols_element is null.");
    }
    MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols_element, JsSymbolId::FromJson(json_defined_symbols_element));
    defined_symbols.push_back(std::move(defined_symbols_element));
  }
  return defined_symbols;
}

absl::StatusOr<std::unique_ptr<JsNode>>
JsNode::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(std::string type, GetType(json));

  if (type == "File") {
    return JsFile::FromJson(json);
  } else if (type == "PrivateName") {
    return JsPrivateName::FromJson(json);
  } else if (type == "Program") {
    return JsProgram::FromJson(json);
  } else if (type == "FunctionDeclaration") {
    return JsFunctionDeclaration::FromJson(json);
  } else if (type == "ObjectMethod") {
    return JsObjectMethod::FromJson(json);
  } else if (type == "FunctionExpression") {
    return JsFunctionExpression::FromJson(json);
  } else if (type == "ClassMethod") {
    return JsClassMethod::FromJson(json);
  } else if (type == "ClassPrivateMethod") {
    return JsClassPrivateMethod::FromJson(json);
  } else if (type == "BlockStatementFunction") {
    return JsBlockStatementFunction::FromJson(json);
  } else if (type == "ArrowFunctionExpression") {
    return JsArrowFunctionExpression::FromJson(json);
  } else if (type == "Function") {
    return JsFunction::FromJson(json);
  } else if (type == "ExpressionStatement") {
    return JsExpressionStatement::FromJson(json);
  } else if (type == "BlockStatement") {
    return JsBlockStatement::FromJson(json);
  } else if (type == "EmptyStatement") {
    return JsEmptyStatement::FromJson(json);
  } else if (type == "DebuggerStatement") {
    return JsDebuggerStatement::FromJson(json);
  } else if (type == "WithStatement") {
    return JsWithStatement::FromJson(json);
  } else if (type == "ReturnStatement") {
    return JsReturnStatement::FromJson(json);
  } else if (type == "LabeledStatement") {
    return JsLabeledStatement::FromJson(json);
  } else if (type == "BreakStatement") {
    return JsBreakStatement::FromJson(json);
  } else if (type == "ContinueStatement") {
    return JsContinueStatement::FromJson(json);
  } else if (type == "IfStatement") {
    return JsIfStatement::FromJson(json);
  } else if (type == "SwitchStatement") {
    return JsSwitchStatement::FromJson(json);
  } else if (type == "ThrowStatement") {
    return JsThrowStatement::FromJson(json);
  } else if (type == "TryStatement") {
    return JsTryStatement::FromJson(json);
  } else if (type == "WhileStatement") {
    return JsWhileStatement::FromJson(json);
  } else if (type == "DoWhileStatement") {
    return JsDoWhileStatement::FromJson(json);
  } else if (type == "ForStatement") {
    return JsForStatement::FromJson(json);
  } else if (type == "ForInStatement") {
    return JsForInStatement::FromJson(json);
  } else if (type == "ForOfStatement") {
    return JsForOfStatement::FromJson(json);
  } else if (type == "VariableDeclaration") {
    return JsVariableDeclaration::FromJson(json);
  } else if (type == "ClassDeclaration") {
    return JsClassDeclaration::FromJson(json);
  } else if (type == "Declaration") {
    return JsDeclaration::FromJson(json);
  } else if (type == "Statement") {
    return JsStatement::FromJson(json);
  } else if (type == "SwitchCase") {
    return JsSwitchCase::FromJson(json);
  } else if (type == "CatchClause") {
    return JsCatchClause::FromJson(json);
  } else if (type == "VariableDeclarator") {
    return JsVariableDeclarator::FromJson(json);
  } else if (type == "Directive") {
    return JsDirective::FromJson(json);
  } else if (type == "DirectiveLiteral") {
    return JsDirectiveLiteral::FromJson(json);
  } else if (type == "InterpreterDirective") {
    return JsInterpreterDirective::FromJson(json);
  } else if (type == "Identifier") {
    return JsIdentifier::FromJson(json);
  } else if (type == "RegExpLiteral") {
    return JsRegExpLiteral::FromJson(json);
  } else if (type == "NullLiteral") {
    return JsNullLiteral::FromJson(json);
  } else if (type == "StringLiteral") {
    return JsStringLiteral::FromJson(json);
  } else if (type == "BooleanLiteral") {
    return JsBooleanLiteral::FromJson(json);
  } else if (type == "NumericLiteral") {
    return JsNumericLiteral::FromJson(json);
  } else if (type == "BigIntLiteral") {
    return JsBigIntLiteral::FromJson(json);
  } else if (type == "Literal") {
    return JsLiteral::FromJson(json);
  } else if (type == "ThisExpression") {
    return JsThisExpression::FromJson(json);
  } else if (type == "YieldExpression") {
    return JsYieldExpression::FromJson(json);
  } else if (type == "AwaitExpression") {
    return JsAwaitExpression::FromJson(json);
  } else if (type == "ArrayExpression") {
    return JsArrayExpression::FromJson(json);
  } else if (type == "ObjectExpression") {
    return JsObjectExpression::FromJson(json);
  } else if (type == "UnaryExpression") {
    return JsUnaryExpression::FromJson(json);
  } else if (type == "UpdateExpression") {
    return JsUpdateExpression::FromJson(json);
  } else if (type == "BinaryExpression") {
    return JsBinaryExpression::FromJson(json);
  } else if (type == "AssignmentExpression") {
    return JsAssignmentExpression::FromJson(json);
  } else if (type == "LogicalExpression") {
    return JsLogicalExpression::FromJson(json);
  } else if (type == "MemberExpression") {
    return JsMemberExpression::FromJson(json);
  } else if (type == "OptionalMemberExpression") {
    return JsOptionalMemberExpression::FromJson(json);
  } else if (type == "ConditionalExpression") {
    return JsConditionalExpression::FromJson(json);
  } else if (type == "CallExpression") {
    return JsCallExpression::FromJson(json);
  } else if (type == "OptionalCallExpression") {
    return JsOptionalCallExpression::FromJson(json);
  } else if (type == "NewExpression") {
    return JsNewExpression::FromJson(json);
  } else if (type == "SequenceExpression") {
    return JsSequenceExpression::FromJson(json);
  } else if (type == "ParenthesizedExpression") {
    return JsParenthesizedExpression::FromJson(json);
  } else if (type == "TemplateLiteral") {
    return JsTemplateLiteral::FromJson(json);
  } else if (type == "TaggedTemplateExpression") {
    return JsTaggedTemplateExpression::FromJson(json);
  } else if (type == "ClassExpression") {
    return JsClassExpression::FromJson(json);
  } else if (type == "MetaProperty") {
    return JsMetaProperty::FromJson(json);
  } else if (type == "Expression") {
    return JsExpression::FromJson(json);
  } else if (type == "ObjectPattern") {
    return JsObjectPattern::FromJson(json);
  } else if (type == "ArrayPattern") {
    return JsArrayPattern::FromJson(json);
  } else if (type == "RestElement") {
    return JsRestElement::FromJson(json);
  } else if (type == "AssignmentPattern") {
    return JsAssignmentPattern::FromJson(json);
  } else if (type == "LVal") {
    return JsLVal::FromJson(json);
  } else if (type == "Super") {
    return JsSuper::FromJson(json);
  } else if (type == "Import") {
    return JsImport::FromJson(json);
  } else if (type == "ObjectProperty") {
    return JsObjectProperty::FromJson(json);
  } else if (type == "ObjectMember") {
    return JsObjectMember::FromJson(json);
  } else if (type == "SpreadElement") {
    return JsSpreadElement::FromJson(json);
  } else if (type == "TemplateElement") {
    return JsTemplateElement::FromJson(json);
  } else if (type == "Pattern") {
    return JsPattern::FromJson(json);
  } else if (type == "Class") {
    return JsClass::FromJson(json);
  } else if (type == "ClassBody") {
    return JsClassBody::FromJson(json);
  } else if (type == "ClassProperty") {
    return JsClassProperty::FromJson(json);
  } else if (type == "ClassPrivateProperty") {
    return JsClassPrivateProperty::FromJson(json);
  } else if (type == "ImportDeclaration") {
    return JsImportDeclaration::FromJson(json);
  } else if (type == "ExportNamedDeclaration") {
    return JsExportNamedDeclaration::FromJson(json);
  } else if (type == "ExportDefaultDeclaration") {
    return JsExportDefaultDeclaration::FromJson(json);
  } else if (type == "ExportAllDeclaration") {
    return JsExportAllDeclaration::FromJson(json);
  } else if (type == "ModuleDeclaration") {
    return JsModuleDeclaration::FromJson(json);
  } else if (type == "ImportSpecifier") {
    return JsImportSpecifier::FromJson(json);
  } else if (type == "ImportDefaultSpecifier") {
    return JsImportDefaultSpecifier::FromJson(json);
  } else if (type == "ImportNamespaceSpecifier") {
    return JsImportNamespaceSpecifier::FromJson(json);
  } else if (type == "ExportSpecifier") {
    return JsExportSpecifier::FromJson(json);
  } else if (type == "ModuleSpecifier") {
    return JsModuleSpecifier::FromJson(json);
  } else if (type == "ImportAttribute") {
    return JsImportAttribute::FromJson(json);
  }
  return absl::InvalidArgumentError(absl::StrCat("Invalid type: ", type));
}

// =============================================================================
// JsInterpreterDirective
// =============================================================================

absl::StatusOr<std::string>
JsInterpreterDirective::GetValue(const nlohmann::json& json) {
  auto value_it = json.find("value");
  if (value_it == json.end()) {
    return absl::InvalidArgumentError("`value` is undefined.");
  }
  const nlohmann::json& json_value = value_it.value();

  if (json_value.is_null()) {
    return absl::InvalidArgumentError("json_value is null.");
  }
  if (!json_value.is_string()) {
    return absl::InvalidArgumentError("Expecting json_value.is_string().");
  }
  return json_value.get<std::string>();
}

absl::StatusOr<std::unique_ptr<JsInterpreterDirective>>
JsInterpreterDirective::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto value, JsInterpreterDirective::GetValue(json));

  return absl::make_unique<JsInterpreterDirective>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(value));
}

// =============================================================================
// JsStatement
// =============================================================================

static bool IsStatement(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  static const auto *kTypes = new absl::flat_hash_set<std::string>{
      "ExpressionStatement",
      "BlockStatement",
      "EmptyStatement",
      "DebuggerStatement",
      "WithStatement",
      "ReturnStatement",
      "LabeledStatement",
      "BreakStatement",
      "ContinueStatement",
      "IfStatement",
      "SwitchStatement",
      "ThrowStatement",
      "TryStatement",
      "WhileStatement",
      "DoWhileStatement",
      "ForStatement",
      "ForInStatement",
      "ForOfStatement",
      "FunctionDeclaration",
      "VariableDeclaration",
      "ClassDeclaration",
  };

  return kTypes->contains(type);
}

absl::StatusOr<std::unique_ptr<JsStatement>>
JsStatement::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(std::string type, GetType(json));

  if (type == "ExpressionStatement") {
    return JsExpressionStatement::FromJson(json);
  } else if (type == "BlockStatement") {
    return JsBlockStatement::FromJson(json);
  } else if (type == "EmptyStatement") {
    return JsEmptyStatement::FromJson(json);
  } else if (type == "DebuggerStatement") {
    return JsDebuggerStatement::FromJson(json);
  } else if (type == "WithStatement") {
    return JsWithStatement::FromJson(json);
  } else if (type == "ReturnStatement") {
    return JsReturnStatement::FromJson(json);
  } else if (type == "LabeledStatement") {
    return JsLabeledStatement::FromJson(json);
  } else if (type == "BreakStatement") {
    return JsBreakStatement::FromJson(json);
  } else if (type == "ContinueStatement") {
    return JsContinueStatement::FromJson(json);
  } else if (type == "IfStatement") {
    return JsIfStatement::FromJson(json);
  } else if (type == "SwitchStatement") {
    return JsSwitchStatement::FromJson(json);
  } else if (type == "ThrowStatement") {
    return JsThrowStatement::FromJson(json);
  } else if (type == "TryStatement") {
    return JsTryStatement::FromJson(json);
  } else if (type == "WhileStatement") {
    return JsWhileStatement::FromJson(json);
  } else if (type == "DoWhileStatement") {
    return JsDoWhileStatement::FromJson(json);
  } else if (type == "ForStatement") {
    return JsForStatement::FromJson(json);
  } else if (type == "ForInStatement") {
    return JsForInStatement::FromJson(json);
  } else if (type == "ForOfStatement") {
    return JsForOfStatement::FromJson(json);
  } else if (type == "FunctionDeclaration") {
    return JsFunctionDeclaration::FromJson(json);
  } else if (type == "VariableDeclaration") {
    return JsVariableDeclaration::FromJson(json);
  } else if (type == "ClassDeclaration") {
    return JsClassDeclaration::FromJson(json);
  } else if (type == "Declaration") {
    return JsDeclaration::FromJson(json);
  }
  return absl::InvalidArgumentError(absl::StrCat("Invalid type: ", type));
}

// =============================================================================
// JsModuleDeclaration
// =============================================================================

static bool IsModuleDeclaration(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  static const auto *kTypes = new absl::flat_hash_set<std::string>{
      "ImportDeclaration",
      "ExportNamedDeclaration",
      "ExportDefaultDeclaration",
      "ExportAllDeclaration",
  };

  return kTypes->contains(type);
}

absl::StatusOr<std::unique_ptr<JsModuleDeclaration>>
JsModuleDeclaration::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(std::string type, GetType(json));

  if (type == "ImportDeclaration") {
    return JsImportDeclaration::FromJson(json);
  } else if (type == "ExportNamedDeclaration") {
    return JsExportNamedDeclaration::FromJson(json);
  } else if (type == "ExportDefaultDeclaration") {
    return JsExportDefaultDeclaration::FromJson(json);
  } else if (type == "ExportAllDeclaration") {
    return JsExportAllDeclaration::FromJson(json);
  }
  return absl::InvalidArgumentError(absl::StrCat("Invalid type: ", type));
}

// =============================================================================
// JsDirectiveLiteralExtra
// =============================================================================

absl::StatusOr<std::string>
JsDirectiveLiteralExtra::GetRaw(const nlohmann::json& json) {
  auto raw_it = json.find("raw");
  if (raw_it == json.end()) {
    return absl::InvalidArgumentError("`raw` is undefined.");
  }
  const nlohmann::json& json_raw = raw_it.value();

  if (json_raw.is_null()) {
    return absl::InvalidArgumentError("json_raw is null.");
  }
  if (!json_raw.is_string()) {
    return absl::InvalidArgumentError("Expecting json_raw.is_string().");
  }
  return json_raw.get<std::string>();
}

absl::StatusOr<std::string>
JsDirectiveLiteralExtra::GetRawValue(const nlohmann::json& json) {
  auto raw_value_it = json.find("rawValue");
  if (raw_value_it == json.end()) {
    return absl::InvalidArgumentError("`rawValue` is undefined.");
  }
  const nlohmann::json& json_raw_value = raw_value_it.value();

  if (json_raw_value.is_null()) {
    return absl::InvalidArgumentError("json_raw_value is null.");
  }
  if (!json_raw_value.is_string()) {
    return absl::InvalidArgumentError("Expecting json_raw_value.is_string().");
  }
  return json_raw_value.get<std::string>();
}

absl::StatusOr<std::unique_ptr<JsDirectiveLiteralExtra>>
JsDirectiveLiteralExtra::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto raw, JsDirectiveLiteralExtra::GetRaw(json));
  MALDOCA_ASSIGN_OR_RETURN(auto raw_value, JsDirectiveLiteralExtra::GetRawValue(json));

  return absl::make_unique<JsDirectiveLiteralExtra>(
      std::move(raw),
      std::move(raw_value));
}

// =============================================================================
// JsDirectiveLiteral
// =============================================================================

absl::StatusOr<std::string>
JsDirectiveLiteral::GetValue(const nlohmann::json& json) {
  auto value_it = json.find("value");
  if (value_it == json.end()) {
    return absl::InvalidArgumentError("`value` is undefined.");
  }
  const nlohmann::json& json_value = value_it.value();

  if (json_value.is_null()) {
    return absl::InvalidArgumentError("json_value is null.");
  }
  if (!json_value.is_string()) {
    return absl::InvalidArgumentError("Expecting json_value.is_string().");
  }
  return json_value.get<std::string>();
}

absl::StatusOr<std::optional<std::unique_ptr<JsDirectiveLiteralExtra>>>
JsDirectiveLiteral::GetExtra(const nlohmann::json& json) {
  auto extra_it = json.find("extra");
  if (extra_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_extra = extra_it.value();

  if (json_extra.is_null()) {
    return absl::InvalidArgumentError("json_extra is null.");
  }
  return JsDirectiveLiteralExtra::FromJson(json_extra);
}

absl::StatusOr<std::unique_ptr<JsDirectiveLiteral>>
JsDirectiveLiteral::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto value, JsDirectiveLiteral::GetValue(json));
  MALDOCA_ASSIGN_OR_RETURN(auto extra, JsDirectiveLiteral::GetExtra(json));

  return absl::make_unique<JsDirectiveLiteral>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(value),
      std::move(extra));
}

// =============================================================================
// JsDirective
// =============================================================================

absl::StatusOr<std::unique_ptr<JsDirectiveLiteral>>
JsDirective::GetValue(const nlohmann::json& json) {
  auto value_it = json.find("value");
  if (value_it == json.end()) {
    return absl::InvalidArgumentError("`value` is undefined.");
  }
  const nlohmann::json& json_value = value_it.value();

  if (json_value.is_null()) {
    return absl::InvalidArgumentError("json_value is null.");
  }
  return JsDirectiveLiteral::FromJson(json_value);
}

absl::StatusOr<std::unique_ptr<JsDirective>>
JsDirective::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto value, JsDirective::GetValue(json));

  return absl::make_unique<JsDirective>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(value));
}

// =============================================================================
// JsProgram
// =============================================================================

absl::StatusOr<std::optional<std::unique_ptr<JsInterpreterDirective>>>
JsProgram::GetInterpreter(const nlohmann::json& json) {
  auto interpreter_it = json.find("interpreter");
  if (interpreter_it == json.end()) {
    return absl::InvalidArgumentError("`interpreter` is undefined.");
  }
  const nlohmann::json& json_interpreter = interpreter_it.value();

  if (json_interpreter.is_null()) {
    return std::nullopt;
  }
  return JsInterpreterDirective::FromJson(json_interpreter);
}

absl::StatusOr<std::string>
JsProgram::GetSourceType(const nlohmann::json& json) {
  auto source_type_it = json.find("sourceType");
  if (source_type_it == json.end()) {
    return absl::InvalidArgumentError("`sourceType` is undefined.");
  }
  const nlohmann::json& json_source_type = source_type_it.value();

  if (json_source_type.is_null()) {
    return absl::InvalidArgumentError("json_source_type is null.");
  }
  if (!json_source_type.is_string()) {
    return absl::InvalidArgumentError("Expecting json_source_type.is_string().");
  }
  return json_source_type.get<std::string>();
}

absl::StatusOr<std::vector<std::variant<std::unique_ptr<JsStatement>, std::unique_ptr<JsModuleDeclaration>>>>
JsProgram::GetBody(const nlohmann::json& json) {
  auto body_it = json.find("body");
  if (body_it == json.end()) {
    return absl::InvalidArgumentError("`body` is undefined.");
  }
  const nlohmann::json& json_body = body_it.value();

  if (json_body.is_null()) {
    return absl::InvalidArgumentError("json_body is null.");
  }
  if (!json_body.is_array()) {
    return absl::InvalidArgumentError("json_body expected to be array.");
  }

  std::vector<std::variant<std::unique_ptr<JsStatement>, std::unique_ptr<JsModuleDeclaration>>> body;
  for (const nlohmann::json& json_body_element : json_body) {
    if (json_body_element.is_null()) {
      return absl::InvalidArgumentError("json_body_element is null.");
    }
    std::variant<std::unique_ptr<JsStatement>, std::unique_ptr<JsModuleDeclaration>> body_element;
    if (IsStatement(json_body_element)) {
      MALDOCA_ASSIGN_OR_RETURN(body_element, JsStatement::FromJson(json_body_element));
    } else if (IsModuleDeclaration(json_body_element)) {
      MALDOCA_ASSIGN_OR_RETURN(body_element, JsModuleDeclaration::FromJson(json_body_element));
    } else {
      auto result = absl::InvalidArgumentError("json_body_element has invalid type.");
      result.SetPayload("json", absl::Cord{json.dump()});
      result.SetPayload("json_element", absl::Cord{json_body_element.dump()});
      return result;
    }
    body.push_back(std::move(body_element));
  }
  return body;
}

absl::StatusOr<std::vector<std::unique_ptr<JsDirective>>>
JsProgram::GetDirectives(const nlohmann::json& json) {
  auto directives_it = json.find("directives");
  if (directives_it == json.end()) {
    return absl::InvalidArgumentError("`directives` is undefined.");
  }
  const nlohmann::json& json_directives = directives_it.value();

  if (json_directives.is_null()) {
    return absl::InvalidArgumentError("json_directives is null.");
  }
  if (!json_directives.is_array()) {
    return absl::InvalidArgumentError("json_directives expected to be array.");
  }

  std::vector<std::unique_ptr<JsDirective>> directives;
  for (const nlohmann::json& json_directives_element : json_directives) {
    if (json_directives_element.is_null()) {
      return absl::InvalidArgumentError("json_directives_element is null.");
    }
    MALDOCA_ASSIGN_OR_RETURN(auto directives_element, JsDirective::FromJson(json_directives_element));
    directives.push_back(std::move(directives_element));
  }
  return directives;
}

absl::StatusOr<std::unique_ptr<JsProgram>>
JsProgram::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto interpreter, JsProgram::GetInterpreter(json));
  MALDOCA_ASSIGN_OR_RETURN(auto source_type, JsProgram::GetSourceType(json));
  MALDOCA_ASSIGN_OR_RETURN(auto body, JsProgram::GetBody(json));
  MALDOCA_ASSIGN_OR_RETURN(auto directives, JsProgram::GetDirectives(json));

  return absl::make_unique<JsProgram>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(interpreter),
      std::move(source_type),
      std::move(body),
      std::move(directives));
}

// =============================================================================
// JsFile
// =============================================================================

absl::StatusOr<std::unique_ptr<JsProgram>>
JsFile::GetProgram(const nlohmann::json& json) {
  auto program_it = json.find("program");
  if (program_it == json.end()) {
    return absl::InvalidArgumentError("`program` is undefined.");
  }
  const nlohmann::json& json_program = program_it.value();

  if (json_program.is_null()) {
    return absl::InvalidArgumentError("json_program is null.");
  }
  return JsProgram::FromJson(json_program);
}

absl::StatusOr<std::unique_ptr<JsFile>>
JsFile::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto program, JsFile::GetProgram(json));

  return absl::make_unique<JsFile>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(program));
}

// =============================================================================
// JsExpression
// =============================================================================

static bool IsExpression(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  static const auto *kTypes = new absl::flat_hash_set<std::string>{
      "Identifier",
      "RegExpLiteral",
      "NullLiteral",
      "StringLiteral",
      "BooleanLiteral",
      "NumericLiteral",
      "BigIntLiteral",
      "ThisExpression",
      "ArrowFunctionExpression",
      "YieldExpression",
      "AwaitExpression",
      "ArrayExpression",
      "ObjectExpression",
      "FunctionExpression",
      "UnaryExpression",
      "UpdateExpression",
      "BinaryExpression",
      "AssignmentExpression",
      "LogicalExpression",
      "MemberExpression",
      "OptionalMemberExpression",
      "ConditionalExpression",
      "CallExpression",
      "OptionalCallExpression",
      "NewExpression",
      "SequenceExpression",
      "ParenthesizedExpression",
      "TemplateLiteral",
      "TaggedTemplateExpression",
      "ClassExpression",
      "MetaProperty",
  };

  return kTypes->contains(type);
}

absl::StatusOr<std::unique_ptr<JsExpression>>
JsExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(std::string type, GetType(json));

  if (type == "Identifier") {
    return JsIdentifier::FromJson(json);
  } else if (type == "RegExpLiteral") {
    return JsRegExpLiteral::FromJson(json);
  } else if (type == "NullLiteral") {
    return JsNullLiteral::FromJson(json);
  } else if (type == "StringLiteral") {
    return JsStringLiteral::FromJson(json);
  } else if (type == "BooleanLiteral") {
    return JsBooleanLiteral::FromJson(json);
  } else if (type == "NumericLiteral") {
    return JsNumericLiteral::FromJson(json);
  } else if (type == "BigIntLiteral") {
    return JsBigIntLiteral::FromJson(json);
  } else if (type == "Literal") {
    return JsLiteral::FromJson(json);
  } else if (type == "ThisExpression") {
    return JsThisExpression::FromJson(json);
  } else if (type == "ArrowFunctionExpression") {
    return JsArrowFunctionExpression::FromJson(json);
  } else if (type == "YieldExpression") {
    return JsYieldExpression::FromJson(json);
  } else if (type == "AwaitExpression") {
    return JsAwaitExpression::FromJson(json);
  } else if (type == "ArrayExpression") {
    return JsArrayExpression::FromJson(json);
  } else if (type == "ObjectExpression") {
    return JsObjectExpression::FromJson(json);
  } else if (type == "FunctionExpression") {
    return JsFunctionExpression::FromJson(json);
  } else if (type == "UnaryExpression") {
    return JsUnaryExpression::FromJson(json);
  } else if (type == "UpdateExpression") {
    return JsUpdateExpression::FromJson(json);
  } else if (type == "BinaryExpression") {
    return JsBinaryExpression::FromJson(json);
  } else if (type == "AssignmentExpression") {
    return JsAssignmentExpression::FromJson(json);
  } else if (type == "LogicalExpression") {
    return JsLogicalExpression::FromJson(json);
  } else if (type == "MemberExpression") {
    return JsMemberExpression::FromJson(json);
  } else if (type == "OptionalMemberExpression") {
    return JsOptionalMemberExpression::FromJson(json);
  } else if (type == "ConditionalExpression") {
    return JsConditionalExpression::FromJson(json);
  } else if (type == "CallExpression") {
    return JsCallExpression::FromJson(json);
  } else if (type == "OptionalCallExpression") {
    return JsOptionalCallExpression::FromJson(json);
  } else if (type == "NewExpression") {
    return JsNewExpression::FromJson(json);
  } else if (type == "SequenceExpression") {
    return JsSequenceExpression::FromJson(json);
  } else if (type == "ParenthesizedExpression") {
    return JsParenthesizedExpression::FromJson(json);
  } else if (type == "TemplateLiteral") {
    return JsTemplateLiteral::FromJson(json);
  } else if (type == "TaggedTemplateExpression") {
    return JsTaggedTemplateExpression::FromJson(json);
  } else if (type == "ClassExpression") {
    return JsClassExpression::FromJson(json);
  } else if (type == "MetaProperty") {
    return JsMetaProperty::FromJson(json);
  }
  return absl::InvalidArgumentError(absl::StrCat("Invalid type: ", type));
}

// =============================================================================
// JsPattern
// =============================================================================

static bool IsPattern(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  static const auto *kTypes = new absl::flat_hash_set<std::string>{
      "Identifier",
      "MemberExpression",
      "ParenthesizedExpression",
      "ObjectPattern",
      "ArrayPattern",
      "RestElement",
      "AssignmentPattern",
  };

  return kTypes->contains(type);
}

absl::StatusOr<std::unique_ptr<JsPattern>>
JsPattern::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(std::string type, GetType(json));

  if (type == "Identifier") {
    return JsIdentifier::FromJson(json);
  } else if (type == "MemberExpression") {
    return JsMemberExpression::FromJson(json);
  } else if (type == "ParenthesizedExpression") {
    return JsParenthesizedExpression::FromJson(json);
  } else if (type == "ObjectPattern") {
    return JsObjectPattern::FromJson(json);
  } else if (type == "ArrayPattern") {
    return JsArrayPattern::FromJson(json);
  } else if (type == "RestElement") {
    return JsRestElement::FromJson(json);
  } else if (type == "AssignmentPattern") {
    return JsAssignmentPattern::FromJson(json);
  }
  return absl::InvalidArgumentError(absl::StrCat("Invalid type: ", type));
}

// =============================================================================
// JsLVal
// =============================================================================

static bool IsLVal(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  static const auto *kTypes = new absl::flat_hash_set<std::string>{
      "Identifier",
      "MemberExpression",
      "ParenthesizedExpression",
      "ObjectPattern",
      "ArrayPattern",
      "RestElement",
      "AssignmentPattern",
  };

  return kTypes->contains(type);
}

absl::StatusOr<std::unique_ptr<JsLVal>>
JsLVal::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(std::string type, GetType(json));

  if (type == "Identifier") {
    return JsIdentifier::FromJson(json);
  } else if (type == "MemberExpression") {
    return JsMemberExpression::FromJson(json);
  } else if (type == "ParenthesizedExpression") {
    return JsParenthesizedExpression::FromJson(json);
  } else if (type == "ObjectPattern") {
    return JsObjectPattern::FromJson(json);
  } else if (type == "ArrayPattern") {
    return JsArrayPattern::FromJson(json);
  } else if (type == "RestElement") {
    return JsRestElement::FromJson(json);
  } else if (type == "AssignmentPattern") {
    return JsAssignmentPattern::FromJson(json);
  }
  return absl::InvalidArgumentError(absl::StrCat("Invalid type: ", type));
}

// =============================================================================
// JsIdentifier
// =============================================================================

static bool IsIdentifier(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  return type == "Identifier";
}

absl::StatusOr<std::string>
JsIdentifier::GetName(const nlohmann::json& json) {
  auto name_it = json.find("name");
  if (name_it == json.end()) {
    return absl::InvalidArgumentError("`name` is undefined.");
  }
  const nlohmann::json& json_name = name_it.value();

  if (json_name.is_null()) {
    return absl::InvalidArgumentError("json_name is null.");
  }
  if (!json_name.is_string()) {
    return absl::InvalidArgumentError("Expecting json_name.is_string().");
  }
  return json_name.get<std::string>();
}

absl::StatusOr<std::unique_ptr<JsIdentifier>>
JsIdentifier::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto name, JsIdentifier::GetName(json));

  return absl::make_unique<JsIdentifier>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(name));
}

// =============================================================================
// JsPrivateName
// =============================================================================

static bool IsPrivateName(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  return type == "PrivateName";
}

absl::StatusOr<std::unique_ptr<JsIdentifier>>
JsPrivateName::GetId(const nlohmann::json& json) {
  auto id_it = json.find("id");
  if (id_it == json.end()) {
    return absl::InvalidArgumentError("`id` is undefined.");
  }
  const nlohmann::json& json_id = id_it.value();

  if (json_id.is_null()) {
    return absl::InvalidArgumentError("json_id is null.");
  }
  return JsIdentifier::FromJson(json_id);
}

absl::StatusOr<std::unique_ptr<JsPrivateName>>
JsPrivateName::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto id, JsPrivateName::GetId(json));

  return absl::make_unique<JsPrivateName>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(id));
}

// =============================================================================
// JsLiteral
// =============================================================================

absl::StatusOr<std::unique_ptr<JsLiteral>>
JsLiteral::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(std::string type, GetType(json));

  if (type == "RegExpLiteral") {
    return JsRegExpLiteral::FromJson(json);
  } else if (type == "NullLiteral") {
    return JsNullLiteral::FromJson(json);
  } else if (type == "StringLiteral") {
    return JsStringLiteral::FromJson(json);
  } else if (type == "BooleanLiteral") {
    return JsBooleanLiteral::FromJson(json);
  } else if (type == "NumericLiteral") {
    return JsNumericLiteral::FromJson(json);
  } else if (type == "BigIntLiteral") {
    return JsBigIntLiteral::FromJson(json);
  }
  return absl::InvalidArgumentError(absl::StrCat("Invalid type: ", type));
}

// =============================================================================
// JsRegExpLiteralExtra
// =============================================================================

absl::StatusOr<std::string>
JsRegExpLiteralExtra::GetRaw(const nlohmann::json& json) {
  auto raw_it = json.find("raw");
  if (raw_it == json.end()) {
    return absl::InvalidArgumentError("`raw` is undefined.");
  }
  const nlohmann::json& json_raw = raw_it.value();

  if (json_raw.is_null()) {
    return absl::InvalidArgumentError("json_raw is null.");
  }
  if (!json_raw.is_string()) {
    return absl::InvalidArgumentError("Expecting json_raw.is_string().");
  }
  return json_raw.get<std::string>();
}

absl::StatusOr<std::unique_ptr<JsRegExpLiteralExtra>>
JsRegExpLiteralExtra::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto raw, JsRegExpLiteralExtra::GetRaw(json));

  return absl::make_unique<JsRegExpLiteralExtra>(
      std::move(raw));
}

// =============================================================================
// JsRegExpLiteral
// =============================================================================

absl::StatusOr<std::string>
JsRegExpLiteral::GetPattern(const nlohmann::json& json) {
  auto pattern_it = json.find("pattern");
  if (pattern_it == json.end()) {
    return absl::InvalidArgumentError("`pattern` is undefined.");
  }
  const nlohmann::json& json_pattern = pattern_it.value();

  if (json_pattern.is_null()) {
    return absl::InvalidArgumentError("json_pattern is null.");
  }
  if (!json_pattern.is_string()) {
    return absl::InvalidArgumentError("Expecting json_pattern.is_string().");
  }
  return json_pattern.get<std::string>();
}

absl::StatusOr<std::string>
JsRegExpLiteral::GetFlags(const nlohmann::json& json) {
  auto flags_it = json.find("flags");
  if (flags_it == json.end()) {
    return absl::InvalidArgumentError("`flags` is undefined.");
  }
  const nlohmann::json& json_flags = flags_it.value();

  if (json_flags.is_null()) {
    return absl::InvalidArgumentError("json_flags is null.");
  }
  if (!json_flags.is_string()) {
    return absl::InvalidArgumentError("Expecting json_flags.is_string().");
  }
  return json_flags.get<std::string>();
}

absl::StatusOr<std::optional<std::unique_ptr<JsRegExpLiteralExtra>>>
JsRegExpLiteral::GetExtra(const nlohmann::json& json) {
  auto extra_it = json.find("extra");
  if (extra_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_extra = extra_it.value();

  if (json_extra.is_null()) {
    return absl::InvalidArgumentError("json_extra is null.");
  }
  return JsRegExpLiteralExtra::FromJson(json_extra);
}

absl::StatusOr<std::unique_ptr<JsRegExpLiteral>>
JsRegExpLiteral::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto pattern, JsRegExpLiteral::GetPattern(json));
  MALDOCA_ASSIGN_OR_RETURN(auto flags, JsRegExpLiteral::GetFlags(json));
  MALDOCA_ASSIGN_OR_RETURN(auto extra, JsRegExpLiteral::GetExtra(json));

  return absl::make_unique<JsRegExpLiteral>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(pattern),
      std::move(flags),
      std::move(extra));
}

// =============================================================================
// JsNullLiteral
// =============================================================================

absl::StatusOr<std::unique_ptr<JsNullLiteral>>
JsNullLiteral::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));

  return absl::make_unique<JsNullLiteral>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols));
}

// =============================================================================
// JsStringLiteralExtra
// =============================================================================

absl::StatusOr<std::string>
JsStringLiteralExtra::GetRaw(const nlohmann::json& json) {
  auto raw_it = json.find("raw");
  if (raw_it == json.end()) {
    return absl::InvalidArgumentError("`raw` is undefined.");
  }
  const nlohmann::json& json_raw = raw_it.value();

  if (json_raw.is_null()) {
    return absl::InvalidArgumentError("json_raw is null.");
  }
  if (!json_raw.is_string()) {
    return absl::InvalidArgumentError("Expecting json_raw.is_string().");
  }
  return json_raw.get<std::string>();
}

absl::StatusOr<std::string>
JsStringLiteralExtra::GetRawValue(const nlohmann::json& json) {
  auto raw_value_it = json.find("rawValue");
  if (raw_value_it == json.end()) {
    return absl::InvalidArgumentError("`rawValue` is undefined.");
  }
  const nlohmann::json& json_raw_value = raw_value_it.value();

  if (json_raw_value.is_null()) {
    return absl::InvalidArgumentError("json_raw_value is null.");
  }
  if (!json_raw_value.is_string()) {
    return absl::InvalidArgumentError("Expecting json_raw_value.is_string().");
  }
  return json_raw_value.get<std::string>();
}

absl::StatusOr<std::unique_ptr<JsStringLiteralExtra>>
JsStringLiteralExtra::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto raw, JsStringLiteralExtra::GetRaw(json));
  MALDOCA_ASSIGN_OR_RETURN(auto raw_value, JsStringLiteralExtra::GetRawValue(json));

  return absl::make_unique<JsStringLiteralExtra>(
      std::move(raw),
      std::move(raw_value));
}

// =============================================================================
// JsStringLiteral
// =============================================================================

static bool IsStringLiteral(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  return type == "StringLiteral";
}

absl::StatusOr<std::string>
JsStringLiteral::GetValue(const nlohmann::json& json) {
  auto value_it = json.find("value");
  if (value_it == json.end()) {
    return absl::InvalidArgumentError("`value` is undefined.");
  }
  const nlohmann::json& json_value = value_it.value();

  if (json_value.is_null()) {
    return absl::InvalidArgumentError("json_value is null.");
  }
  if (!json_value.is_string()) {
    return absl::InvalidArgumentError("Expecting json_value.is_string().");
  }
  return json_value.get<std::string>();
}

absl::StatusOr<std::optional<std::unique_ptr<JsStringLiteralExtra>>>
JsStringLiteral::GetExtra(const nlohmann::json& json) {
  auto extra_it = json.find("extra");
  if (extra_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_extra = extra_it.value();

  if (json_extra.is_null()) {
    return absl::InvalidArgumentError("json_extra is null.");
  }
  return JsStringLiteralExtra::FromJson(json_extra);
}

absl::StatusOr<std::unique_ptr<JsStringLiteral>>
JsStringLiteral::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto value, JsStringLiteral::GetValue(json));
  MALDOCA_ASSIGN_OR_RETURN(auto extra, JsStringLiteral::GetExtra(json));

  return absl::make_unique<JsStringLiteral>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(value),
      std::move(extra));
}

// =============================================================================
// JsBooleanLiteral
// =============================================================================

absl::StatusOr<bool>
JsBooleanLiteral::GetValue(const nlohmann::json& json) {
  auto value_it = json.find("value");
  if (value_it == json.end()) {
    return absl::InvalidArgumentError("`value` is undefined.");
  }
  const nlohmann::json& json_value = value_it.value();

  if (json_value.is_null()) {
    return absl::InvalidArgumentError("json_value is null.");
  }
  if (!json_value.is_boolean()) {
    return absl::InvalidArgumentError("Expecting json_value.is_boolean().");
  }
  return json_value.get<bool>();
}

absl::StatusOr<std::unique_ptr<JsBooleanLiteral>>
JsBooleanLiteral::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto value, JsBooleanLiteral::GetValue(json));

  return absl::make_unique<JsBooleanLiteral>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(value));
}

// =============================================================================
// JsNumericLiteralExtra
// =============================================================================

absl::StatusOr<std::string>
JsNumericLiteralExtra::GetRaw(const nlohmann::json& json) {
  auto raw_it = json.find("raw");
  if (raw_it == json.end()) {
    return absl::InvalidArgumentError("`raw` is undefined.");
  }
  const nlohmann::json& json_raw = raw_it.value();

  if (json_raw.is_null()) {
    return absl::InvalidArgumentError("json_raw is null.");
  }
  if (!json_raw.is_string()) {
    return absl::InvalidArgumentError("Expecting json_raw.is_string().");
  }
  return json_raw.get<std::string>();
}

absl::StatusOr<double>
JsNumericLiteralExtra::GetRawValue(const nlohmann::json& json) {
  auto raw_value_it = json.find("rawValue");
  if (raw_value_it == json.end()) {
    return absl::InvalidArgumentError("`rawValue` is undefined.");
  }
  const nlohmann::json& json_raw_value = raw_value_it.value();

  if (json_raw_value.is_null()) {
    return absl::InvalidArgumentError("json_raw_value is null.");
  }
  if (!json_raw_value.is_number()) {
    return absl::InvalidArgumentError("Expecting json_raw_value.is_number().");
  }
  return json_raw_value.get<double>();
}

absl::StatusOr<std::unique_ptr<JsNumericLiteralExtra>>
JsNumericLiteralExtra::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto raw, JsNumericLiteralExtra::GetRaw(json));
  MALDOCA_ASSIGN_OR_RETURN(auto raw_value, JsNumericLiteralExtra::GetRawValue(json));

  return absl::make_unique<JsNumericLiteralExtra>(
      std::move(raw),
      std::move(raw_value));
}

// =============================================================================
// JsNumericLiteral
// =============================================================================

absl::StatusOr<double>
JsNumericLiteral::GetValue(const nlohmann::json& json) {
  auto value_it = json.find("value");
  if (value_it == json.end()) {
    return absl::InvalidArgumentError("`value` is undefined.");
  }
  const nlohmann::json& json_value = value_it.value();

  if (json_value.is_null()) {
    return absl::InvalidArgumentError("json_value is null.");
  }
  if (!json_value.is_number()) {
    return absl::InvalidArgumentError("Expecting json_value.is_number().");
  }
  return json_value.get<double>();
}

absl::StatusOr<std::optional<std::unique_ptr<JsNumericLiteralExtra>>>
JsNumericLiteral::GetExtra(const nlohmann::json& json) {
  auto extra_it = json.find("extra");
  if (extra_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_extra = extra_it.value();

  if (json_extra.is_null()) {
    return absl::InvalidArgumentError("json_extra is null.");
  }
  return JsNumericLiteralExtra::FromJson(json_extra);
}

absl::StatusOr<std::unique_ptr<JsNumericLiteral>>
JsNumericLiteral::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto value, JsNumericLiteral::GetValue(json));
  MALDOCA_ASSIGN_OR_RETURN(auto extra, JsNumericLiteral::GetExtra(json));

  return absl::make_unique<JsNumericLiteral>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(value),
      std::move(extra));
}

// =============================================================================
// JsBigIntLiteralExtra
// =============================================================================

absl::StatusOr<std::string>
JsBigIntLiteralExtra::GetRaw(const nlohmann::json& json) {
  auto raw_it = json.find("raw");
  if (raw_it == json.end()) {
    return absl::InvalidArgumentError("`raw` is undefined.");
  }
  const nlohmann::json& json_raw = raw_it.value();

  if (json_raw.is_null()) {
    return absl::InvalidArgumentError("json_raw is null.");
  }
  if (!json_raw.is_string()) {
    return absl::InvalidArgumentError("Expecting json_raw.is_string().");
  }
  return json_raw.get<std::string>();
}

absl::StatusOr<std::string>
JsBigIntLiteralExtra::GetRawValue(const nlohmann::json& json) {
  auto raw_value_it = json.find("rawValue");
  if (raw_value_it == json.end()) {
    return absl::InvalidArgumentError("`rawValue` is undefined.");
  }
  const nlohmann::json& json_raw_value = raw_value_it.value();

  if (json_raw_value.is_null()) {
    return absl::InvalidArgumentError("json_raw_value is null.");
  }
  if (!json_raw_value.is_string()) {
    return absl::InvalidArgumentError("Expecting json_raw_value.is_string().");
  }
  return json_raw_value.get<std::string>();
}

absl::StatusOr<std::unique_ptr<JsBigIntLiteralExtra>>
JsBigIntLiteralExtra::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto raw, JsBigIntLiteralExtra::GetRaw(json));
  MALDOCA_ASSIGN_OR_RETURN(auto raw_value, JsBigIntLiteralExtra::GetRawValue(json));

  return absl::make_unique<JsBigIntLiteralExtra>(
      std::move(raw),
      std::move(raw_value));
}

// =============================================================================
// JsBigIntLiteral
// =============================================================================

absl::StatusOr<std::string>
JsBigIntLiteral::GetValue(const nlohmann::json& json) {
  auto value_it = json.find("value");
  if (value_it == json.end()) {
    return absl::InvalidArgumentError("`value` is undefined.");
  }
  const nlohmann::json& json_value = value_it.value();

  if (json_value.is_null()) {
    return absl::InvalidArgumentError("json_value is null.");
  }
  if (!json_value.is_string()) {
    return absl::InvalidArgumentError("Expecting json_value.is_string().");
  }
  return json_value.get<std::string>();
}

absl::StatusOr<std::optional<std::unique_ptr<JsBigIntLiteralExtra>>>
JsBigIntLiteral::GetExtra(const nlohmann::json& json) {
  auto extra_it = json.find("extra");
  if (extra_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_extra = extra_it.value();

  if (json_extra.is_null()) {
    return absl::InvalidArgumentError("json_extra is null.");
  }
  return JsBigIntLiteralExtra::FromJson(json_extra);
}

absl::StatusOr<std::unique_ptr<JsBigIntLiteral>>
JsBigIntLiteral::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto value, JsBigIntLiteral::GetValue(json));
  MALDOCA_ASSIGN_OR_RETURN(auto extra, JsBigIntLiteral::GetExtra(json));

  return absl::make_unique<JsBigIntLiteral>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(value),
      std::move(extra));
}

// =============================================================================
// JsFunction
// =============================================================================

absl::StatusOr<std::optional<std::unique_ptr<JsIdentifier>>>
JsFunction::GetId(const nlohmann::json& json) {
  auto id_it = json.find("id");
  if (id_it == json.end()) {
    return absl::InvalidArgumentError("`id` is undefined.");
  }
  const nlohmann::json& json_id = id_it.value();

  if (json_id.is_null()) {
    return std::nullopt;
  }
  return JsIdentifier::FromJson(json_id);
}

absl::StatusOr<std::vector<std::unique_ptr<JsPattern>>>
JsFunction::GetParams(const nlohmann::json& json) {
  auto params_it = json.find("params");
  if (params_it == json.end()) {
    return absl::InvalidArgumentError("`params` is undefined.");
  }
  const nlohmann::json& json_params = params_it.value();

  if (json_params.is_null()) {
    return absl::InvalidArgumentError("json_params is null.");
  }
  if (!json_params.is_array()) {
    return absl::InvalidArgumentError("json_params expected to be array.");
  }

  std::vector<std::unique_ptr<JsPattern>> params;
  for (const nlohmann::json& json_params_element : json_params) {
    if (json_params_element.is_null()) {
      return absl::InvalidArgumentError("json_params_element is null.");
    }
    MALDOCA_ASSIGN_OR_RETURN(auto params_element, JsPattern::FromJson(json_params_element));
    params.push_back(std::move(params_element));
  }
  return params;
}

absl::StatusOr<bool>
JsFunction::GetGenerator(const nlohmann::json& json) {
  auto generator_it = json.find("generator");
  if (generator_it == json.end()) {
    return absl::InvalidArgumentError("`generator` is undefined.");
  }
  const nlohmann::json& json_generator = generator_it.value();

  if (json_generator.is_null()) {
    return absl::InvalidArgumentError("json_generator is null.");
  }
  if (!json_generator.is_boolean()) {
    return absl::InvalidArgumentError("Expecting json_generator.is_boolean().");
  }
  return json_generator.get<bool>();
}

absl::StatusOr<bool>
JsFunction::GetAsync(const nlohmann::json& json) {
  auto async_it = json.find("async");
  if (async_it == json.end()) {
    return absl::InvalidArgumentError("`async` is undefined.");
  }
  const nlohmann::json& json_async = async_it.value();

  if (json_async.is_null()) {
    return absl::InvalidArgumentError("json_async is null.");
  }
  if (!json_async.is_boolean()) {
    return absl::InvalidArgumentError("Expecting json_async.is_boolean().");
  }
  return json_async.get<bool>();
}

absl::StatusOr<std::unique_ptr<JsFunction>>
JsFunction::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(std::string type, GetType(json));

  if (type == "FunctionDeclaration") {
    return JsFunctionDeclaration::FromJson(json);
  } else if (type == "ObjectMethod") {
    return JsObjectMethod::FromJson(json);
  } else if (type == "FunctionExpression") {
    return JsFunctionExpression::FromJson(json);
  } else if (type == "ClassMethod") {
    return JsClassMethod::FromJson(json);
  } else if (type == "ClassPrivateMethod") {
    return JsClassPrivateMethod::FromJson(json);
  } else if (type == "BlockStatementFunction") {
    return JsBlockStatementFunction::FromJson(json);
  } else if (type == "ArrowFunctionExpression") {
    return JsArrowFunctionExpression::FromJson(json);
  }
  return absl::InvalidArgumentError(absl::StrCat("Invalid type: ", type));
}

// =============================================================================
// JsBlockStatement
// =============================================================================

static bool IsBlockStatement(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  return type == "BlockStatement";
}

absl::StatusOr<std::vector<std::unique_ptr<JsStatement>>>
JsBlockStatement::GetBody(const nlohmann::json& json) {
  auto body_it = json.find("body");
  if (body_it == json.end()) {
    return absl::InvalidArgumentError("`body` is undefined.");
  }
  const nlohmann::json& json_body = body_it.value();

  if (json_body.is_null()) {
    return absl::InvalidArgumentError("json_body is null.");
  }
  if (!json_body.is_array()) {
    return absl::InvalidArgumentError("json_body expected to be array.");
  }

  std::vector<std::unique_ptr<JsStatement>> body;
  for (const nlohmann::json& json_body_element : json_body) {
    if (json_body_element.is_null()) {
      return absl::InvalidArgumentError("json_body_element is null.");
    }
    MALDOCA_ASSIGN_OR_RETURN(auto body_element, JsStatement::FromJson(json_body_element));
    body.push_back(std::move(body_element));
  }
  return body;
}

absl::StatusOr<std::vector<std::unique_ptr<JsDirective>>>
JsBlockStatement::GetDirectives(const nlohmann::json& json) {
  auto directives_it = json.find("directives");
  if (directives_it == json.end()) {
    return absl::InvalidArgumentError("`directives` is undefined.");
  }
  const nlohmann::json& json_directives = directives_it.value();

  if (json_directives.is_null()) {
    return absl::InvalidArgumentError("json_directives is null.");
  }
  if (!json_directives.is_array()) {
    return absl::InvalidArgumentError("json_directives expected to be array.");
  }

  std::vector<std::unique_ptr<JsDirective>> directives;
  for (const nlohmann::json& json_directives_element : json_directives) {
    if (json_directives_element.is_null()) {
      return absl::InvalidArgumentError("json_directives_element is null.");
    }
    MALDOCA_ASSIGN_OR_RETURN(auto directives_element, JsDirective::FromJson(json_directives_element));
    directives.push_back(std::move(directives_element));
  }
  return directives;
}

absl::StatusOr<std::unique_ptr<JsBlockStatement>>
JsBlockStatement::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto body, JsBlockStatement::GetBody(json));
  MALDOCA_ASSIGN_OR_RETURN(auto directives, JsBlockStatement::GetDirectives(json));

  return absl::make_unique<JsBlockStatement>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(body),
      std::move(directives));
}

// =============================================================================
// JsBlockStatementFunction
// =============================================================================

absl::StatusOr<std::unique_ptr<JsBlockStatement>>
JsBlockStatementFunction::GetBody(const nlohmann::json& json) {
  auto body_it = json.find("body");
  if (body_it == json.end()) {
    return absl::InvalidArgumentError("`body` is undefined.");
  }
  const nlohmann::json& json_body = body_it.value();

  if (json_body.is_null()) {
    return absl::InvalidArgumentError("json_body is null.");
  }
  return JsBlockStatement::FromJson(json_body);
}

absl::StatusOr<std::unique_ptr<JsBlockStatementFunction>>
JsBlockStatementFunction::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(std::string type, GetType(json));

  if (type == "FunctionDeclaration") {
    return JsFunctionDeclaration::FromJson(json);
  } else if (type == "ObjectMethod") {
    return JsObjectMethod::FromJson(json);
  } else if (type == "FunctionExpression") {
    return JsFunctionExpression::FromJson(json);
  } else if (type == "ClassMethod") {
    return JsClassMethod::FromJson(json);
  } else if (type == "ClassPrivateMethod") {
    return JsClassPrivateMethod::FromJson(json);
  }
  return absl::InvalidArgumentError(absl::StrCat("Invalid type: ", type));
}

// =============================================================================
// JsExpressionStatement
// =============================================================================

absl::StatusOr<std::unique_ptr<JsExpression>>
JsExpressionStatement::GetExpression(const nlohmann::json& json) {
  auto expression_it = json.find("expression");
  if (expression_it == json.end()) {
    return absl::InvalidArgumentError("`expression` is undefined.");
  }
  const nlohmann::json& json_expression = expression_it.value();

  if (json_expression.is_null()) {
    return absl::InvalidArgumentError("json_expression is null.");
  }
  return JsExpression::FromJson(json_expression);
}

absl::StatusOr<std::unique_ptr<JsExpressionStatement>>
JsExpressionStatement::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto expression, JsExpressionStatement::GetExpression(json));

  return absl::make_unique<JsExpressionStatement>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(expression));
}

// =============================================================================
// JsEmptyStatement
// =============================================================================

absl::StatusOr<std::unique_ptr<JsEmptyStatement>>
JsEmptyStatement::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));

  return absl::make_unique<JsEmptyStatement>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols));
}

// =============================================================================
// JsDebuggerStatement
// =============================================================================

absl::StatusOr<std::unique_ptr<JsDebuggerStatement>>
JsDebuggerStatement::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));

  return absl::make_unique<JsDebuggerStatement>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols));
}

// =============================================================================
// JsWithStatement
// =============================================================================

absl::StatusOr<std::unique_ptr<JsExpression>>
JsWithStatement::GetObject(const nlohmann::json& json) {
  auto object_it = json.find("object");
  if (object_it == json.end()) {
    return absl::InvalidArgumentError("`object` is undefined.");
  }
  const nlohmann::json& json_object = object_it.value();

  if (json_object.is_null()) {
    return absl::InvalidArgumentError("json_object is null.");
  }
  return JsExpression::FromJson(json_object);
}

absl::StatusOr<std::unique_ptr<JsStatement>>
JsWithStatement::GetBody(const nlohmann::json& json) {
  auto body_it = json.find("body");
  if (body_it == json.end()) {
    return absl::InvalidArgumentError("`body` is undefined.");
  }
  const nlohmann::json& json_body = body_it.value();

  if (json_body.is_null()) {
    return absl::InvalidArgumentError("json_body is null.");
  }
  return JsStatement::FromJson(json_body);
}

absl::StatusOr<std::unique_ptr<JsWithStatement>>
JsWithStatement::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto object, JsWithStatement::GetObject(json));
  MALDOCA_ASSIGN_OR_RETURN(auto body, JsWithStatement::GetBody(json));

  return absl::make_unique<JsWithStatement>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(object),
      std::move(body));
}

// =============================================================================
// JsReturnStatement
// =============================================================================

absl::StatusOr<std::optional<std::unique_ptr<JsExpression>>>
JsReturnStatement::GetArgument(const nlohmann::json& json) {
  auto argument_it = json.find("argument");
  if (argument_it == json.end()) {
    return absl::InvalidArgumentError("`argument` is undefined.");
  }
  const nlohmann::json& json_argument = argument_it.value();

  if (json_argument.is_null()) {
    return std::nullopt;
  }
  return JsExpression::FromJson(json_argument);
}

absl::StatusOr<std::unique_ptr<JsReturnStatement>>
JsReturnStatement::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto argument, JsReturnStatement::GetArgument(json));

  return absl::make_unique<JsReturnStatement>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(argument));
}

// =============================================================================
// JsLabeledStatement
// =============================================================================

absl::StatusOr<std::unique_ptr<JsIdentifier>>
JsLabeledStatement::GetLabel(const nlohmann::json& json) {
  auto label_it = json.find("label");
  if (label_it == json.end()) {
    return absl::InvalidArgumentError("`label` is undefined.");
  }
  const nlohmann::json& json_label = label_it.value();

  if (json_label.is_null()) {
    return absl::InvalidArgumentError("json_label is null.");
  }
  return JsIdentifier::FromJson(json_label);
}

absl::StatusOr<std::unique_ptr<JsStatement>>
JsLabeledStatement::GetBody(const nlohmann::json& json) {
  auto body_it = json.find("body");
  if (body_it == json.end()) {
    return absl::InvalidArgumentError("`body` is undefined.");
  }
  const nlohmann::json& json_body = body_it.value();

  if (json_body.is_null()) {
    return absl::InvalidArgumentError("json_body is null.");
  }
  return JsStatement::FromJson(json_body);
}

absl::StatusOr<std::unique_ptr<JsLabeledStatement>>
JsLabeledStatement::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto label, JsLabeledStatement::GetLabel(json));
  MALDOCA_ASSIGN_OR_RETURN(auto body, JsLabeledStatement::GetBody(json));

  return absl::make_unique<JsLabeledStatement>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(label),
      std::move(body));
}

// =============================================================================
// JsBreakStatement
// =============================================================================

absl::StatusOr<std::optional<std::unique_ptr<JsIdentifier>>>
JsBreakStatement::GetLabel(const nlohmann::json& json) {
  auto label_it = json.find("label");
  if (label_it == json.end()) {
    return absl::InvalidArgumentError("`label` is undefined.");
  }
  const nlohmann::json& json_label = label_it.value();

  if (json_label.is_null()) {
    return std::nullopt;
  }
  return JsIdentifier::FromJson(json_label);
}

absl::StatusOr<std::unique_ptr<JsBreakStatement>>
JsBreakStatement::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto label, JsBreakStatement::GetLabel(json));

  return absl::make_unique<JsBreakStatement>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(label));
}

// =============================================================================
// JsContinueStatement
// =============================================================================

absl::StatusOr<std::optional<std::unique_ptr<JsIdentifier>>>
JsContinueStatement::GetLabel(const nlohmann::json& json) {
  auto label_it = json.find("label");
  if (label_it == json.end()) {
    return absl::InvalidArgumentError("`label` is undefined.");
  }
  const nlohmann::json& json_label = label_it.value();

  if (json_label.is_null()) {
    return std::nullopt;
  }
  return JsIdentifier::FromJson(json_label);
}

absl::StatusOr<std::unique_ptr<JsContinueStatement>>
JsContinueStatement::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto label, JsContinueStatement::GetLabel(json));

  return absl::make_unique<JsContinueStatement>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(label));
}

// =============================================================================
// JsIfStatement
// =============================================================================

absl::StatusOr<std::unique_ptr<JsExpression>>
JsIfStatement::GetTest(const nlohmann::json& json) {
  auto test_it = json.find("test");
  if (test_it == json.end()) {
    return absl::InvalidArgumentError("`test` is undefined.");
  }
  const nlohmann::json& json_test = test_it.value();

  if (json_test.is_null()) {
    return absl::InvalidArgumentError("json_test is null.");
  }
  return JsExpression::FromJson(json_test);
}

absl::StatusOr<std::unique_ptr<JsStatement>>
JsIfStatement::GetConsequent(const nlohmann::json& json) {
  auto consequent_it = json.find("consequent");
  if (consequent_it == json.end()) {
    return absl::InvalidArgumentError("`consequent` is undefined.");
  }
  const nlohmann::json& json_consequent = consequent_it.value();

  if (json_consequent.is_null()) {
    return absl::InvalidArgumentError("json_consequent is null.");
  }
  return JsStatement::FromJson(json_consequent);
}

absl::StatusOr<std::optional<std::unique_ptr<JsStatement>>>
JsIfStatement::GetAlternate(const nlohmann::json& json) {
  auto alternate_it = json.find("alternate");
  if (alternate_it == json.end()) {
    return absl::InvalidArgumentError("`alternate` is undefined.");
  }
  const nlohmann::json& json_alternate = alternate_it.value();

  if (json_alternate.is_null()) {
    return std::nullopt;
  }
  return JsStatement::FromJson(json_alternate);
}

absl::StatusOr<std::unique_ptr<JsIfStatement>>
JsIfStatement::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto test, JsIfStatement::GetTest(json));
  MALDOCA_ASSIGN_OR_RETURN(auto consequent, JsIfStatement::GetConsequent(json));
  MALDOCA_ASSIGN_OR_RETURN(auto alternate, JsIfStatement::GetAlternate(json));

  return absl::make_unique<JsIfStatement>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(test),
      std::move(consequent),
      std::move(alternate));
}

// =============================================================================
// JsSwitchCase
// =============================================================================

absl::StatusOr<std::optional<std::unique_ptr<JsExpression>>>
JsSwitchCase::GetTest(const nlohmann::json& json) {
  auto test_it = json.find("test");
  if (test_it == json.end()) {
    return absl::InvalidArgumentError("`test` is undefined.");
  }
  const nlohmann::json& json_test = test_it.value();

  if (json_test.is_null()) {
    return std::nullopt;
  }
  return JsExpression::FromJson(json_test);
}

absl::StatusOr<std::vector<std::unique_ptr<JsStatement>>>
JsSwitchCase::GetConsequent(const nlohmann::json& json) {
  auto consequent_it = json.find("consequent");
  if (consequent_it == json.end()) {
    return absl::InvalidArgumentError("`consequent` is undefined.");
  }
  const nlohmann::json& json_consequent = consequent_it.value();

  if (json_consequent.is_null()) {
    return absl::InvalidArgumentError("json_consequent is null.");
  }
  if (!json_consequent.is_array()) {
    return absl::InvalidArgumentError("json_consequent expected to be array.");
  }

  std::vector<std::unique_ptr<JsStatement>> consequent;
  for (const nlohmann::json& json_consequent_element : json_consequent) {
    if (json_consequent_element.is_null()) {
      return absl::InvalidArgumentError("json_consequent_element is null.");
    }
    MALDOCA_ASSIGN_OR_RETURN(auto consequent_element, JsStatement::FromJson(json_consequent_element));
    consequent.push_back(std::move(consequent_element));
  }
  return consequent;
}

absl::StatusOr<std::unique_ptr<JsSwitchCase>>
JsSwitchCase::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto test, JsSwitchCase::GetTest(json));
  MALDOCA_ASSIGN_OR_RETURN(auto consequent, JsSwitchCase::GetConsequent(json));

  return absl::make_unique<JsSwitchCase>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(test),
      std::move(consequent));
}

// =============================================================================
// JsSwitchStatement
// =============================================================================

absl::StatusOr<std::unique_ptr<JsExpression>>
JsSwitchStatement::GetDiscriminant(const nlohmann::json& json) {
  auto discriminant_it = json.find("discriminant");
  if (discriminant_it == json.end()) {
    return absl::InvalidArgumentError("`discriminant` is undefined.");
  }
  const nlohmann::json& json_discriminant = discriminant_it.value();

  if (json_discriminant.is_null()) {
    return absl::InvalidArgumentError("json_discriminant is null.");
  }
  return JsExpression::FromJson(json_discriminant);
}

absl::StatusOr<std::vector<std::unique_ptr<JsSwitchCase>>>
JsSwitchStatement::GetCases(const nlohmann::json& json) {
  auto cases_it = json.find("cases");
  if (cases_it == json.end()) {
    return absl::InvalidArgumentError("`cases` is undefined.");
  }
  const nlohmann::json& json_cases = cases_it.value();

  if (json_cases.is_null()) {
    return absl::InvalidArgumentError("json_cases is null.");
  }
  if (!json_cases.is_array()) {
    return absl::InvalidArgumentError("json_cases expected to be array.");
  }

  std::vector<std::unique_ptr<JsSwitchCase>> cases;
  for (const nlohmann::json& json_cases_element : json_cases) {
    if (json_cases_element.is_null()) {
      return absl::InvalidArgumentError("json_cases_element is null.");
    }
    MALDOCA_ASSIGN_OR_RETURN(auto cases_element, JsSwitchCase::FromJson(json_cases_element));
    cases.push_back(std::move(cases_element));
  }
  return cases;
}

absl::StatusOr<std::unique_ptr<JsSwitchStatement>>
JsSwitchStatement::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto discriminant, JsSwitchStatement::GetDiscriminant(json));
  MALDOCA_ASSIGN_OR_RETURN(auto cases, JsSwitchStatement::GetCases(json));

  return absl::make_unique<JsSwitchStatement>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(discriminant),
      std::move(cases));
}

// =============================================================================
// JsThrowStatement
// =============================================================================

absl::StatusOr<std::unique_ptr<JsExpression>>
JsThrowStatement::GetArgument(const nlohmann::json& json) {
  auto argument_it = json.find("argument");
  if (argument_it == json.end()) {
    return absl::InvalidArgumentError("`argument` is undefined.");
  }
  const nlohmann::json& json_argument = argument_it.value();

  if (json_argument.is_null()) {
    return absl::InvalidArgumentError("json_argument is null.");
  }
  return JsExpression::FromJson(json_argument);
}

absl::StatusOr<std::unique_ptr<JsThrowStatement>>
JsThrowStatement::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto argument, JsThrowStatement::GetArgument(json));

  return absl::make_unique<JsThrowStatement>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(argument));
}

// =============================================================================
// JsCatchClause
// =============================================================================

absl::StatusOr<std::optional<std::unique_ptr<JsPattern>>>
JsCatchClause::GetParam(const nlohmann::json& json) {
  auto param_it = json.find("param");
  if (param_it == json.end()) {
    return absl::InvalidArgumentError("`param` is undefined.");
  }
  const nlohmann::json& json_param = param_it.value();

  if (json_param.is_null()) {
    return std::nullopt;
  }
  return JsPattern::FromJson(json_param);
}

absl::StatusOr<std::unique_ptr<JsBlockStatement>>
JsCatchClause::GetBody(const nlohmann::json& json) {
  auto body_it = json.find("body");
  if (body_it == json.end()) {
    return absl::InvalidArgumentError("`body` is undefined.");
  }
  const nlohmann::json& json_body = body_it.value();

  if (json_body.is_null()) {
    return absl::InvalidArgumentError("json_body is null.");
  }
  return JsBlockStatement::FromJson(json_body);
}

absl::StatusOr<std::unique_ptr<JsCatchClause>>
JsCatchClause::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto param, JsCatchClause::GetParam(json));
  MALDOCA_ASSIGN_OR_RETURN(auto body, JsCatchClause::GetBody(json));

  return absl::make_unique<JsCatchClause>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(param),
      std::move(body));
}

// =============================================================================
// JsTryStatement
// =============================================================================

absl::StatusOr<std::unique_ptr<JsBlockStatement>>
JsTryStatement::GetBlock(const nlohmann::json& json) {
  auto block_it = json.find("block");
  if (block_it == json.end()) {
    return absl::InvalidArgumentError("`block` is undefined.");
  }
  const nlohmann::json& json_block = block_it.value();

  if (json_block.is_null()) {
    return absl::InvalidArgumentError("json_block is null.");
  }
  return JsBlockStatement::FromJson(json_block);
}

absl::StatusOr<std::optional<std::unique_ptr<JsCatchClause>>>
JsTryStatement::GetHandler(const nlohmann::json& json) {
  auto handler_it = json.find("handler");
  if (handler_it == json.end()) {
    return absl::InvalidArgumentError("`handler` is undefined.");
  }
  const nlohmann::json& json_handler = handler_it.value();

  if (json_handler.is_null()) {
    return std::nullopt;
  }
  return JsCatchClause::FromJson(json_handler);
}

absl::StatusOr<std::optional<std::unique_ptr<JsBlockStatement>>>
JsTryStatement::GetFinalizer(const nlohmann::json& json) {
  auto finalizer_it = json.find("finalizer");
  if (finalizer_it == json.end()) {
    return absl::InvalidArgumentError("`finalizer` is undefined.");
  }
  const nlohmann::json& json_finalizer = finalizer_it.value();

  if (json_finalizer.is_null()) {
    return std::nullopt;
  }
  return JsBlockStatement::FromJson(json_finalizer);
}

absl::StatusOr<std::unique_ptr<JsTryStatement>>
JsTryStatement::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto block, JsTryStatement::GetBlock(json));
  MALDOCA_ASSIGN_OR_RETURN(auto handler, JsTryStatement::GetHandler(json));
  MALDOCA_ASSIGN_OR_RETURN(auto finalizer, JsTryStatement::GetFinalizer(json));

  return absl::make_unique<JsTryStatement>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(block),
      std::move(handler),
      std::move(finalizer));
}

// =============================================================================
// JsWhileStatement
// =============================================================================

absl::StatusOr<std::unique_ptr<JsExpression>>
JsWhileStatement::GetTest(const nlohmann::json& json) {
  auto test_it = json.find("test");
  if (test_it == json.end()) {
    return absl::InvalidArgumentError("`test` is undefined.");
  }
  const nlohmann::json& json_test = test_it.value();

  if (json_test.is_null()) {
    return absl::InvalidArgumentError("json_test is null.");
  }
  return JsExpression::FromJson(json_test);
}

absl::StatusOr<std::unique_ptr<JsStatement>>
JsWhileStatement::GetBody(const nlohmann::json& json) {
  auto body_it = json.find("body");
  if (body_it == json.end()) {
    return absl::InvalidArgumentError("`body` is undefined.");
  }
  const nlohmann::json& json_body = body_it.value();

  if (json_body.is_null()) {
    return absl::InvalidArgumentError("json_body is null.");
  }
  return JsStatement::FromJson(json_body);
}

absl::StatusOr<std::unique_ptr<JsWhileStatement>>
JsWhileStatement::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto test, JsWhileStatement::GetTest(json));
  MALDOCA_ASSIGN_OR_RETURN(auto body, JsWhileStatement::GetBody(json));

  return absl::make_unique<JsWhileStatement>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(test),
      std::move(body));
}

// =============================================================================
// JsDoWhileStatement
// =============================================================================

absl::StatusOr<std::unique_ptr<JsStatement>>
JsDoWhileStatement::GetBody(const nlohmann::json& json) {
  auto body_it = json.find("body");
  if (body_it == json.end()) {
    return absl::InvalidArgumentError("`body` is undefined.");
  }
  const nlohmann::json& json_body = body_it.value();

  if (json_body.is_null()) {
    return absl::InvalidArgumentError("json_body is null.");
  }
  return JsStatement::FromJson(json_body);
}

absl::StatusOr<std::unique_ptr<JsExpression>>
JsDoWhileStatement::GetTest(const nlohmann::json& json) {
  auto test_it = json.find("test");
  if (test_it == json.end()) {
    return absl::InvalidArgumentError("`test` is undefined.");
  }
  const nlohmann::json& json_test = test_it.value();

  if (json_test.is_null()) {
    return absl::InvalidArgumentError("json_test is null.");
  }
  return JsExpression::FromJson(json_test);
}

absl::StatusOr<std::unique_ptr<JsDoWhileStatement>>
JsDoWhileStatement::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto body, JsDoWhileStatement::GetBody(json));
  MALDOCA_ASSIGN_OR_RETURN(auto test, JsDoWhileStatement::GetTest(json));

  return absl::make_unique<JsDoWhileStatement>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(body),
      std::move(test));
}

// =============================================================================
// JsDeclaration
// =============================================================================

absl::StatusOr<std::unique_ptr<JsDeclaration>>
JsDeclaration::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(std::string type, GetType(json));

  if (type == "FunctionDeclaration") {
    return JsFunctionDeclaration::FromJson(json);
  } else if (type == "VariableDeclaration") {
    return JsVariableDeclaration::FromJson(json);
  } else if (type == "ClassDeclaration") {
    return JsClassDeclaration::FromJson(json);
  }
  return absl::InvalidArgumentError(absl::StrCat("Invalid type: ", type));
}

// =============================================================================
// JsVariableDeclarator
// =============================================================================

absl::StatusOr<std::unique_ptr<JsLVal>>
JsVariableDeclarator::GetId(const nlohmann::json& json) {
  auto id_it = json.find("id");
  if (id_it == json.end()) {
    return absl::InvalidArgumentError("`id` is undefined.");
  }
  const nlohmann::json& json_id = id_it.value();

  if (json_id.is_null()) {
    return absl::InvalidArgumentError("json_id is null.");
  }
  return JsLVal::FromJson(json_id);
}

absl::StatusOr<std::optional<std::unique_ptr<JsExpression>>>
JsVariableDeclarator::GetInit(const nlohmann::json& json) {
  auto init_it = json.find("init");
  if (init_it == json.end()) {
    return absl::InvalidArgumentError("`init` is undefined.");
  }
  const nlohmann::json& json_init = init_it.value();

  if (json_init.is_null()) {
    return std::nullopt;
  }
  return JsExpression::FromJson(json_init);
}

absl::StatusOr<std::unique_ptr<JsVariableDeclarator>>
JsVariableDeclarator::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto id, JsVariableDeclarator::GetId(json));
  MALDOCA_ASSIGN_OR_RETURN(auto init, JsVariableDeclarator::GetInit(json));

  return absl::make_unique<JsVariableDeclarator>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(id),
      std::move(init));
}

// =============================================================================
// JsVariableDeclaration
// =============================================================================

static bool IsVariableDeclaration(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  return type == "VariableDeclaration";
}

absl::StatusOr<std::vector<std::unique_ptr<JsVariableDeclarator>>>
JsVariableDeclaration::GetDeclarations(const nlohmann::json& json) {
  auto declarations_it = json.find("declarations");
  if (declarations_it == json.end()) {
    return absl::InvalidArgumentError("`declarations` is undefined.");
  }
  const nlohmann::json& json_declarations = declarations_it.value();

  if (json_declarations.is_null()) {
    return absl::InvalidArgumentError("json_declarations is null.");
  }
  if (!json_declarations.is_array()) {
    return absl::InvalidArgumentError("json_declarations expected to be array.");
  }

  std::vector<std::unique_ptr<JsVariableDeclarator>> declarations;
  for (const nlohmann::json& json_declarations_element : json_declarations) {
    if (json_declarations_element.is_null()) {
      return absl::InvalidArgumentError("json_declarations_element is null.");
    }
    MALDOCA_ASSIGN_OR_RETURN(auto declarations_element, JsVariableDeclarator::FromJson(json_declarations_element));
    declarations.push_back(std::move(declarations_element));
  }
  return declarations;
}

absl::StatusOr<std::string>
JsVariableDeclaration::GetKind(const nlohmann::json& json) {
  auto kind_it = json.find("kind");
  if (kind_it == json.end()) {
    return absl::InvalidArgumentError("`kind` is undefined.");
  }
  const nlohmann::json& json_kind = kind_it.value();

  if (json_kind.is_null()) {
    return absl::InvalidArgumentError("json_kind is null.");
  }
  if (!json_kind.is_string()) {
    return absl::InvalidArgumentError("Expecting json_kind.is_string().");
  }
  return json_kind.get<std::string>();
}

absl::StatusOr<std::unique_ptr<JsVariableDeclaration>>
JsVariableDeclaration::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto declarations, JsVariableDeclaration::GetDeclarations(json));
  MALDOCA_ASSIGN_OR_RETURN(auto kind, JsVariableDeclaration::GetKind(json));

  return absl::make_unique<JsVariableDeclaration>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(declarations),
      std::move(kind));
}

// =============================================================================
// JsForStatement
// =============================================================================

absl::StatusOr<std::optional<std::variant<std::unique_ptr<JsVariableDeclaration>, std::unique_ptr<JsExpression>>>>
JsForStatement::GetInit(const nlohmann::json& json) {
  auto init_it = json.find("init");
  if (init_it == json.end()) {
    return absl::InvalidArgumentError("`init` is undefined.");
  }
  const nlohmann::json& json_init = init_it.value();

  if (json_init.is_null()) {
    return std::nullopt;
  }
  if (IsVariableDeclaration(json_init)) {
    return JsVariableDeclaration::FromJson(json_init);
  } else if (IsExpression(json_init)) {
    return JsExpression::FromJson(json_init);
  } else {
    auto result = absl::InvalidArgumentError("json_init has invalid type.");
    result.SetPayload("json", absl::Cord{json.dump()});
    result.SetPayload("json_element", absl::Cord{json_init.dump()});
    return result;
  }
}

absl::StatusOr<std::optional<std::unique_ptr<JsExpression>>>
JsForStatement::GetTest(const nlohmann::json& json) {
  auto test_it = json.find("test");
  if (test_it == json.end()) {
    return absl::InvalidArgumentError("`test` is undefined.");
  }
  const nlohmann::json& json_test = test_it.value();

  if (json_test.is_null()) {
    return std::nullopt;
  }
  return JsExpression::FromJson(json_test);
}

absl::StatusOr<std::optional<std::unique_ptr<JsExpression>>>
JsForStatement::GetUpdate(const nlohmann::json& json) {
  auto update_it = json.find("update");
  if (update_it == json.end()) {
    return absl::InvalidArgumentError("`update` is undefined.");
  }
  const nlohmann::json& json_update = update_it.value();

  if (json_update.is_null()) {
    return std::nullopt;
  }
  return JsExpression::FromJson(json_update);
}

absl::StatusOr<std::unique_ptr<JsStatement>>
JsForStatement::GetBody(const nlohmann::json& json) {
  auto body_it = json.find("body");
  if (body_it == json.end()) {
    return absl::InvalidArgumentError("`body` is undefined.");
  }
  const nlohmann::json& json_body = body_it.value();

  if (json_body.is_null()) {
    return absl::InvalidArgumentError("json_body is null.");
  }
  return JsStatement::FromJson(json_body);
}

absl::StatusOr<std::unique_ptr<JsForStatement>>
JsForStatement::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto init, JsForStatement::GetInit(json));
  MALDOCA_ASSIGN_OR_RETURN(auto test, JsForStatement::GetTest(json));
  MALDOCA_ASSIGN_OR_RETURN(auto update, JsForStatement::GetUpdate(json));
  MALDOCA_ASSIGN_OR_RETURN(auto body, JsForStatement::GetBody(json));

  return absl::make_unique<JsForStatement>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(init),
      std::move(test),
      std::move(update),
      std::move(body));
}

// =============================================================================
// JsForInStatement
// =============================================================================

absl::StatusOr<std::variant<std::unique_ptr<JsVariableDeclaration>, std::unique_ptr<JsLVal>>>
JsForInStatement::GetLeft(const nlohmann::json& json) {
  auto left_it = json.find("left");
  if (left_it == json.end()) {
    return absl::InvalidArgumentError("`left` is undefined.");
  }
  const nlohmann::json& json_left = left_it.value();

  if (json_left.is_null()) {
    return absl::InvalidArgumentError("json_left is null.");
  }
  if (IsVariableDeclaration(json_left)) {
    return JsVariableDeclaration::FromJson(json_left);
  } else if (IsLVal(json_left)) {
    return JsLVal::FromJson(json_left);
  } else {
    auto result = absl::InvalidArgumentError("json_left has invalid type.");
    result.SetPayload("json", absl::Cord{json.dump()});
    result.SetPayload("json_element", absl::Cord{json_left.dump()});
    return result;
  }
}

absl::StatusOr<std::unique_ptr<JsExpression>>
JsForInStatement::GetRight(const nlohmann::json& json) {
  auto right_it = json.find("right");
  if (right_it == json.end()) {
    return absl::InvalidArgumentError("`right` is undefined.");
  }
  const nlohmann::json& json_right = right_it.value();

  if (json_right.is_null()) {
    return absl::InvalidArgumentError("json_right is null.");
  }
  return JsExpression::FromJson(json_right);
}

absl::StatusOr<std::unique_ptr<JsStatement>>
JsForInStatement::GetBody(const nlohmann::json& json) {
  auto body_it = json.find("body");
  if (body_it == json.end()) {
    return absl::InvalidArgumentError("`body` is undefined.");
  }
  const nlohmann::json& json_body = body_it.value();

  if (json_body.is_null()) {
    return absl::InvalidArgumentError("json_body is null.");
  }
  return JsStatement::FromJson(json_body);
}

absl::StatusOr<std::unique_ptr<JsForInStatement>>
JsForInStatement::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto left, JsForInStatement::GetLeft(json));
  MALDOCA_ASSIGN_OR_RETURN(auto right, JsForInStatement::GetRight(json));
  MALDOCA_ASSIGN_OR_RETURN(auto body, JsForInStatement::GetBody(json));

  return absl::make_unique<JsForInStatement>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(left),
      std::move(right),
      std::move(body));
}

// =============================================================================
// JsForOfStatement
// =============================================================================

absl::StatusOr<std::variant<std::unique_ptr<JsVariableDeclaration>, std::unique_ptr<JsLVal>>>
JsForOfStatement::GetLeft(const nlohmann::json& json) {
  auto left_it = json.find("left");
  if (left_it == json.end()) {
    return absl::InvalidArgumentError("`left` is undefined.");
  }
  const nlohmann::json& json_left = left_it.value();

  if (json_left.is_null()) {
    return absl::InvalidArgumentError("json_left is null.");
  }
  if (IsVariableDeclaration(json_left)) {
    return JsVariableDeclaration::FromJson(json_left);
  } else if (IsLVal(json_left)) {
    return JsLVal::FromJson(json_left);
  } else {
    auto result = absl::InvalidArgumentError("json_left has invalid type.");
    result.SetPayload("json", absl::Cord{json.dump()});
    result.SetPayload("json_element", absl::Cord{json_left.dump()});
    return result;
  }
}

absl::StatusOr<std::unique_ptr<JsExpression>>
JsForOfStatement::GetRight(const nlohmann::json& json) {
  auto right_it = json.find("right");
  if (right_it == json.end()) {
    return absl::InvalidArgumentError("`right` is undefined.");
  }
  const nlohmann::json& json_right = right_it.value();

  if (json_right.is_null()) {
    return absl::InvalidArgumentError("json_right is null.");
  }
  return JsExpression::FromJson(json_right);
}

absl::StatusOr<std::unique_ptr<JsStatement>>
JsForOfStatement::GetBody(const nlohmann::json& json) {
  auto body_it = json.find("body");
  if (body_it == json.end()) {
    return absl::InvalidArgumentError("`body` is undefined.");
  }
  const nlohmann::json& json_body = body_it.value();

  if (json_body.is_null()) {
    return absl::InvalidArgumentError("json_body is null.");
  }
  return JsStatement::FromJson(json_body);
}

absl::StatusOr<bool>
JsForOfStatement::GetAwait(const nlohmann::json& json) {
  auto await_it = json.find("await");
  if (await_it == json.end()) {
    return absl::InvalidArgumentError("`await` is undefined.");
  }
  const nlohmann::json& json_await = await_it.value();

  if (json_await.is_null()) {
    return absl::InvalidArgumentError("json_await is null.");
  }
  if (!json_await.is_boolean()) {
    return absl::InvalidArgumentError("Expecting json_await.is_boolean().");
  }
  return json_await.get<bool>();
}

absl::StatusOr<std::unique_ptr<JsForOfStatement>>
JsForOfStatement::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto left, JsForOfStatement::GetLeft(json));
  MALDOCA_ASSIGN_OR_RETURN(auto right, JsForOfStatement::GetRight(json));
  MALDOCA_ASSIGN_OR_RETURN(auto body, JsForOfStatement::GetBody(json));
  MALDOCA_ASSIGN_OR_RETURN(auto await, JsForOfStatement::GetAwait(json));

  return absl::make_unique<JsForOfStatement>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(left),
      std::move(right),
      std::move(body),
      std::move(await));
}

// =============================================================================
// JsFunctionDeclaration
// =============================================================================

static bool IsFunctionDeclaration(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  return type == "FunctionDeclaration";
}

absl::StatusOr<std::unique_ptr<JsFunctionDeclaration>>
JsFunctionDeclaration::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto id, JsFunction::GetId(json));
  MALDOCA_ASSIGN_OR_RETURN(auto params, JsFunction::GetParams(json));
  MALDOCA_ASSIGN_OR_RETURN(auto generator, JsFunction::GetGenerator(json));
  MALDOCA_ASSIGN_OR_RETURN(auto async, JsFunction::GetAsync(json));
  MALDOCA_ASSIGN_OR_RETURN(auto body, JsBlockStatementFunction::GetBody(json));

  return absl::make_unique<JsFunctionDeclaration>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(id),
      std::move(params),
      std::move(generator),
      std::move(async),
      std::move(body));
}

// =============================================================================
// JsSuper
// =============================================================================

static bool IsSuper(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  return type == "Super";
}

absl::StatusOr<std::unique_ptr<JsSuper>>
JsSuper::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));

  return absl::make_unique<JsSuper>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols));
}

// =============================================================================
// JsImport
// =============================================================================

static bool IsImport(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  return type == "Import";
}

absl::StatusOr<std::unique_ptr<JsImport>>
JsImport::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));

  return absl::make_unique<JsImport>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols));
}

// =============================================================================
// JsThisExpression
// =============================================================================

absl::StatusOr<std::unique_ptr<JsThisExpression>>
JsThisExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));

  return absl::make_unique<JsThisExpression>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols));
}

// =============================================================================
// JsArrowFunctionExpression
// =============================================================================

absl::StatusOr<std::variant<std::unique_ptr<JsBlockStatement>, std::unique_ptr<JsExpression>>>
JsArrowFunctionExpression::GetBody(const nlohmann::json& json) {
  auto body_it = json.find("body");
  if (body_it == json.end()) {
    return absl::InvalidArgumentError("`body` is undefined.");
  }
  const nlohmann::json& json_body = body_it.value();

  if (json_body.is_null()) {
    return absl::InvalidArgumentError("json_body is null.");
  }
  if (IsBlockStatement(json_body)) {
    return JsBlockStatement::FromJson(json_body);
  } else if (IsExpression(json_body)) {
    return JsExpression::FromJson(json_body);
  } else {
    auto result = absl::InvalidArgumentError("json_body has invalid type.");
    result.SetPayload("json", absl::Cord{json.dump()});
    result.SetPayload("json_element", absl::Cord{json_body.dump()});
    return result;
  }
}

absl::StatusOr<std::unique_ptr<JsArrowFunctionExpression>>
JsArrowFunctionExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto id, JsFunction::GetId(json));
  MALDOCA_ASSIGN_OR_RETURN(auto params, JsFunction::GetParams(json));
  MALDOCA_ASSIGN_OR_RETURN(auto generator, JsFunction::GetGenerator(json));
  MALDOCA_ASSIGN_OR_RETURN(auto async, JsFunction::GetAsync(json));
  MALDOCA_ASSIGN_OR_RETURN(auto body, JsArrowFunctionExpression::GetBody(json));

  return absl::make_unique<JsArrowFunctionExpression>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(id),
      std::move(params),
      std::move(generator),
      std::move(async),
      std::move(body));
}

// =============================================================================
// JsYieldExpression
// =============================================================================

absl::StatusOr<std::optional<std::unique_ptr<JsExpression>>>
JsYieldExpression::GetArgument(const nlohmann::json& json) {
  auto argument_it = json.find("argument");
  if (argument_it == json.end()) {
    return absl::InvalidArgumentError("`argument` is undefined.");
  }
  const nlohmann::json& json_argument = argument_it.value();

  if (json_argument.is_null()) {
    return std::nullopt;
  }
  return JsExpression::FromJson(json_argument);
}

absl::StatusOr<bool>
JsYieldExpression::GetDelegate(const nlohmann::json& json) {
  auto delegate_it = json.find("delegate");
  if (delegate_it == json.end()) {
    return absl::InvalidArgumentError("`delegate` is undefined.");
  }
  const nlohmann::json& json_delegate = delegate_it.value();

  if (json_delegate.is_null()) {
    return absl::InvalidArgumentError("json_delegate is null.");
  }
  if (!json_delegate.is_boolean()) {
    return absl::InvalidArgumentError("Expecting json_delegate.is_boolean().");
  }
  return json_delegate.get<bool>();
}

absl::StatusOr<std::unique_ptr<JsYieldExpression>>
JsYieldExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto argument, JsYieldExpression::GetArgument(json));
  MALDOCA_ASSIGN_OR_RETURN(auto delegate, JsYieldExpression::GetDelegate(json));

  return absl::make_unique<JsYieldExpression>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(argument),
      std::move(delegate));
}

// =============================================================================
// JsAwaitExpression
// =============================================================================

absl::StatusOr<std::optional<std::unique_ptr<JsExpression>>>
JsAwaitExpression::GetArgument(const nlohmann::json& json) {
  auto argument_it = json.find("argument");
  if (argument_it == json.end()) {
    return absl::InvalidArgumentError("`argument` is undefined.");
  }
  const nlohmann::json& json_argument = argument_it.value();

  if (json_argument.is_null()) {
    return std::nullopt;
  }
  return JsExpression::FromJson(json_argument);
}

absl::StatusOr<std::unique_ptr<JsAwaitExpression>>
JsAwaitExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto argument, JsAwaitExpression::GetArgument(json));

  return absl::make_unique<JsAwaitExpression>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(argument));
}

// =============================================================================
// JsSpreadElement
// =============================================================================

static bool IsSpreadElement(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  return type == "SpreadElement";
}

absl::StatusOr<std::unique_ptr<JsExpression>>
JsSpreadElement::GetArgument(const nlohmann::json& json) {
  auto argument_it = json.find("argument");
  if (argument_it == json.end()) {
    return absl::InvalidArgumentError("`argument` is undefined.");
  }
  const nlohmann::json& json_argument = argument_it.value();

  if (json_argument.is_null()) {
    return absl::InvalidArgumentError("json_argument is null.");
  }
  return JsExpression::FromJson(json_argument);
}

absl::StatusOr<std::unique_ptr<JsSpreadElement>>
JsSpreadElement::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto argument, JsSpreadElement::GetArgument(json));

  return absl::make_unique<JsSpreadElement>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(argument));
}

// =============================================================================
// JsArrayExpression
// =============================================================================

absl::StatusOr<std::vector<std::optional<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>>>>
JsArrayExpression::GetElements(const nlohmann::json& json) {
  auto elements_it = json.find("elements");
  if (elements_it == json.end()) {
    return absl::InvalidArgumentError("`elements` is undefined.");
  }
  const nlohmann::json& json_elements = elements_it.value();

  if (json_elements.is_null()) {
    return absl::InvalidArgumentError("json_elements is null.");
  }
  if (!json_elements.is_array()) {
    return absl::InvalidArgumentError("json_elements expected to be array.");
  }

  std::vector<std::optional<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>>> elements;
  for (const nlohmann::json& json_elements_element : json_elements) {
    std::optional<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>> elements_element;
    if (!json_elements_element.is_null()) {
      if (IsExpression(json_elements_element)) {
        MALDOCA_ASSIGN_OR_RETURN(elements_element, JsExpression::FromJson(json_elements_element));
      } else if (IsSpreadElement(json_elements_element)) {
        MALDOCA_ASSIGN_OR_RETURN(elements_element, JsSpreadElement::FromJson(json_elements_element));
      } else {
        auto result = absl::InvalidArgumentError("json_elements_element has invalid type.");
        result.SetPayload("json", absl::Cord{json.dump()});
        result.SetPayload("json_element", absl::Cord{json_elements_element.dump()});
        return result;
      }
    }
    elements.push_back(std::move(elements_element));
  }
  return elements;
}

absl::StatusOr<std::unique_ptr<JsArrayExpression>>
JsArrayExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto elements, JsArrayExpression::GetElements(json));

  return absl::make_unique<JsArrayExpression>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(elements));
}

// =============================================================================
// JsObjectMember
// =============================================================================

absl::StatusOr<std::unique_ptr<JsExpression>>
JsObjectMember::GetKey(const nlohmann::json& json) {
  auto key_it = json.find("key");
  if (key_it == json.end()) {
    return absl::InvalidArgumentError("`key` is undefined.");
  }
  const nlohmann::json& json_key = key_it.value();

  if (json_key.is_null()) {
    return absl::InvalidArgumentError("json_key is null.");
  }
  return JsExpression::FromJson(json_key);
}

absl::StatusOr<bool>
JsObjectMember::GetComputed(const nlohmann::json& json) {
  auto computed_it = json.find("computed");
  if (computed_it == json.end()) {
    return absl::InvalidArgumentError("`computed` is undefined.");
  }
  const nlohmann::json& json_computed = computed_it.value();

  if (json_computed.is_null()) {
    return absl::InvalidArgumentError("json_computed is null.");
  }
  if (!json_computed.is_boolean()) {
    return absl::InvalidArgumentError("Expecting json_computed.is_boolean().");
  }
  return json_computed.get<bool>();
}

absl::StatusOr<std::unique_ptr<JsObjectMember>>
JsObjectMember::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(std::string type, GetType(json));

  if (type == "ObjectProperty") {
    return JsObjectProperty::FromJson(json);
  } else if (type == "ObjectMethod") {
    return JsObjectMethod::FromJson(json);
  }
  return absl::InvalidArgumentError(absl::StrCat("Invalid type: ", type));
}

// =============================================================================
// JsObjectProperty
// =============================================================================

static bool IsObjectProperty(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  return type == "ObjectProperty";
}

absl::StatusOr<bool>
JsObjectProperty::GetShorthand(const nlohmann::json& json) {
  auto shorthand_it = json.find("shorthand");
  if (shorthand_it == json.end()) {
    return absl::InvalidArgumentError("`shorthand` is undefined.");
  }
  const nlohmann::json& json_shorthand = shorthand_it.value();

  if (json_shorthand.is_null()) {
    return absl::InvalidArgumentError("json_shorthand is null.");
  }
  if (!json_shorthand.is_boolean()) {
    return absl::InvalidArgumentError("Expecting json_shorthand.is_boolean().");
  }
  return json_shorthand.get<bool>();
}

absl::StatusOr<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsPattern>>>
JsObjectProperty::GetValue(const nlohmann::json& json) {
  auto value_it = json.find("value");
  if (value_it == json.end()) {
    return absl::InvalidArgumentError("`value` is undefined.");
  }
  const nlohmann::json& json_value = value_it.value();

  if (json_value.is_null()) {
    return absl::InvalidArgumentError("json_value is null.");
  }
  if (IsExpression(json_value)) {
    return JsExpression::FromJson(json_value);
  } else if (IsPattern(json_value)) {
    return JsPattern::FromJson(json_value);
  } else {
    auto result = absl::InvalidArgumentError("json_value has invalid type.");
    result.SetPayload("json", absl::Cord{json.dump()});
    result.SetPayload("json_element", absl::Cord{json_value.dump()});
    return result;
  }
}

absl::StatusOr<std::unique_ptr<JsObjectProperty>>
JsObjectProperty::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto key, JsObjectMember::GetKey(json));
  MALDOCA_ASSIGN_OR_RETURN(auto computed, JsObjectMember::GetComputed(json));
  MALDOCA_ASSIGN_OR_RETURN(auto shorthand, JsObjectProperty::GetShorthand(json));
  MALDOCA_ASSIGN_OR_RETURN(auto value, JsObjectProperty::GetValue(json));

  return absl::make_unique<JsObjectProperty>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(key),
      std::move(computed),
      std::move(shorthand),
      std::move(value));
}

// =============================================================================
// JsObjectMethod
// =============================================================================

static bool IsObjectMethod(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  return type == "ObjectMethod";
}

absl::StatusOr<std::string>
JsObjectMethod::GetKind(const nlohmann::json& json) {
  auto kind_it = json.find("kind");
  if (kind_it == json.end()) {
    return absl::InvalidArgumentError("`kind` is undefined.");
  }
  const nlohmann::json& json_kind = kind_it.value();

  if (json_kind.is_null()) {
    return absl::InvalidArgumentError("json_kind is null.");
  }
  if (!json_kind.is_string()) {
    return absl::InvalidArgumentError("Expecting json_kind.is_string().");
  }
  return json_kind.get<std::string>();
}

absl::StatusOr<std::unique_ptr<JsObjectMethod>>
JsObjectMethod::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto key, JsObjectMember::GetKey(json));
  MALDOCA_ASSIGN_OR_RETURN(auto computed, JsObjectMember::GetComputed(json));
  MALDOCA_ASSIGN_OR_RETURN(auto id, JsFunction::GetId(json));
  MALDOCA_ASSIGN_OR_RETURN(auto params, JsFunction::GetParams(json));
  MALDOCA_ASSIGN_OR_RETURN(auto generator, JsFunction::GetGenerator(json));
  MALDOCA_ASSIGN_OR_RETURN(auto async, JsFunction::GetAsync(json));
  MALDOCA_ASSIGN_OR_RETURN(auto body, JsBlockStatementFunction::GetBody(json));
  MALDOCA_ASSIGN_OR_RETURN(auto kind, JsObjectMethod::GetKind(json));

  return absl::make_unique<JsObjectMethod>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(key),
      std::move(computed),
      std::move(id),
      std::move(params),
      std::move(generator),
      std::move(async),
      std::move(body),
      std::move(kind));
}

// =============================================================================
// JsObjectExpression
// =============================================================================

absl::StatusOr<std::vector<std::variant<std::unique_ptr<JsObjectProperty>, std::unique_ptr<JsObjectMethod>, std::unique_ptr<JsSpreadElement>>>>
JsObjectExpression::GetProperties(const nlohmann::json& json) {
  auto properties_it = json.find("properties");
  if (properties_it == json.end()) {
    return absl::InvalidArgumentError("`properties` is undefined.");
  }
  const nlohmann::json& json_properties = properties_it.value();

  if (json_properties.is_null()) {
    return absl::InvalidArgumentError("json_properties is null.");
  }
  if (!json_properties.is_array()) {
    return absl::InvalidArgumentError("json_properties expected to be array.");
  }

  std::vector<std::variant<std::unique_ptr<JsObjectProperty>, std::unique_ptr<JsObjectMethod>, std::unique_ptr<JsSpreadElement>>> properties_;
  for (const nlohmann::json& json_properties_element : json_properties) {
    if (json_properties_element.is_null()) {
      return absl::InvalidArgumentError("json_properties_element is null.");
    }
    std::variant<std::unique_ptr<JsObjectProperty>, std::unique_ptr<JsObjectMethod>, std::unique_ptr<JsSpreadElement>> properties_element;
    if (IsObjectProperty(json_properties_element)) {
      MALDOCA_ASSIGN_OR_RETURN(properties_element, JsObjectProperty::FromJson(json_properties_element));
    } else if (IsObjectMethod(json_properties_element)) {
      MALDOCA_ASSIGN_OR_RETURN(properties_element, JsObjectMethod::FromJson(json_properties_element));
    } else if (IsSpreadElement(json_properties_element)) {
      MALDOCA_ASSIGN_OR_RETURN(properties_element, JsSpreadElement::FromJson(json_properties_element));
    } else {
      auto result = absl::InvalidArgumentError("json_properties_element has invalid type.");
      result.SetPayload("json", absl::Cord{json.dump()});
      result.SetPayload("json_element", absl::Cord{json_properties_element.dump()});
      return result;
    }
    properties_.push_back(std::move(properties_element));
  }
  return properties_;
}

absl::StatusOr<std::unique_ptr<JsObjectExpression>>
JsObjectExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto properties_, JsObjectExpression::GetProperties(json));

  return absl::make_unique<JsObjectExpression>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(properties_));
}

// =============================================================================
// JsFunctionExpression
// =============================================================================

absl::StatusOr<std::unique_ptr<JsFunctionExpression>>
JsFunctionExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto id, JsFunction::GetId(json));
  MALDOCA_ASSIGN_OR_RETURN(auto params, JsFunction::GetParams(json));
  MALDOCA_ASSIGN_OR_RETURN(auto generator, JsFunction::GetGenerator(json));
  MALDOCA_ASSIGN_OR_RETURN(auto async, JsFunction::GetAsync(json));
  MALDOCA_ASSIGN_OR_RETURN(auto body, JsBlockStatementFunction::GetBody(json));

  return absl::make_unique<JsFunctionExpression>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(id),
      std::move(params),
      std::move(generator),
      std::move(async),
      std::move(body));
}

// =============================================================================
// JsUnaryExpression
// =============================================================================

absl::StatusOr<JsUnaryOperator>
JsUnaryExpression::GetOperator(const nlohmann::json& json) {
  auto operator_it = json.find("operator");
  if (operator_it == json.end()) {
    return absl::InvalidArgumentError("`operator` is undefined.");
  }
  const nlohmann::json& json_operator = operator_it.value();

  if (json_operator.is_null()) {
    return absl::InvalidArgumentError("json_operator is null.");
  }
  if (!json_operator.is_string()) {
    return absl::InvalidArgumentError("`json_operator` expected to be a string.");
  }
  std::string json_operator_str = json_operator.get<std::string>();
  return StringToJsUnaryOperator(json_operator_str);
}

absl::StatusOr<bool>
JsUnaryExpression::GetPrefix(const nlohmann::json& json) {
  auto prefix_it = json.find("prefix");
  if (prefix_it == json.end()) {
    return absl::InvalidArgumentError("`prefix` is undefined.");
  }
  const nlohmann::json& json_prefix = prefix_it.value();

  if (json_prefix.is_null()) {
    return absl::InvalidArgumentError("json_prefix is null.");
  }
  if (!json_prefix.is_boolean()) {
    return absl::InvalidArgumentError("Expecting json_prefix.is_boolean().");
  }
  return json_prefix.get<bool>();
}

absl::StatusOr<std::unique_ptr<JsExpression>>
JsUnaryExpression::GetArgument(const nlohmann::json& json) {
  auto argument_it = json.find("argument");
  if (argument_it == json.end()) {
    return absl::InvalidArgumentError("`argument` is undefined.");
  }
  const nlohmann::json& json_argument = argument_it.value();

  if (json_argument.is_null()) {
    return absl::InvalidArgumentError("json_argument is null.");
  }
  return JsExpression::FromJson(json_argument);
}

absl::StatusOr<std::unique_ptr<JsUnaryExpression>>
JsUnaryExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto operator_, JsUnaryExpression::GetOperator(json));
  MALDOCA_ASSIGN_OR_RETURN(auto prefix, JsUnaryExpression::GetPrefix(json));
  MALDOCA_ASSIGN_OR_RETURN(auto argument, JsUnaryExpression::GetArgument(json));

  return absl::make_unique<JsUnaryExpression>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(operator_),
      std::move(prefix),
      std::move(argument));
}

// =============================================================================
// JsUpdateExpression
// =============================================================================

absl::StatusOr<JsUpdateOperator>
JsUpdateExpression::GetOperator(const nlohmann::json& json) {
  auto operator_it = json.find("operator");
  if (operator_it == json.end()) {
    return absl::InvalidArgumentError("`operator` is undefined.");
  }
  const nlohmann::json& json_operator = operator_it.value();

  if (json_operator.is_null()) {
    return absl::InvalidArgumentError("json_operator is null.");
  }
  if (!json_operator.is_string()) {
    return absl::InvalidArgumentError("`json_operator` expected to be a string.");
  }
  std::string json_operator_str = json_operator.get<std::string>();
  return StringToJsUpdateOperator(json_operator_str);
}

absl::StatusOr<std::unique_ptr<JsLVal>>
JsUpdateExpression::GetArgument(const nlohmann::json& json) {
  auto argument_it = json.find("argument");
  if (argument_it == json.end()) {
    return absl::InvalidArgumentError("`argument` is undefined.");
  }
  const nlohmann::json& json_argument = argument_it.value();

  if (json_argument.is_null()) {
    return absl::InvalidArgumentError("json_argument is null.");
  }
  return JsLVal::FromJson(json_argument);
}

absl::StatusOr<bool>
JsUpdateExpression::GetPrefix(const nlohmann::json& json) {
  auto prefix_it = json.find("prefix");
  if (prefix_it == json.end()) {
    return absl::InvalidArgumentError("`prefix` is undefined.");
  }
  const nlohmann::json& json_prefix = prefix_it.value();

  if (json_prefix.is_null()) {
    return absl::InvalidArgumentError("json_prefix is null.");
  }
  if (!json_prefix.is_boolean()) {
    return absl::InvalidArgumentError("Expecting json_prefix.is_boolean().");
  }
  return json_prefix.get<bool>();
}

absl::StatusOr<std::unique_ptr<JsUpdateExpression>>
JsUpdateExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto operator_, JsUpdateExpression::GetOperator(json));
  MALDOCA_ASSIGN_OR_RETURN(auto argument, JsUpdateExpression::GetArgument(json));
  MALDOCA_ASSIGN_OR_RETURN(auto prefix, JsUpdateExpression::GetPrefix(json));

  return absl::make_unique<JsUpdateExpression>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(operator_),
      std::move(argument),
      std::move(prefix));
}

// =============================================================================
// JsBinaryExpression
// =============================================================================

absl::StatusOr<JsBinaryOperator>
JsBinaryExpression::GetOperator(const nlohmann::json& json) {
  auto operator_it = json.find("operator");
  if (operator_it == json.end()) {
    return absl::InvalidArgumentError("`operator` is undefined.");
  }
  const nlohmann::json& json_operator = operator_it.value();

  if (json_operator.is_null()) {
    return absl::InvalidArgumentError("json_operator is null.");
  }
  if (!json_operator.is_string()) {
    return absl::InvalidArgumentError("`json_operator` expected to be a string.");
  }
  std::string json_operator_str = json_operator.get<std::string>();
  return StringToJsBinaryOperator(json_operator_str);
}

absl::StatusOr<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsPrivateName>>>
JsBinaryExpression::GetLeft(const nlohmann::json& json) {
  auto left_it = json.find("left");
  if (left_it == json.end()) {
    return absl::InvalidArgumentError("`left` is undefined.");
  }
  const nlohmann::json& json_left = left_it.value();

  if (json_left.is_null()) {
    return absl::InvalidArgumentError("json_left is null.");
  }
  if (IsExpression(json_left)) {
    return JsExpression::FromJson(json_left);
  } else if (IsPrivateName(json_left)) {
    return JsPrivateName::FromJson(json_left);
  } else {
    auto result = absl::InvalidArgumentError("json_left has invalid type.");
    result.SetPayload("json", absl::Cord{json.dump()});
    result.SetPayload("json_element", absl::Cord{json_left.dump()});
    return result;
  }
}

absl::StatusOr<std::unique_ptr<JsExpression>>
JsBinaryExpression::GetRight(const nlohmann::json& json) {
  auto right_it = json.find("right");
  if (right_it == json.end()) {
    return absl::InvalidArgumentError("`right` is undefined.");
  }
  const nlohmann::json& json_right = right_it.value();

  if (json_right.is_null()) {
    return absl::InvalidArgumentError("json_right is null.");
  }
  return JsExpression::FromJson(json_right);
}

absl::StatusOr<std::unique_ptr<JsBinaryExpression>>
JsBinaryExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto operator_, JsBinaryExpression::GetOperator(json));
  MALDOCA_ASSIGN_OR_RETURN(auto left, JsBinaryExpression::GetLeft(json));
  MALDOCA_ASSIGN_OR_RETURN(auto right, JsBinaryExpression::GetRight(json));

  return absl::make_unique<JsBinaryExpression>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(operator_),
      std::move(left),
      std::move(right));
}

// =============================================================================
// JsAssignmentExpression
// =============================================================================

absl::StatusOr<JsAssignmentOperator>
JsAssignmentExpression::GetOperator(const nlohmann::json& json) {
  auto operator_it = json.find("operator");
  if (operator_it == json.end()) {
    return absl::InvalidArgumentError("`operator` is undefined.");
  }
  const nlohmann::json& json_operator = operator_it.value();

  if (json_operator.is_null()) {
    return absl::InvalidArgumentError("json_operator is null.");
  }
  if (!json_operator.is_string()) {
    return absl::InvalidArgumentError("`json_operator` expected to be a string.");
  }
  std::string json_operator_str = json_operator.get<std::string>();
  return StringToJsAssignmentOperator(json_operator_str);
}

absl::StatusOr<std::unique_ptr<JsLVal>>
JsAssignmentExpression::GetLeft(const nlohmann::json& json) {
  auto left_it = json.find("left");
  if (left_it == json.end()) {
    return absl::InvalidArgumentError("`left` is undefined.");
  }
  const nlohmann::json& json_left = left_it.value();

  if (json_left.is_null()) {
    return absl::InvalidArgumentError("json_left is null.");
  }
  return JsLVal::FromJson(json_left);
}

absl::StatusOr<std::unique_ptr<JsExpression>>
JsAssignmentExpression::GetRight(const nlohmann::json& json) {
  auto right_it = json.find("right");
  if (right_it == json.end()) {
    return absl::InvalidArgumentError("`right` is undefined.");
  }
  const nlohmann::json& json_right = right_it.value();

  if (json_right.is_null()) {
    return absl::InvalidArgumentError("json_right is null.");
  }
  return JsExpression::FromJson(json_right);
}

absl::StatusOr<std::unique_ptr<JsAssignmentExpression>>
JsAssignmentExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto operator_, JsAssignmentExpression::GetOperator(json));
  MALDOCA_ASSIGN_OR_RETURN(auto left, JsAssignmentExpression::GetLeft(json));
  MALDOCA_ASSIGN_OR_RETURN(auto right, JsAssignmentExpression::GetRight(json));

  return absl::make_unique<JsAssignmentExpression>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(operator_),
      std::move(left),
      std::move(right));
}

// =============================================================================
// JsLogicalExpression
// =============================================================================

absl::StatusOr<JsLogicalOperator>
JsLogicalExpression::GetOperator(const nlohmann::json& json) {
  auto operator_it = json.find("operator");
  if (operator_it == json.end()) {
    return absl::InvalidArgumentError("`operator` is undefined.");
  }
  const nlohmann::json& json_operator = operator_it.value();

  if (json_operator.is_null()) {
    return absl::InvalidArgumentError("json_operator is null.");
  }
  if (!json_operator.is_string()) {
    return absl::InvalidArgumentError("`json_operator` expected to be a string.");
  }
  std::string json_operator_str = json_operator.get<std::string>();
  return StringToJsLogicalOperator(json_operator_str);
}

absl::StatusOr<std::unique_ptr<JsExpression>>
JsLogicalExpression::GetLeft(const nlohmann::json& json) {
  auto left_it = json.find("left");
  if (left_it == json.end()) {
    return absl::InvalidArgumentError("`left` is undefined.");
  }
  const nlohmann::json& json_left = left_it.value();

  if (json_left.is_null()) {
    return absl::InvalidArgumentError("json_left is null.");
  }
  return JsExpression::FromJson(json_left);
}

absl::StatusOr<std::unique_ptr<JsExpression>>
JsLogicalExpression::GetRight(const nlohmann::json& json) {
  auto right_it = json.find("right");
  if (right_it == json.end()) {
    return absl::InvalidArgumentError("`right` is undefined.");
  }
  const nlohmann::json& json_right = right_it.value();

  if (json_right.is_null()) {
    return absl::InvalidArgumentError("json_right is null.");
  }
  return JsExpression::FromJson(json_right);
}

absl::StatusOr<std::unique_ptr<JsLogicalExpression>>
JsLogicalExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto operator_, JsLogicalExpression::GetOperator(json));
  MALDOCA_ASSIGN_OR_RETURN(auto left, JsLogicalExpression::GetLeft(json));
  MALDOCA_ASSIGN_OR_RETURN(auto right, JsLogicalExpression::GetRight(json));

  return absl::make_unique<JsLogicalExpression>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(operator_),
      std::move(left),
      std::move(right));
}

// =============================================================================
// JsMemberExpression
// =============================================================================

absl::StatusOr<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSuper>>>
JsMemberExpression::GetObject(const nlohmann::json& json) {
  auto object_it = json.find("object");
  if (object_it == json.end()) {
    return absl::InvalidArgumentError("`object` is undefined.");
  }
  const nlohmann::json& json_object = object_it.value();

  if (json_object.is_null()) {
    return absl::InvalidArgumentError("json_object is null.");
  }
  if (IsExpression(json_object)) {
    return JsExpression::FromJson(json_object);
  } else if (IsSuper(json_object)) {
    return JsSuper::FromJson(json_object);
  } else {
    auto result = absl::InvalidArgumentError("json_object has invalid type.");
    result.SetPayload("json", absl::Cord{json.dump()});
    result.SetPayload("json_element", absl::Cord{json_object.dump()});
    return result;
  }
}

absl::StatusOr<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsPrivateName>>>
JsMemberExpression::GetProperty(const nlohmann::json& json) {
  auto property_it = json.find("property");
  if (property_it == json.end()) {
    return absl::InvalidArgumentError("`property` is undefined.");
  }
  const nlohmann::json& json_property = property_it.value();

  if (json_property.is_null()) {
    return absl::InvalidArgumentError("json_property is null.");
  }
  if (IsExpression(json_property)) {
    return JsExpression::FromJson(json_property);
  } else if (IsPrivateName(json_property)) {
    return JsPrivateName::FromJson(json_property);
  } else {
    auto result = absl::InvalidArgumentError("json_property has invalid type.");
    result.SetPayload("json", absl::Cord{json.dump()});
    result.SetPayload("json_element", absl::Cord{json_property.dump()});
    return result;
  }
}

absl::StatusOr<bool>
JsMemberExpression::GetComputed(const nlohmann::json& json) {
  auto computed_it = json.find("computed");
  if (computed_it == json.end()) {
    return absl::InvalidArgumentError("`computed` is undefined.");
  }
  const nlohmann::json& json_computed = computed_it.value();

  if (json_computed.is_null()) {
    return absl::InvalidArgumentError("json_computed is null.");
  }
  if (!json_computed.is_boolean()) {
    return absl::InvalidArgumentError("Expecting json_computed.is_boolean().");
  }
  return json_computed.get<bool>();
}

absl::StatusOr<std::unique_ptr<JsMemberExpression>>
JsMemberExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto object, JsMemberExpression::GetObject(json));
  MALDOCA_ASSIGN_OR_RETURN(auto property, JsMemberExpression::GetProperty(json));
  MALDOCA_ASSIGN_OR_RETURN(auto computed, JsMemberExpression::GetComputed(json));

  return absl::make_unique<JsMemberExpression>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(object),
      std::move(property),
      std::move(computed));
}

// =============================================================================
// JsOptionalMemberExpression
// =============================================================================

absl::StatusOr<std::unique_ptr<JsExpression>>
JsOptionalMemberExpression::GetObject(const nlohmann::json& json) {
  auto object_it = json.find("object");
  if (object_it == json.end()) {
    return absl::InvalidArgumentError("`object` is undefined.");
  }
  const nlohmann::json& json_object = object_it.value();

  if (json_object.is_null()) {
    return absl::InvalidArgumentError("json_object is null.");
  }
  return JsExpression::FromJson(json_object);
}

absl::StatusOr<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsPrivateName>>>
JsOptionalMemberExpression::GetProperty(const nlohmann::json& json) {
  auto property_it = json.find("property");
  if (property_it == json.end()) {
    return absl::InvalidArgumentError("`property` is undefined.");
  }
  const nlohmann::json& json_property = property_it.value();

  if (json_property.is_null()) {
    return absl::InvalidArgumentError("json_property is null.");
  }
  if (IsExpression(json_property)) {
    return JsExpression::FromJson(json_property);
  } else if (IsPrivateName(json_property)) {
    return JsPrivateName::FromJson(json_property);
  } else {
    auto result = absl::InvalidArgumentError("json_property has invalid type.");
    result.SetPayload("json", absl::Cord{json.dump()});
    result.SetPayload("json_element", absl::Cord{json_property.dump()});
    return result;
  }
}

absl::StatusOr<bool>
JsOptionalMemberExpression::GetComputed(const nlohmann::json& json) {
  auto computed_it = json.find("computed");
  if (computed_it == json.end()) {
    return absl::InvalidArgumentError("`computed` is undefined.");
  }
  const nlohmann::json& json_computed = computed_it.value();

  if (json_computed.is_null()) {
    return absl::InvalidArgumentError("json_computed is null.");
  }
  if (!json_computed.is_boolean()) {
    return absl::InvalidArgumentError("Expecting json_computed.is_boolean().");
  }
  return json_computed.get<bool>();
}

absl::StatusOr<bool>
JsOptionalMemberExpression::GetOptional(const nlohmann::json& json) {
  auto optional_it = json.find("optional");
  if (optional_it == json.end()) {
    return absl::InvalidArgumentError("`optional` is undefined.");
  }
  const nlohmann::json& json_optional = optional_it.value();

  if (json_optional.is_null()) {
    return absl::InvalidArgumentError("json_optional is null.");
  }
  if (!json_optional.is_boolean()) {
    return absl::InvalidArgumentError("Expecting json_optional.is_boolean().");
  }
  return json_optional.get<bool>();
}

absl::StatusOr<std::unique_ptr<JsOptionalMemberExpression>>
JsOptionalMemberExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto object, JsOptionalMemberExpression::GetObject(json));
  MALDOCA_ASSIGN_OR_RETURN(auto property, JsOptionalMemberExpression::GetProperty(json));
  MALDOCA_ASSIGN_OR_RETURN(auto computed, JsOptionalMemberExpression::GetComputed(json));
  MALDOCA_ASSIGN_OR_RETURN(auto optional, JsOptionalMemberExpression::GetOptional(json));

  return absl::make_unique<JsOptionalMemberExpression>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(object),
      std::move(property),
      std::move(computed),
      std::move(optional));
}

// =============================================================================
// JsConditionalExpression
// =============================================================================

absl::StatusOr<std::unique_ptr<JsExpression>>
JsConditionalExpression::GetTest(const nlohmann::json& json) {
  auto test_it = json.find("test");
  if (test_it == json.end()) {
    return absl::InvalidArgumentError("`test` is undefined.");
  }
  const nlohmann::json& json_test = test_it.value();

  if (json_test.is_null()) {
    return absl::InvalidArgumentError("json_test is null.");
  }
  return JsExpression::FromJson(json_test);
}

absl::StatusOr<std::unique_ptr<JsExpression>>
JsConditionalExpression::GetAlternate(const nlohmann::json& json) {
  auto alternate_it = json.find("alternate");
  if (alternate_it == json.end()) {
    return absl::InvalidArgumentError("`alternate` is undefined.");
  }
  const nlohmann::json& json_alternate = alternate_it.value();

  if (json_alternate.is_null()) {
    return absl::InvalidArgumentError("json_alternate is null.");
  }
  return JsExpression::FromJson(json_alternate);
}

absl::StatusOr<std::unique_ptr<JsExpression>>
JsConditionalExpression::GetConsequent(const nlohmann::json& json) {
  auto consequent_it = json.find("consequent");
  if (consequent_it == json.end()) {
    return absl::InvalidArgumentError("`consequent` is undefined.");
  }
  const nlohmann::json& json_consequent = consequent_it.value();

  if (json_consequent.is_null()) {
    return absl::InvalidArgumentError("json_consequent is null.");
  }
  return JsExpression::FromJson(json_consequent);
}

absl::StatusOr<std::unique_ptr<JsConditionalExpression>>
JsConditionalExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto test, JsConditionalExpression::GetTest(json));
  MALDOCA_ASSIGN_OR_RETURN(auto alternate, JsConditionalExpression::GetAlternate(json));
  MALDOCA_ASSIGN_OR_RETURN(auto consequent, JsConditionalExpression::GetConsequent(json));

  return absl::make_unique<JsConditionalExpression>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(test),
      std::move(alternate),
      std::move(consequent));
}

// =============================================================================
// JsCallExpression
// =============================================================================

absl::StatusOr<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSuper>, std::unique_ptr<JsImport>>>
JsCallExpression::GetCallee(const nlohmann::json& json) {
  auto callee_it = json.find("callee");
  if (callee_it == json.end()) {
    return absl::InvalidArgumentError("`callee` is undefined.");
  }
  const nlohmann::json& json_callee = callee_it.value();

  if (json_callee.is_null()) {
    return absl::InvalidArgumentError("json_callee is null.");
  }
  if (IsExpression(json_callee)) {
    return JsExpression::FromJson(json_callee);
  } else if (IsSuper(json_callee)) {
    return JsSuper::FromJson(json_callee);
  } else if (IsImport(json_callee)) {
    return JsImport::FromJson(json_callee);
  } else {
    auto result = absl::InvalidArgumentError("json_callee has invalid type.");
    result.SetPayload("json", absl::Cord{json.dump()});
    result.SetPayload("json_element", absl::Cord{json_callee.dump()});
    return result;
  }
}

absl::StatusOr<std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>>>
JsCallExpression::GetArguments(const nlohmann::json& json) {
  auto arguments_it = json.find("arguments");
  if (arguments_it == json.end()) {
    return absl::InvalidArgumentError("`arguments` is undefined.");
  }
  const nlohmann::json& json_arguments = arguments_it.value();

  if (json_arguments.is_null()) {
    return absl::InvalidArgumentError("json_arguments is null.");
  }
  if (!json_arguments.is_array()) {
    return absl::InvalidArgumentError("json_arguments expected to be array.");
  }

  std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>> arguments;
  for (const nlohmann::json& json_arguments_element : json_arguments) {
    if (json_arguments_element.is_null()) {
      return absl::InvalidArgumentError("json_arguments_element is null.");
    }
    std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>> arguments_element;
    if (IsExpression(json_arguments_element)) {
      MALDOCA_ASSIGN_OR_RETURN(arguments_element, JsExpression::FromJson(json_arguments_element));
    } else if (IsSpreadElement(json_arguments_element)) {
      MALDOCA_ASSIGN_OR_RETURN(arguments_element, JsSpreadElement::FromJson(json_arguments_element));
    } else {
      auto result = absl::InvalidArgumentError("json_arguments_element has invalid type.");
      result.SetPayload("json", absl::Cord{json.dump()});
      result.SetPayload("json_element", absl::Cord{json_arguments_element.dump()});
      return result;
    }
    arguments.push_back(std::move(arguments_element));
  }
  return arguments;
}

absl::StatusOr<std::unique_ptr<JsCallExpression>>
JsCallExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto callee, JsCallExpression::GetCallee(json));
  MALDOCA_ASSIGN_OR_RETURN(auto arguments, JsCallExpression::GetArguments(json));

  return absl::make_unique<JsCallExpression>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(callee),
      std::move(arguments));
}

// =============================================================================
// JsOptionalCallExpression
// =============================================================================

absl::StatusOr<std::unique_ptr<JsExpression>>
JsOptionalCallExpression::GetCallee(const nlohmann::json& json) {
  auto callee_it = json.find("callee");
  if (callee_it == json.end()) {
    return absl::InvalidArgumentError("`callee` is undefined.");
  }
  const nlohmann::json& json_callee = callee_it.value();

  if (json_callee.is_null()) {
    return absl::InvalidArgumentError("json_callee is null.");
  }
  return JsExpression::FromJson(json_callee);
}

absl::StatusOr<std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>>>
JsOptionalCallExpression::GetArguments(const nlohmann::json& json) {
  auto arguments_it = json.find("arguments");
  if (arguments_it == json.end()) {
    return absl::InvalidArgumentError("`arguments` is undefined.");
  }
  const nlohmann::json& json_arguments = arguments_it.value();

  if (json_arguments.is_null()) {
    return absl::InvalidArgumentError("json_arguments is null.");
  }
  if (!json_arguments.is_array()) {
    return absl::InvalidArgumentError("json_arguments expected to be array.");
  }

  std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>> arguments;
  for (const nlohmann::json& json_arguments_element : json_arguments) {
    if (json_arguments_element.is_null()) {
      return absl::InvalidArgumentError("json_arguments_element is null.");
    }
    std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>> arguments_element;
    if (IsExpression(json_arguments_element)) {
      MALDOCA_ASSIGN_OR_RETURN(arguments_element, JsExpression::FromJson(json_arguments_element));
    } else if (IsSpreadElement(json_arguments_element)) {
      MALDOCA_ASSIGN_OR_RETURN(arguments_element, JsSpreadElement::FromJson(json_arguments_element));
    } else {
      auto result = absl::InvalidArgumentError("json_arguments_element has invalid type.");
      result.SetPayload("json", absl::Cord{json.dump()});
      result.SetPayload("json_element", absl::Cord{json_arguments_element.dump()});
      return result;
    }
    arguments.push_back(std::move(arguments_element));
  }
  return arguments;
}

absl::StatusOr<bool>
JsOptionalCallExpression::GetOptional(const nlohmann::json& json) {
  auto optional_it = json.find("optional");
  if (optional_it == json.end()) {
    return absl::InvalidArgumentError("`optional` is undefined.");
  }
  const nlohmann::json& json_optional = optional_it.value();

  if (json_optional.is_null()) {
    return absl::InvalidArgumentError("json_optional is null.");
  }
  if (!json_optional.is_boolean()) {
    return absl::InvalidArgumentError("Expecting json_optional.is_boolean().");
  }
  return json_optional.get<bool>();
}

absl::StatusOr<std::unique_ptr<JsOptionalCallExpression>>
JsOptionalCallExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto callee, JsOptionalCallExpression::GetCallee(json));
  MALDOCA_ASSIGN_OR_RETURN(auto arguments, JsOptionalCallExpression::GetArguments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto optional, JsOptionalCallExpression::GetOptional(json));

  return absl::make_unique<JsOptionalCallExpression>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(callee),
      std::move(arguments),
      std::move(optional));
}

// =============================================================================
// JsNewExpression
// =============================================================================

absl::StatusOr<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSuper>, std::unique_ptr<JsImport>>>
JsNewExpression::GetCallee(const nlohmann::json& json) {
  auto callee_it = json.find("callee");
  if (callee_it == json.end()) {
    return absl::InvalidArgumentError("`callee` is undefined.");
  }
  const nlohmann::json& json_callee = callee_it.value();

  if (json_callee.is_null()) {
    return absl::InvalidArgumentError("json_callee is null.");
  }
  if (IsExpression(json_callee)) {
    return JsExpression::FromJson(json_callee);
  } else if (IsSuper(json_callee)) {
    return JsSuper::FromJson(json_callee);
  } else if (IsImport(json_callee)) {
    return JsImport::FromJson(json_callee);
  } else {
    auto result = absl::InvalidArgumentError("json_callee has invalid type.");
    result.SetPayload("json", absl::Cord{json.dump()});
    result.SetPayload("json_element", absl::Cord{json_callee.dump()});
    return result;
  }
}

absl::StatusOr<std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>>>
JsNewExpression::GetArguments(const nlohmann::json& json) {
  auto arguments_it = json.find("arguments");
  if (arguments_it == json.end()) {
    return absl::InvalidArgumentError("`arguments` is undefined.");
  }
  const nlohmann::json& json_arguments = arguments_it.value();

  if (json_arguments.is_null()) {
    return absl::InvalidArgumentError("json_arguments is null.");
  }
  if (!json_arguments.is_array()) {
    return absl::InvalidArgumentError("json_arguments expected to be array.");
  }

  std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>> arguments;
  for (const nlohmann::json& json_arguments_element : json_arguments) {
    if (json_arguments_element.is_null()) {
      return absl::InvalidArgumentError("json_arguments_element is null.");
    }
    std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>> arguments_element;
    if (IsExpression(json_arguments_element)) {
      MALDOCA_ASSIGN_OR_RETURN(arguments_element, JsExpression::FromJson(json_arguments_element));
    } else if (IsSpreadElement(json_arguments_element)) {
      MALDOCA_ASSIGN_OR_RETURN(arguments_element, JsSpreadElement::FromJson(json_arguments_element));
    } else {
      auto result = absl::InvalidArgumentError("json_arguments_element has invalid type.");
      result.SetPayload("json", absl::Cord{json.dump()});
      result.SetPayload("json_element", absl::Cord{json_arguments_element.dump()});
      return result;
    }
    arguments.push_back(std::move(arguments_element));
  }
  return arguments;
}

absl::StatusOr<std::unique_ptr<JsNewExpression>>
JsNewExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto callee, JsNewExpression::GetCallee(json));
  MALDOCA_ASSIGN_OR_RETURN(auto arguments, JsNewExpression::GetArguments(json));

  return absl::make_unique<JsNewExpression>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(callee),
      std::move(arguments));
}

// =============================================================================
// JsSequenceExpression
// =============================================================================

absl::StatusOr<std::vector<std::unique_ptr<JsExpression>>>
JsSequenceExpression::GetExpressions(const nlohmann::json& json) {
  auto expressions_it = json.find("expressions");
  if (expressions_it == json.end()) {
    return absl::InvalidArgumentError("`expressions` is undefined.");
  }
  const nlohmann::json& json_expressions = expressions_it.value();

  if (json_expressions.is_null()) {
    return absl::InvalidArgumentError("json_expressions is null.");
  }
  if (!json_expressions.is_array()) {
    return absl::InvalidArgumentError("json_expressions expected to be array.");
  }

  std::vector<std::unique_ptr<JsExpression>> expressions;
  for (const nlohmann::json& json_expressions_element : json_expressions) {
    if (json_expressions_element.is_null()) {
      return absl::InvalidArgumentError("json_expressions_element is null.");
    }
    MALDOCA_ASSIGN_OR_RETURN(auto expressions_element, JsExpression::FromJson(json_expressions_element));
    expressions.push_back(std::move(expressions_element));
  }
  return expressions;
}

absl::StatusOr<std::unique_ptr<JsSequenceExpression>>
JsSequenceExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto expressions, JsSequenceExpression::GetExpressions(json));

  return absl::make_unique<JsSequenceExpression>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(expressions));
}

// =============================================================================
// JsParenthesizedExpression
// =============================================================================

absl::StatusOr<std::unique_ptr<JsExpression>>
JsParenthesizedExpression::GetExpression(const nlohmann::json& json) {
  auto expression_it = json.find("expression");
  if (expression_it == json.end()) {
    return absl::InvalidArgumentError("`expression` is undefined.");
  }
  const nlohmann::json& json_expression = expression_it.value();

  if (json_expression.is_null()) {
    return absl::InvalidArgumentError("json_expression is null.");
  }
  return JsExpression::FromJson(json_expression);
}

absl::StatusOr<std::unique_ptr<JsParenthesizedExpression>>
JsParenthesizedExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto expression, JsParenthesizedExpression::GetExpression(json));

  return absl::make_unique<JsParenthesizedExpression>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(expression));
}

// =============================================================================
// JsTemplateElementValue
// =============================================================================

absl::StatusOr<std::optional<std::string>>
JsTemplateElementValue::GetCooked(const nlohmann::json& json) {
  auto cooked_it = json.find("cooked");
  if (cooked_it == json.end()) {
    return absl::InvalidArgumentError("`cooked` is undefined.");
  }
  const nlohmann::json& json_cooked = cooked_it.value();

  if (json_cooked.is_null()) {
    return std::nullopt;
  }
  if (!json_cooked.is_string()) {
    return absl::InvalidArgumentError("Expecting json_cooked.is_string().");
  }
  return json_cooked.get<std::string>();
}

absl::StatusOr<std::string>
JsTemplateElementValue::GetRaw(const nlohmann::json& json) {
  auto raw_it = json.find("raw");
  if (raw_it == json.end()) {
    return absl::InvalidArgumentError("`raw` is undefined.");
  }
  const nlohmann::json& json_raw = raw_it.value();

  if (json_raw.is_null()) {
    return absl::InvalidArgumentError("json_raw is null.");
  }
  if (!json_raw.is_string()) {
    return absl::InvalidArgumentError("Expecting json_raw.is_string().");
  }
  return json_raw.get<std::string>();
}

absl::StatusOr<std::unique_ptr<JsTemplateElementValue>>
JsTemplateElementValue::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto cooked, JsTemplateElementValue::GetCooked(json));
  MALDOCA_ASSIGN_OR_RETURN(auto raw, JsTemplateElementValue::GetRaw(json));

  return absl::make_unique<JsTemplateElementValue>(
      std::move(cooked),
      std::move(raw));
}

// =============================================================================
// JsTemplateElement
// =============================================================================

absl::StatusOr<bool>
JsTemplateElement::GetTail(const nlohmann::json& json) {
  auto tail_it = json.find("tail");
  if (tail_it == json.end()) {
    return absl::InvalidArgumentError("`tail` is undefined.");
  }
  const nlohmann::json& json_tail = tail_it.value();

  if (json_tail.is_null()) {
    return absl::InvalidArgumentError("json_tail is null.");
  }
  if (!json_tail.is_boolean()) {
    return absl::InvalidArgumentError("Expecting json_tail.is_boolean().");
  }
  return json_tail.get<bool>();
}

absl::StatusOr<std::unique_ptr<JsTemplateElementValue>>
JsTemplateElement::GetValue(const nlohmann::json& json) {
  auto value_it = json.find("value");
  if (value_it == json.end()) {
    return absl::InvalidArgumentError("`value` is undefined.");
  }
  const nlohmann::json& json_value = value_it.value();

  if (json_value.is_null()) {
    return absl::InvalidArgumentError("json_value is null.");
  }
  return JsTemplateElementValue::FromJson(json_value);
}

absl::StatusOr<std::unique_ptr<JsTemplateElement>>
JsTemplateElement::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto tail, JsTemplateElement::GetTail(json));
  MALDOCA_ASSIGN_OR_RETURN(auto value, JsTemplateElement::GetValue(json));

  return absl::make_unique<JsTemplateElement>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(tail),
      std::move(value));
}

// =============================================================================
// JsTemplateLiteral
// =============================================================================

absl::StatusOr<std::vector<std::unique_ptr<JsTemplateElement>>>
JsTemplateLiteral::GetQuasis(const nlohmann::json& json) {
  auto quasis_it = json.find("quasis");
  if (quasis_it == json.end()) {
    return absl::InvalidArgumentError("`quasis` is undefined.");
  }
  const nlohmann::json& json_quasis = quasis_it.value();

  if (json_quasis.is_null()) {
    return absl::InvalidArgumentError("json_quasis is null.");
  }
  if (!json_quasis.is_array()) {
    return absl::InvalidArgumentError("json_quasis expected to be array.");
  }

  std::vector<std::unique_ptr<JsTemplateElement>> quasis;
  for (const nlohmann::json& json_quasis_element : json_quasis) {
    if (json_quasis_element.is_null()) {
      return absl::InvalidArgumentError("json_quasis_element is null.");
    }
    MALDOCA_ASSIGN_OR_RETURN(auto quasis_element, JsTemplateElement::FromJson(json_quasis_element));
    quasis.push_back(std::move(quasis_element));
  }
  return quasis;
}

absl::StatusOr<std::vector<std::unique_ptr<JsExpression>>>
JsTemplateLiteral::GetExpressions(const nlohmann::json& json) {
  auto expressions_it = json.find("expressions");
  if (expressions_it == json.end()) {
    return absl::InvalidArgumentError("`expressions` is undefined.");
  }
  const nlohmann::json& json_expressions = expressions_it.value();

  if (json_expressions.is_null()) {
    return absl::InvalidArgumentError("json_expressions is null.");
  }
  if (!json_expressions.is_array()) {
    return absl::InvalidArgumentError("json_expressions expected to be array.");
  }

  std::vector<std::unique_ptr<JsExpression>> expressions;
  for (const nlohmann::json& json_expressions_element : json_expressions) {
    if (json_expressions_element.is_null()) {
      return absl::InvalidArgumentError("json_expressions_element is null.");
    }
    MALDOCA_ASSIGN_OR_RETURN(auto expressions_element, JsExpression::FromJson(json_expressions_element));
    expressions.push_back(std::move(expressions_element));
  }
  return expressions;
}

absl::StatusOr<std::unique_ptr<JsTemplateLiteral>>
JsTemplateLiteral::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto quasis, JsTemplateLiteral::GetQuasis(json));
  MALDOCA_ASSIGN_OR_RETURN(auto expressions, JsTemplateLiteral::GetExpressions(json));

  return absl::make_unique<JsTemplateLiteral>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(quasis),
      std::move(expressions));
}

// =============================================================================
// JsTaggedTemplateExpression
// =============================================================================

absl::StatusOr<std::unique_ptr<JsExpression>>
JsTaggedTemplateExpression::GetTag(const nlohmann::json& json) {
  auto tag_it = json.find("tag");
  if (tag_it == json.end()) {
    return absl::InvalidArgumentError("`tag` is undefined.");
  }
  const nlohmann::json& json_tag = tag_it.value();

  if (json_tag.is_null()) {
    return absl::InvalidArgumentError("json_tag is null.");
  }
  return JsExpression::FromJson(json_tag);
}

absl::StatusOr<std::unique_ptr<JsTemplateLiteral>>
JsTaggedTemplateExpression::GetQuasi(const nlohmann::json& json) {
  auto quasi_it = json.find("quasi");
  if (quasi_it == json.end()) {
    return absl::InvalidArgumentError("`quasi` is undefined.");
  }
  const nlohmann::json& json_quasi = quasi_it.value();

  if (json_quasi.is_null()) {
    return absl::InvalidArgumentError("json_quasi is null.");
  }
  return JsTemplateLiteral::FromJson(json_quasi);
}

absl::StatusOr<std::unique_ptr<JsTaggedTemplateExpression>>
JsTaggedTemplateExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto tag, JsTaggedTemplateExpression::GetTag(json));
  MALDOCA_ASSIGN_OR_RETURN(auto quasi, JsTaggedTemplateExpression::GetQuasi(json));

  return absl::make_unique<JsTaggedTemplateExpression>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(tag),
      std::move(quasi));
}

// =============================================================================
// JsRestElement
// =============================================================================

static bool IsRestElement(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  return type == "RestElement";
}

absl::StatusOr<std::unique_ptr<JsLVal>>
JsRestElement::GetArgument(const nlohmann::json& json) {
  auto argument_it = json.find("argument");
  if (argument_it == json.end()) {
    return absl::InvalidArgumentError("`argument` is undefined.");
  }
  const nlohmann::json& json_argument = argument_it.value();

  if (json_argument.is_null()) {
    return absl::InvalidArgumentError("json_argument is null.");
  }
  return JsLVal::FromJson(json_argument);
}

absl::StatusOr<std::unique_ptr<JsRestElement>>
JsRestElement::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto argument, JsRestElement::GetArgument(json));

  return absl::make_unique<JsRestElement>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(argument));
}

// =============================================================================
// JsObjectPattern
// =============================================================================

absl::StatusOr<std::vector<std::variant<std::unique_ptr<JsObjectProperty>, std::unique_ptr<JsRestElement>>>>
JsObjectPattern::GetProperties(const nlohmann::json& json) {
  auto properties_it = json.find("properties");
  if (properties_it == json.end()) {
    return absl::InvalidArgumentError("`properties` is undefined.");
  }
  const nlohmann::json& json_properties = properties_it.value();

  if (json_properties.is_null()) {
    return absl::InvalidArgumentError("json_properties is null.");
  }
  if (!json_properties.is_array()) {
    return absl::InvalidArgumentError("json_properties expected to be array.");
  }

  std::vector<std::variant<std::unique_ptr<JsObjectProperty>, std::unique_ptr<JsRestElement>>> properties_;
  for (const nlohmann::json& json_properties_element : json_properties) {
    if (json_properties_element.is_null()) {
      return absl::InvalidArgumentError("json_properties_element is null.");
    }
    std::variant<std::unique_ptr<JsObjectProperty>, std::unique_ptr<JsRestElement>> properties_element;
    if (IsObjectProperty(json_properties_element)) {
      MALDOCA_ASSIGN_OR_RETURN(properties_element, JsObjectProperty::FromJson(json_properties_element));
    } else if (IsRestElement(json_properties_element)) {
      MALDOCA_ASSIGN_OR_RETURN(properties_element, JsRestElement::FromJson(json_properties_element));
    } else {
      auto result = absl::InvalidArgumentError("json_properties_element has invalid type.");
      result.SetPayload("json", absl::Cord{json.dump()});
      result.SetPayload("json_element", absl::Cord{json_properties_element.dump()});
      return result;
    }
    properties_.push_back(std::move(properties_element));
  }
  return properties_;
}

absl::StatusOr<std::unique_ptr<JsObjectPattern>>
JsObjectPattern::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto properties_, JsObjectPattern::GetProperties(json));

  return absl::make_unique<JsObjectPattern>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(properties_));
}

// =============================================================================
// JsArrayPattern
// =============================================================================

absl::StatusOr<std::vector<std::optional<std::unique_ptr<JsPattern>>>>
JsArrayPattern::GetElements(const nlohmann::json& json) {
  auto elements_it = json.find("elements");
  if (elements_it == json.end()) {
    return absl::InvalidArgumentError("`elements` is undefined.");
  }
  const nlohmann::json& json_elements = elements_it.value();

  if (json_elements.is_null()) {
    return absl::InvalidArgumentError("json_elements is null.");
  }
  if (!json_elements.is_array()) {
    return absl::InvalidArgumentError("json_elements expected to be array.");
  }

  std::vector<std::optional<std::unique_ptr<JsPattern>>> elements;
  for (const nlohmann::json& json_elements_element : json_elements) {
    std::optional<std::unique_ptr<JsPattern>> elements_element;
    if (!json_elements_element.is_null()) {
      MALDOCA_ASSIGN_OR_RETURN(elements_element, JsPattern::FromJson(json_elements_element));
    }
    elements.push_back(std::move(elements_element));
  }
  return elements;
}

absl::StatusOr<std::unique_ptr<JsArrayPattern>>
JsArrayPattern::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto elements, JsArrayPattern::GetElements(json));

  return absl::make_unique<JsArrayPattern>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(elements));
}

// =============================================================================
// JsAssignmentPattern
// =============================================================================

absl::StatusOr<std::unique_ptr<JsPattern>>
JsAssignmentPattern::GetLeft(const nlohmann::json& json) {
  auto left_it = json.find("left");
  if (left_it == json.end()) {
    return absl::InvalidArgumentError("`left` is undefined.");
  }
  const nlohmann::json& json_left = left_it.value();

  if (json_left.is_null()) {
    return absl::InvalidArgumentError("json_left is null.");
  }
  return JsPattern::FromJson(json_left);
}

absl::StatusOr<std::unique_ptr<JsExpression>>
JsAssignmentPattern::GetRight(const nlohmann::json& json) {
  auto right_it = json.find("right");
  if (right_it == json.end()) {
    return absl::InvalidArgumentError("`right` is undefined.");
  }
  const nlohmann::json& json_right = right_it.value();

  if (json_right.is_null()) {
    return absl::InvalidArgumentError("json_right is null.");
  }
  return JsExpression::FromJson(json_right);
}

absl::StatusOr<std::unique_ptr<JsAssignmentPattern>>
JsAssignmentPattern::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto left, JsAssignmentPattern::GetLeft(json));
  MALDOCA_ASSIGN_OR_RETURN(auto right, JsAssignmentPattern::GetRight(json));

  return absl::make_unique<JsAssignmentPattern>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(left),
      std::move(right));
}

// =============================================================================
// JsClassMethod
// =============================================================================

static bool IsClassMethod(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  return type == "ClassMethod";
}

absl::StatusOr<std::unique_ptr<JsExpression>>
JsClassMethod::GetKey(const nlohmann::json& json) {
  auto key_it = json.find("key");
  if (key_it == json.end()) {
    return absl::InvalidArgumentError("`key` is undefined.");
  }
  const nlohmann::json& json_key = key_it.value();

  if (json_key.is_null()) {
    return absl::InvalidArgumentError("json_key is null.");
  }
  return JsExpression::FromJson(json_key);
}

absl::StatusOr<std::string>
JsClassMethod::GetKind(const nlohmann::json& json) {
  auto kind_it = json.find("kind");
  if (kind_it == json.end()) {
    return absl::InvalidArgumentError("`kind` is undefined.");
  }
  const nlohmann::json& json_kind = kind_it.value();

  if (json_kind.is_null()) {
    return absl::InvalidArgumentError("json_kind is null.");
  }
  if (!json_kind.is_string()) {
    return absl::InvalidArgumentError("Expecting json_kind.is_string().");
  }
  return json_kind.get<std::string>();
}

absl::StatusOr<bool>
JsClassMethod::GetComputed(const nlohmann::json& json) {
  auto computed_it = json.find("computed");
  if (computed_it == json.end()) {
    return absl::InvalidArgumentError("`computed` is undefined.");
  }
  const nlohmann::json& json_computed = computed_it.value();

  if (json_computed.is_null()) {
    return absl::InvalidArgumentError("json_computed is null.");
  }
  if (!json_computed.is_boolean()) {
    return absl::InvalidArgumentError("Expecting json_computed.is_boolean().");
  }
  return json_computed.get<bool>();
}

absl::StatusOr<bool>
JsClassMethod::GetStatic(const nlohmann::json& json) {
  auto static_it = json.find("static");
  if (static_it == json.end()) {
    return absl::InvalidArgumentError("`static` is undefined.");
  }
  const nlohmann::json& json_static = static_it.value();

  if (json_static.is_null()) {
    return absl::InvalidArgumentError("json_static is null.");
  }
  if (!json_static.is_boolean()) {
    return absl::InvalidArgumentError("Expecting json_static.is_boolean().");
  }
  return json_static.get<bool>();
}

absl::StatusOr<std::unique_ptr<JsClassMethod>>
JsClassMethod::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto id, JsFunction::GetId(json));
  MALDOCA_ASSIGN_OR_RETURN(auto params, JsFunction::GetParams(json));
  MALDOCA_ASSIGN_OR_RETURN(auto generator, JsFunction::GetGenerator(json));
  MALDOCA_ASSIGN_OR_RETURN(auto async, JsFunction::GetAsync(json));
  MALDOCA_ASSIGN_OR_RETURN(auto body, JsBlockStatementFunction::GetBody(json));
  MALDOCA_ASSIGN_OR_RETURN(auto key, JsClassMethod::GetKey(json));
  MALDOCA_ASSIGN_OR_RETURN(auto kind, JsClassMethod::GetKind(json));
  MALDOCA_ASSIGN_OR_RETURN(auto computed, JsClassMethod::GetComputed(json));
  MALDOCA_ASSIGN_OR_RETURN(auto static_, JsClassMethod::GetStatic(json));

  return absl::make_unique<JsClassMethod>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(id),
      std::move(params),
      std::move(generator),
      std::move(async),
      std::move(body),
      std::move(key),
      std::move(kind),
      std::move(computed),
      std::move(static_));
}

// =============================================================================
// JsClassPrivateMethod
// =============================================================================

static bool IsClassPrivateMethod(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  return type == "ClassPrivateMethod";
}

absl::StatusOr<std::unique_ptr<JsPrivateName>>
JsClassPrivateMethod::GetKey(const nlohmann::json& json) {
  auto key_it = json.find("key");
  if (key_it == json.end()) {
    return absl::InvalidArgumentError("`key` is undefined.");
  }
  const nlohmann::json& json_key = key_it.value();

  if (json_key.is_null()) {
    return absl::InvalidArgumentError("json_key is null.");
  }
  return JsPrivateName::FromJson(json_key);
}

absl::StatusOr<std::string>
JsClassPrivateMethod::GetKind(const nlohmann::json& json) {
  auto kind_it = json.find("kind");
  if (kind_it == json.end()) {
    return absl::InvalidArgumentError("`kind` is undefined.");
  }
  const nlohmann::json& json_kind = kind_it.value();

  if (json_kind.is_null()) {
    return absl::InvalidArgumentError("json_kind is null.");
  }
  if (!json_kind.is_string()) {
    return absl::InvalidArgumentError("Expecting json_kind.is_string().");
  }
  return json_kind.get<std::string>();
}

absl::StatusOr<bool>
JsClassPrivateMethod::GetStatic(const nlohmann::json& json) {
  auto static_it = json.find("static");
  if (static_it == json.end()) {
    return absl::InvalidArgumentError("`static` is undefined.");
  }
  const nlohmann::json& json_static = static_it.value();

  if (json_static.is_null()) {
    return absl::InvalidArgumentError("json_static is null.");
  }
  if (!json_static.is_boolean()) {
    return absl::InvalidArgumentError("Expecting json_static.is_boolean().");
  }
  return json_static.get<bool>();
}

absl::StatusOr<std::optional<bool>>
JsClassPrivateMethod::GetComputed(const nlohmann::json& json) {
  auto computed_it = json.find("computed");
  if (computed_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_computed = computed_it.value();

  if (json_computed.is_null()) {
    return absl::InvalidArgumentError("json_computed is null.");
  }
  if (!json_computed.is_boolean()) {
    return absl::InvalidArgumentError("Expecting json_computed.is_boolean().");
  }
  return json_computed.get<bool>();
}

absl::StatusOr<std::unique_ptr<JsClassPrivateMethod>>
JsClassPrivateMethod::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto id, JsFunction::GetId(json));
  MALDOCA_ASSIGN_OR_RETURN(auto params, JsFunction::GetParams(json));
  MALDOCA_ASSIGN_OR_RETURN(auto generator, JsFunction::GetGenerator(json));
  MALDOCA_ASSIGN_OR_RETURN(auto async, JsFunction::GetAsync(json));
  MALDOCA_ASSIGN_OR_RETURN(auto body, JsBlockStatementFunction::GetBody(json));
  MALDOCA_ASSIGN_OR_RETURN(auto key, JsClassPrivateMethod::GetKey(json));
  MALDOCA_ASSIGN_OR_RETURN(auto kind, JsClassPrivateMethod::GetKind(json));
  MALDOCA_ASSIGN_OR_RETURN(auto static_, JsClassPrivateMethod::GetStatic(json));
  MALDOCA_ASSIGN_OR_RETURN(auto computed, JsClassPrivateMethod::GetComputed(json));

  return absl::make_unique<JsClassPrivateMethod>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(id),
      std::move(params),
      std::move(generator),
      std::move(async),
      std::move(body),
      std::move(key),
      std::move(kind),
      std::move(static_),
      std::move(computed));
}

// =============================================================================
// JsClassProperty
// =============================================================================

static bool IsClassProperty(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  return type == "ClassProperty";
}

absl::StatusOr<std::unique_ptr<JsExpression>>
JsClassProperty::GetKey(const nlohmann::json& json) {
  auto key_it = json.find("key");
  if (key_it == json.end()) {
    return absl::InvalidArgumentError("`key` is undefined.");
  }
  const nlohmann::json& json_key = key_it.value();

  if (json_key.is_null()) {
    return absl::InvalidArgumentError("json_key is null.");
  }
  return JsExpression::FromJson(json_key);
}

absl::StatusOr<std::optional<std::unique_ptr<JsExpression>>>
JsClassProperty::GetValue(const nlohmann::json& json) {
  auto value_it = json.find("value");
  if (value_it == json.end()) {
    return absl::InvalidArgumentError("`value` is undefined.");
  }
  const nlohmann::json& json_value = value_it.value();

  if (json_value.is_null()) {
    return std::nullopt;
  }
  return JsExpression::FromJson(json_value);
}

absl::StatusOr<bool>
JsClassProperty::GetStatic(const nlohmann::json& json) {
  auto static_it = json.find("static");
  if (static_it == json.end()) {
    return absl::InvalidArgumentError("`static` is undefined.");
  }
  const nlohmann::json& json_static = static_it.value();

  if (json_static.is_null()) {
    return absl::InvalidArgumentError("json_static is null.");
  }
  if (!json_static.is_boolean()) {
    return absl::InvalidArgumentError("Expecting json_static.is_boolean().");
  }
  return json_static.get<bool>();
}

absl::StatusOr<bool>
JsClassProperty::GetComputed(const nlohmann::json& json) {
  auto computed_it = json.find("computed");
  if (computed_it == json.end()) {
    return absl::InvalidArgumentError("`computed` is undefined.");
  }
  const nlohmann::json& json_computed = computed_it.value();

  if (json_computed.is_null()) {
    return absl::InvalidArgumentError("json_computed is null.");
  }
  if (!json_computed.is_boolean()) {
    return absl::InvalidArgumentError("Expecting json_computed.is_boolean().");
  }
  return json_computed.get<bool>();
}

absl::StatusOr<std::unique_ptr<JsClassProperty>>
JsClassProperty::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto key, JsClassProperty::GetKey(json));
  MALDOCA_ASSIGN_OR_RETURN(auto value, JsClassProperty::GetValue(json));
  MALDOCA_ASSIGN_OR_RETURN(auto static_, JsClassProperty::GetStatic(json));
  MALDOCA_ASSIGN_OR_RETURN(auto computed, JsClassProperty::GetComputed(json));

  return absl::make_unique<JsClassProperty>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(key),
      std::move(value),
      std::move(static_),
      std::move(computed));
}

// =============================================================================
// JsClassPrivateProperty
// =============================================================================

static bool IsClassPrivateProperty(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  return type == "ClassPrivateProperty";
}

absl::StatusOr<std::unique_ptr<JsPrivateName>>
JsClassPrivateProperty::GetKey(const nlohmann::json& json) {
  auto key_it = json.find("key");
  if (key_it == json.end()) {
    return absl::InvalidArgumentError("`key` is undefined.");
  }
  const nlohmann::json& json_key = key_it.value();

  if (json_key.is_null()) {
    return absl::InvalidArgumentError("json_key is null.");
  }
  return JsPrivateName::FromJson(json_key);
}

absl::StatusOr<std::optional<std::unique_ptr<JsExpression>>>
JsClassPrivateProperty::GetValue(const nlohmann::json& json) {
  auto value_it = json.find("value");
  if (value_it == json.end()) {
    return absl::InvalidArgumentError("`value` is undefined.");
  }
  const nlohmann::json& json_value = value_it.value();

  if (json_value.is_null()) {
    return std::nullopt;
  }
  return JsExpression::FromJson(json_value);
}

absl::StatusOr<bool>
JsClassPrivateProperty::GetStatic(const nlohmann::json& json) {
  auto static_it = json.find("static");
  if (static_it == json.end()) {
    return absl::InvalidArgumentError("`static` is undefined.");
  }
  const nlohmann::json& json_static = static_it.value();

  if (json_static.is_null()) {
    return absl::InvalidArgumentError("json_static is null.");
  }
  if (!json_static.is_boolean()) {
    return absl::InvalidArgumentError("Expecting json_static.is_boolean().");
  }
  return json_static.get<bool>();
}

absl::StatusOr<std::unique_ptr<JsClassPrivateProperty>>
JsClassPrivateProperty::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto key, JsClassPrivateProperty::GetKey(json));
  MALDOCA_ASSIGN_OR_RETURN(auto value, JsClassPrivateProperty::GetValue(json));
  MALDOCA_ASSIGN_OR_RETURN(auto static_, JsClassPrivateProperty::GetStatic(json));

  return absl::make_unique<JsClassPrivateProperty>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(key),
      std::move(value),
      std::move(static_));
}

// =============================================================================
// JsClassBody
// =============================================================================

absl::StatusOr<std::vector<std::variant<std::unique_ptr<JsClassMethod>, std::unique_ptr<JsClassPrivateMethod>, std::unique_ptr<JsClassProperty>, std::unique_ptr<JsClassPrivateProperty>>>>
JsClassBody::GetBody(const nlohmann::json& json) {
  auto body_it = json.find("body");
  if (body_it == json.end()) {
    return absl::InvalidArgumentError("`body` is undefined.");
  }
  const nlohmann::json& json_body = body_it.value();

  if (json_body.is_null()) {
    return absl::InvalidArgumentError("json_body is null.");
  }
  if (!json_body.is_array()) {
    return absl::InvalidArgumentError("json_body expected to be array.");
  }

  std::vector<std::variant<std::unique_ptr<JsClassMethod>, std::unique_ptr<JsClassPrivateMethod>, std::unique_ptr<JsClassProperty>, std::unique_ptr<JsClassPrivateProperty>>> body;
  for (const nlohmann::json& json_body_element : json_body) {
    if (json_body_element.is_null()) {
      return absl::InvalidArgumentError("json_body_element is null.");
    }
    std::variant<std::unique_ptr<JsClassMethod>, std::unique_ptr<JsClassPrivateMethod>, std::unique_ptr<JsClassProperty>, std::unique_ptr<JsClassPrivateProperty>> body_element;
    if (IsClassMethod(json_body_element)) {
      MALDOCA_ASSIGN_OR_RETURN(body_element, JsClassMethod::FromJson(json_body_element));
    } else if (IsClassPrivateMethod(json_body_element)) {
      MALDOCA_ASSIGN_OR_RETURN(body_element, JsClassPrivateMethod::FromJson(json_body_element));
    } else if (IsClassProperty(json_body_element)) {
      MALDOCA_ASSIGN_OR_RETURN(body_element, JsClassProperty::FromJson(json_body_element));
    } else if (IsClassPrivateProperty(json_body_element)) {
      MALDOCA_ASSIGN_OR_RETURN(body_element, JsClassPrivateProperty::FromJson(json_body_element));
    } else {
      auto result = absl::InvalidArgumentError("json_body_element has invalid type.");
      result.SetPayload("json", absl::Cord{json.dump()});
      result.SetPayload("json_element", absl::Cord{json_body_element.dump()});
      return result;
    }
    body.push_back(std::move(body_element));
  }
  return body;
}

absl::StatusOr<std::unique_ptr<JsClassBody>>
JsClassBody::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto body, JsClassBody::GetBody(json));

  return absl::make_unique<JsClassBody>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(body));
}

// =============================================================================
// JsClass
// =============================================================================

absl::StatusOr<std::optional<std::unique_ptr<JsExpression>>>
JsClass::GetSuperClass(const nlohmann::json& json) {
  auto super_class_it = json.find("superClass");
  if (super_class_it == json.end()) {
    return absl::InvalidArgumentError("`superClass` is undefined.");
  }
  const nlohmann::json& json_super_class = super_class_it.value();

  if (json_super_class.is_null()) {
    return std::nullopt;
  }
  return JsExpression::FromJson(json_super_class);
}

absl::StatusOr<std::unique_ptr<JsClassBody>>
JsClass::GetBody(const nlohmann::json& json) {
  auto body_it = json.find("body");
  if (body_it == json.end()) {
    return absl::InvalidArgumentError("`body` is undefined.");
  }
  const nlohmann::json& json_body = body_it.value();

  if (json_body.is_null()) {
    return absl::InvalidArgumentError("json_body is null.");
  }
  return JsClassBody::FromJson(json_body);
}

absl::StatusOr<std::unique_ptr<JsClass>>
JsClass::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(std::string type, GetType(json));

  if (type == "ClassDeclaration") {
    return JsClassDeclaration::FromJson(json);
  } else if (type == "ClassExpression") {
    return JsClassExpression::FromJson(json);
  }
  return absl::InvalidArgumentError(absl::StrCat("Invalid type: ", type));
}

// =============================================================================
// JsClassDeclaration
// =============================================================================

static bool IsClassDeclaration(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  return type == "ClassDeclaration";
}

absl::StatusOr<std::optional<std::unique_ptr<JsIdentifier>>>
JsClassDeclaration::GetId(const nlohmann::json& json) {
  auto id_it = json.find("id");
  if (id_it == json.end()) {
    return absl::InvalidArgumentError("`id` is undefined.");
  }
  const nlohmann::json& json_id = id_it.value();

  if (json_id.is_null()) {
    return std::nullopt;
  }
  return JsIdentifier::FromJson(json_id);
}

absl::StatusOr<std::unique_ptr<JsClassDeclaration>>
JsClassDeclaration::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto super_class, JsClass::GetSuperClass(json));
  MALDOCA_ASSIGN_OR_RETURN(auto body, JsClass::GetBody(json));
  MALDOCA_ASSIGN_OR_RETURN(auto id, JsClassDeclaration::GetId(json));

  return absl::make_unique<JsClassDeclaration>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(super_class),
      std::move(body),
      std::move(id));
}

// =============================================================================
// JsClassExpression
// =============================================================================

absl::StatusOr<std::optional<std::unique_ptr<JsIdentifier>>>
JsClassExpression::GetId(const nlohmann::json& json) {
  auto id_it = json.find("id");
  if (id_it == json.end()) {
    return absl::InvalidArgumentError("`id` is undefined.");
  }
  const nlohmann::json& json_id = id_it.value();

  if (json_id.is_null()) {
    return std::nullopt;
  }
  return JsIdentifier::FromJson(json_id);
}

absl::StatusOr<std::unique_ptr<JsClassExpression>>
JsClassExpression::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto super_class, JsClass::GetSuperClass(json));
  MALDOCA_ASSIGN_OR_RETURN(auto body, JsClass::GetBody(json));
  MALDOCA_ASSIGN_OR_RETURN(auto id, JsClassExpression::GetId(json));

  return absl::make_unique<JsClassExpression>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(super_class),
      std::move(body),
      std::move(id));
}

// =============================================================================
// JsMetaProperty
// =============================================================================

absl::StatusOr<std::unique_ptr<JsIdentifier>>
JsMetaProperty::GetMeta(const nlohmann::json& json) {
  auto meta_it = json.find("meta");
  if (meta_it == json.end()) {
    return absl::InvalidArgumentError("`meta` is undefined.");
  }
  const nlohmann::json& json_meta = meta_it.value();

  if (json_meta.is_null()) {
    return absl::InvalidArgumentError("json_meta is null.");
  }
  return JsIdentifier::FromJson(json_meta);
}

absl::StatusOr<std::unique_ptr<JsIdentifier>>
JsMetaProperty::GetProperty(const nlohmann::json& json) {
  auto property_it = json.find("property");
  if (property_it == json.end()) {
    return absl::InvalidArgumentError("`property` is undefined.");
  }
  const nlohmann::json& json_property = property_it.value();

  if (json_property.is_null()) {
    return absl::InvalidArgumentError("json_property is null.");
  }
  return JsIdentifier::FromJson(json_property);
}

absl::StatusOr<std::unique_ptr<JsMetaProperty>>
JsMetaProperty::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto meta, JsMetaProperty::GetMeta(json));
  MALDOCA_ASSIGN_OR_RETURN(auto property, JsMetaProperty::GetProperty(json));

  return absl::make_unique<JsMetaProperty>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(meta),
      std::move(property));
}

// =============================================================================
// JsModuleSpecifier
// =============================================================================

absl::StatusOr<std::unique_ptr<JsModuleSpecifier>>
JsModuleSpecifier::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(std::string type, GetType(json));

  if (type == "ImportSpecifier") {
    return JsImportSpecifier::FromJson(json);
  } else if (type == "ImportDefaultSpecifier") {
    return JsImportDefaultSpecifier::FromJson(json);
  } else if (type == "ImportNamespaceSpecifier") {
    return JsImportNamespaceSpecifier::FromJson(json);
  } else if (type == "ExportSpecifier") {
    return JsExportSpecifier::FromJson(json);
  }
  return absl::InvalidArgumentError(absl::StrCat("Invalid type: ", type));
}

// =============================================================================
// JsImportSpecifier
// =============================================================================

static bool IsImportSpecifier(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  return type == "ImportSpecifier";
}

absl::StatusOr<std::variant<std::unique_ptr<JsIdentifier>, std::unique_ptr<JsStringLiteral>>>
JsImportSpecifier::GetImported(const nlohmann::json& json) {
  auto imported_it = json.find("imported");
  if (imported_it == json.end()) {
    return absl::InvalidArgumentError("`imported` is undefined.");
  }
  const nlohmann::json& json_imported = imported_it.value();

  if (json_imported.is_null()) {
    return absl::InvalidArgumentError("json_imported is null.");
  }
  if (IsIdentifier(json_imported)) {
    return JsIdentifier::FromJson(json_imported);
  } else if (IsStringLiteral(json_imported)) {
    return JsStringLiteral::FromJson(json_imported);
  } else {
    auto result = absl::InvalidArgumentError("json_imported has invalid type.");
    result.SetPayload("json", absl::Cord{json.dump()});
    result.SetPayload("json_element", absl::Cord{json_imported.dump()});
    return result;
  }
}

absl::StatusOr<std::unique_ptr<JsIdentifier>>
JsImportSpecifier::GetLocal(const nlohmann::json& json) {
  auto local_it = json.find("local");
  if (local_it == json.end()) {
    return absl::InvalidArgumentError("`local` is undefined.");
  }
  const nlohmann::json& json_local = local_it.value();

  if (json_local.is_null()) {
    return absl::InvalidArgumentError("json_local is null.");
  }
  return JsIdentifier::FromJson(json_local);
}

absl::StatusOr<std::unique_ptr<JsImportSpecifier>>
JsImportSpecifier::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto imported, JsImportSpecifier::GetImported(json));
  MALDOCA_ASSIGN_OR_RETURN(auto local, JsImportSpecifier::GetLocal(json));

  return absl::make_unique<JsImportSpecifier>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(imported),
      std::move(local));
}

// =============================================================================
// JsImportDefaultSpecifier
// =============================================================================

static bool IsImportDefaultSpecifier(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  return type == "ImportDefaultSpecifier";
}

absl::StatusOr<std::unique_ptr<JsIdentifier>>
JsImportDefaultSpecifier::GetLocal(const nlohmann::json& json) {
  auto local_it = json.find("local");
  if (local_it == json.end()) {
    return absl::InvalidArgumentError("`local` is undefined.");
  }
  const nlohmann::json& json_local = local_it.value();

  if (json_local.is_null()) {
    return absl::InvalidArgumentError("json_local is null.");
  }
  return JsIdentifier::FromJson(json_local);
}

absl::StatusOr<std::unique_ptr<JsImportDefaultSpecifier>>
JsImportDefaultSpecifier::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto local, JsImportDefaultSpecifier::GetLocal(json));

  return absl::make_unique<JsImportDefaultSpecifier>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(local));
}

// =============================================================================
// JsImportNamespaceSpecifier
// =============================================================================

static bool IsImportNamespaceSpecifier(const nlohmann::json& json) {
  if (!json.is_object()) {
    return false;
  }
  auto type_it = json.find("type");
  if (type_it == json.end()) {
    return false;
  }
  const nlohmann::json &type_json = type_it.value();
  if (!type_json.is_string()) {
    return false;
  }
  const std::string &type = type_json.get<std::string>();
  return type == "ImportNamespaceSpecifier";
}

absl::StatusOr<std::unique_ptr<JsIdentifier>>
JsImportNamespaceSpecifier::GetLocal(const nlohmann::json& json) {
  auto local_it = json.find("local");
  if (local_it == json.end()) {
    return absl::InvalidArgumentError("`local` is undefined.");
  }
  const nlohmann::json& json_local = local_it.value();

  if (json_local.is_null()) {
    return absl::InvalidArgumentError("json_local is null.");
  }
  return JsIdentifier::FromJson(json_local);
}

absl::StatusOr<std::unique_ptr<JsImportNamespaceSpecifier>>
JsImportNamespaceSpecifier::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto local, JsImportNamespaceSpecifier::GetLocal(json));

  return absl::make_unique<JsImportNamespaceSpecifier>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(local));
}

// =============================================================================
// JsImportAttribute
// =============================================================================

absl::StatusOr<std::unique_ptr<JsIdentifier>>
JsImportAttribute::GetKey(const nlohmann::json& json) {
  auto key_it = json.find("key");
  if (key_it == json.end()) {
    return absl::InvalidArgumentError("`key` is undefined.");
  }
  const nlohmann::json& json_key = key_it.value();

  if (json_key.is_null()) {
    return absl::InvalidArgumentError("json_key is null.");
  }
  return JsIdentifier::FromJson(json_key);
}

absl::StatusOr<std::unique_ptr<JsStringLiteral>>
JsImportAttribute::GetValue(const nlohmann::json& json) {
  auto value_it = json.find("value");
  if (value_it == json.end()) {
    return absl::InvalidArgumentError("`value` is undefined.");
  }
  const nlohmann::json& json_value = value_it.value();

  if (json_value.is_null()) {
    return absl::InvalidArgumentError("json_value is null.");
  }
  return JsStringLiteral::FromJson(json_value);
}

absl::StatusOr<std::unique_ptr<JsImportAttribute>>
JsImportAttribute::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto key, JsImportAttribute::GetKey(json));
  MALDOCA_ASSIGN_OR_RETURN(auto value, JsImportAttribute::GetValue(json));

  return absl::make_unique<JsImportAttribute>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(key),
      std::move(value));
}

// =============================================================================
// JsImportDeclaration
// =============================================================================

absl::StatusOr<std::vector<std::variant<std::unique_ptr<JsImportSpecifier>, std::unique_ptr<JsImportDefaultSpecifier>, std::unique_ptr<JsImportNamespaceSpecifier>>>>
JsImportDeclaration::GetSpecifiers(const nlohmann::json& json) {
  auto specifiers_it = json.find("specifiers");
  if (specifiers_it == json.end()) {
    return absl::InvalidArgumentError("`specifiers` is undefined.");
  }
  const nlohmann::json& json_specifiers = specifiers_it.value();

  if (json_specifiers.is_null()) {
    return absl::InvalidArgumentError("json_specifiers is null.");
  }
  if (!json_specifiers.is_array()) {
    return absl::InvalidArgumentError("json_specifiers expected to be array.");
  }

  std::vector<std::variant<std::unique_ptr<JsImportSpecifier>, std::unique_ptr<JsImportDefaultSpecifier>, std::unique_ptr<JsImportNamespaceSpecifier>>> specifiers;
  for (const nlohmann::json& json_specifiers_element : json_specifiers) {
    if (json_specifiers_element.is_null()) {
      return absl::InvalidArgumentError("json_specifiers_element is null.");
    }
    std::variant<std::unique_ptr<JsImportSpecifier>, std::unique_ptr<JsImportDefaultSpecifier>, std::unique_ptr<JsImportNamespaceSpecifier>> specifiers_element;
    if (IsImportSpecifier(json_specifiers_element)) {
      MALDOCA_ASSIGN_OR_RETURN(specifiers_element, JsImportSpecifier::FromJson(json_specifiers_element));
    } else if (IsImportDefaultSpecifier(json_specifiers_element)) {
      MALDOCA_ASSIGN_OR_RETURN(specifiers_element, JsImportDefaultSpecifier::FromJson(json_specifiers_element));
    } else if (IsImportNamespaceSpecifier(json_specifiers_element)) {
      MALDOCA_ASSIGN_OR_RETURN(specifiers_element, JsImportNamespaceSpecifier::FromJson(json_specifiers_element));
    } else {
      auto result = absl::InvalidArgumentError("json_specifiers_element has invalid type.");
      result.SetPayload("json", absl::Cord{json.dump()});
      result.SetPayload("json_element", absl::Cord{json_specifiers_element.dump()});
      return result;
    }
    specifiers.push_back(std::move(specifiers_element));
  }
  return specifiers;
}

absl::StatusOr<std::unique_ptr<JsStringLiteral>>
JsImportDeclaration::GetSource(const nlohmann::json& json) {
  auto source_it = json.find("source");
  if (source_it == json.end()) {
    return absl::InvalidArgumentError("`source` is undefined.");
  }
  const nlohmann::json& json_source = source_it.value();

  if (json_source.is_null()) {
    return absl::InvalidArgumentError("json_source is null.");
  }
  return JsStringLiteral::FromJson(json_source);
}

absl::StatusOr<std::optional<std::unique_ptr<JsImportAttribute>>>
JsImportDeclaration::GetAssertions(const nlohmann::json& json) {
  auto assertions_it = json.find("assertions");
  if (assertions_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_assertions = assertions_it.value();

  if (json_assertions.is_null()) {
    return absl::InvalidArgumentError("json_assertions is null.");
  }
  return JsImportAttribute::FromJson(json_assertions);
}

absl::StatusOr<std::unique_ptr<JsImportDeclaration>>
JsImportDeclaration::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto specifiers, JsImportDeclaration::GetSpecifiers(json));
  MALDOCA_ASSIGN_OR_RETURN(auto source, JsImportDeclaration::GetSource(json));
  MALDOCA_ASSIGN_OR_RETURN(auto assertions, JsImportDeclaration::GetAssertions(json));

  return absl::make_unique<JsImportDeclaration>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(specifiers),
      std::move(source),
      std::move(assertions));
}

// =============================================================================
// JsExportSpecifier
// =============================================================================

absl::StatusOr<std::variant<std::unique_ptr<JsIdentifier>, std::unique_ptr<JsStringLiteral>>>
JsExportSpecifier::GetExported(const nlohmann::json& json) {
  auto exported_it = json.find("exported");
  if (exported_it == json.end()) {
    return absl::InvalidArgumentError("`exported` is undefined.");
  }
  const nlohmann::json& json_exported = exported_it.value();

  if (json_exported.is_null()) {
    return absl::InvalidArgumentError("json_exported is null.");
  }
  if (IsIdentifier(json_exported)) {
    return JsIdentifier::FromJson(json_exported);
  } else if (IsStringLiteral(json_exported)) {
    return JsStringLiteral::FromJson(json_exported);
  } else {
    auto result = absl::InvalidArgumentError("json_exported has invalid type.");
    result.SetPayload("json", absl::Cord{json.dump()});
    result.SetPayload("json_element", absl::Cord{json_exported.dump()});
    return result;
  }
}

absl::StatusOr<std::optional<std::variant<std::unique_ptr<JsIdentifier>, std::unique_ptr<JsStringLiteral>>>>
JsExportSpecifier::GetLocal(const nlohmann::json& json) {
  auto local_it = json.find("local");
  if (local_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_local = local_it.value();

  if (json_local.is_null()) {
    return absl::InvalidArgumentError("json_local is null.");
  }
  if (IsIdentifier(json_local)) {
    return JsIdentifier::FromJson(json_local);
  } else if (IsStringLiteral(json_local)) {
    return JsStringLiteral::FromJson(json_local);
  } else {
    auto result = absl::InvalidArgumentError("json_local has invalid type.");
    result.SetPayload("json", absl::Cord{json.dump()});
    result.SetPayload("json_element", absl::Cord{json_local.dump()});
    return result;
  }
}

absl::StatusOr<std::unique_ptr<JsExportSpecifier>>
JsExportSpecifier::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto exported, JsExportSpecifier::GetExported(json));
  MALDOCA_ASSIGN_OR_RETURN(auto local, JsExportSpecifier::GetLocal(json));

  return absl::make_unique<JsExportSpecifier>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(exported),
      std::move(local));
}

// =============================================================================
// JsExportNamedDeclaration
// =============================================================================

absl::StatusOr<std::optional<std::unique_ptr<JsDeclaration>>>
JsExportNamedDeclaration::GetDeclaration(const nlohmann::json& json) {
  auto declaration_it = json.find("declaration");
  if (declaration_it == json.end()) {
    return absl::InvalidArgumentError("`declaration` is undefined.");
  }
  const nlohmann::json& json_declaration = declaration_it.value();

  if (json_declaration.is_null()) {
    return std::nullopt;
  }
  return JsDeclaration::FromJson(json_declaration);
}

absl::StatusOr<std::vector<std::unique_ptr<JsExportSpecifier>>>
JsExportNamedDeclaration::GetSpecifiers(const nlohmann::json& json) {
  auto specifiers_it = json.find("specifiers");
  if (specifiers_it == json.end()) {
    return absl::InvalidArgumentError("`specifiers` is undefined.");
  }
  const nlohmann::json& json_specifiers = specifiers_it.value();

  if (json_specifiers.is_null()) {
    return absl::InvalidArgumentError("json_specifiers is null.");
  }
  if (!json_specifiers.is_array()) {
    return absl::InvalidArgumentError("json_specifiers expected to be array.");
  }

  std::vector<std::unique_ptr<JsExportSpecifier>> specifiers;
  for (const nlohmann::json& json_specifiers_element : json_specifiers) {
    if (json_specifiers_element.is_null()) {
      return absl::InvalidArgumentError("json_specifiers_element is null.");
    }
    MALDOCA_ASSIGN_OR_RETURN(auto specifiers_element, JsExportSpecifier::FromJson(json_specifiers_element));
    specifiers.push_back(std::move(specifiers_element));
  }
  return specifiers;
}

absl::StatusOr<std::optional<std::unique_ptr<JsStringLiteral>>>
JsExportNamedDeclaration::GetSource(const nlohmann::json& json) {
  auto source_it = json.find("source");
  if (source_it == json.end()) {
    return absl::InvalidArgumentError("`source` is undefined.");
  }
  const nlohmann::json& json_source = source_it.value();

  if (json_source.is_null()) {
    return std::nullopt;
  }
  return JsStringLiteral::FromJson(json_source);
}

absl::StatusOr<std::optional<std::vector<std::unique_ptr<JsImportAttribute>>>>
JsExportNamedDeclaration::GetAssertions(const nlohmann::json& json) {
  auto assertions_it = json.find("assertions");
  if (assertions_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_assertions = assertions_it.value();

  if (json_assertions.is_null()) {
    return absl::InvalidArgumentError("json_assertions is null.");
  }
  if (!json_assertions.is_array()) {
    return absl::InvalidArgumentError("json_assertions expected to be array.");
  }

  std::vector<std::unique_ptr<JsImportAttribute>> assertions;
  for (const nlohmann::json& json_assertions_element : json_assertions) {
    if (json_assertions_element.is_null()) {
      return absl::InvalidArgumentError("json_assertions_element is null.");
    }
    MALDOCA_ASSIGN_OR_RETURN(auto assertions_element, JsImportAttribute::FromJson(json_assertions_element));
    assertions.push_back(std::move(assertions_element));
  }
  return assertions;
}

absl::StatusOr<std::unique_ptr<JsExportNamedDeclaration>>
JsExportNamedDeclaration::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto declaration, JsExportNamedDeclaration::GetDeclaration(json));
  MALDOCA_ASSIGN_OR_RETURN(auto specifiers, JsExportNamedDeclaration::GetSpecifiers(json));
  MALDOCA_ASSIGN_OR_RETURN(auto source, JsExportNamedDeclaration::GetSource(json));
  MALDOCA_ASSIGN_OR_RETURN(auto assertions, JsExportNamedDeclaration::GetAssertions(json));

  return absl::make_unique<JsExportNamedDeclaration>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(declaration),
      std::move(specifiers),
      std::move(source),
      std::move(assertions));
}

// =============================================================================
// JsExportDefaultDeclaration
// =============================================================================

absl::StatusOr<std::variant<std::unique_ptr<JsFunctionDeclaration>, std::unique_ptr<JsClassDeclaration>, std::unique_ptr<JsExpression>>>
JsExportDefaultDeclaration::GetDeclaration(const nlohmann::json& json) {
  auto declaration_it = json.find("declaration");
  if (declaration_it == json.end()) {
    return absl::InvalidArgumentError("`declaration` is undefined.");
  }
  const nlohmann::json& json_declaration = declaration_it.value();

  if (json_declaration.is_null()) {
    return absl::InvalidArgumentError("json_declaration is null.");
  }
  if (IsFunctionDeclaration(json_declaration)) {
    return JsFunctionDeclaration::FromJson(json_declaration);
  } else if (IsClassDeclaration(json_declaration)) {
    return JsClassDeclaration::FromJson(json_declaration);
  } else if (IsExpression(json_declaration)) {
    return JsExpression::FromJson(json_declaration);
  } else {
    auto result = absl::InvalidArgumentError("json_declaration has invalid type.");
    result.SetPayload("json", absl::Cord{json.dump()});
    result.SetPayload("json_element", absl::Cord{json_declaration.dump()});
    return result;
  }
}

absl::StatusOr<std::unique_ptr<JsExportDefaultDeclaration>>
JsExportDefaultDeclaration::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto declaration, JsExportDefaultDeclaration::GetDeclaration(json));

  return absl::make_unique<JsExportDefaultDeclaration>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(declaration));
}

// =============================================================================
// JsExportAllDeclaration
// =============================================================================

absl::StatusOr<std::unique_ptr<JsStringLiteral>>
JsExportAllDeclaration::GetSource(const nlohmann::json& json) {
  auto source_it = json.find("source");
  if (source_it == json.end()) {
    return absl::InvalidArgumentError("`source` is undefined.");
  }
  const nlohmann::json& json_source = source_it.value();

  if (json_source.is_null()) {
    return absl::InvalidArgumentError("json_source is null.");
  }
  return JsStringLiteral::FromJson(json_source);
}

absl::StatusOr<std::optional<std::vector<std::unique_ptr<JsImportAttribute>>>>
JsExportAllDeclaration::GetAssertions(const nlohmann::json& json) {
  auto assertions_it = json.find("assertions");
  if (assertions_it == json.end()) {
    return std::nullopt;
  }
  const nlohmann::json& json_assertions = assertions_it.value();

  if (json_assertions.is_null()) {
    return absl::InvalidArgumentError("json_assertions is null.");
  }
  if (!json_assertions.is_array()) {
    return absl::InvalidArgumentError("json_assertions expected to be array.");
  }

  std::vector<std::unique_ptr<JsImportAttribute>> assertions;
  for (const nlohmann::json& json_assertions_element : json_assertions) {
    if (json_assertions_element.is_null()) {
      return absl::InvalidArgumentError("json_assertions_element is null.");
    }
    MALDOCA_ASSIGN_OR_RETURN(auto assertions_element, JsImportAttribute::FromJson(json_assertions_element));
    assertions.push_back(std::move(assertions_element));
  }
  return assertions;
}

absl::StatusOr<std::unique_ptr<JsExportAllDeclaration>>
JsExportAllDeclaration::FromJson(const nlohmann::json& json) {
  if (!json.is_object()) {
    return absl::InvalidArgumentError("JSON is not an object.");
  }

  MALDOCA_ASSIGN_OR_RETURN(auto loc, JsNode::GetLoc(json));
  MALDOCA_ASSIGN_OR_RETURN(auto start, JsNode::GetStart(json));
  MALDOCA_ASSIGN_OR_RETURN(auto end, JsNode::GetEnd(json));
  MALDOCA_ASSIGN_OR_RETURN(auto leading_comments, JsNode::GetLeadingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto trailing_comments, JsNode::GetTrailingComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto inner_comments, JsNode::GetInnerComments(json));
  MALDOCA_ASSIGN_OR_RETURN(auto scope_uid, JsNode::GetScopeUid(json));
  MALDOCA_ASSIGN_OR_RETURN(auto referenced_symbol, JsNode::GetReferencedSymbol(json));
  MALDOCA_ASSIGN_OR_RETURN(auto defined_symbols, JsNode::GetDefinedSymbols(json));
  MALDOCA_ASSIGN_OR_RETURN(auto source, JsExportAllDeclaration::GetSource(json));
  MALDOCA_ASSIGN_OR_RETURN(auto assertions, JsExportAllDeclaration::GetAssertions(json));

  return absl::make_unique<JsExportAllDeclaration>(
      std::move(loc),
      std::move(start),
      std::move(end),
      std::move(leading_comments),
      std::move(trailing_comments),
      std::move(inner_comments),
      std::move(scope_uid),
      std::move(referenced_symbol),
      std::move(defined_symbols),
      std::move(source),
      std::move(assertions));
}

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca
