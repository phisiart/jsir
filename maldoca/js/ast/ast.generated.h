// Copyright 2024 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// =============================================================================
// STOP!! DO NOT MODIFY!! THIS FILE IS AUTOMATICALLY GENERATED.
// =============================================================================

#ifndef MALDOCA_JS_AST_AST_GENERATED_H_
#define MALDOCA_JS_AST_AST_GENERATED_H_

// IWYU pragma: begin_keep
// NOLINTBEGIN(whitespace/line_length)
// clang-format off

#include <optional>
#include <string>
#include <variant>
#include <vector>

#include "absl/status/statusor.h"
#include "absl/strings/string_view.h"
#include "nlohmann/json.hpp"

namespace maldoca {

enum class JsUnaryOperator {
  kMinus,
  kPlus,
  kNot,
  kBitwiseNot,
  kTypeOf,
  kVoid,
  kDelete,
  kThrow,
};

absl::string_view JsUnaryOperatorToString(JsUnaryOperator unary_operator);
absl::StatusOr<JsUnaryOperator> StringToJsUnaryOperator(absl::string_view s);

enum class JsUpdateOperator {
  kIncrement,
  kDecrement,
};

absl::string_view JsUpdateOperatorToString(JsUpdateOperator update_operator);
absl::StatusOr<JsUpdateOperator> StringToJsUpdateOperator(absl::string_view s);

enum class JsBinaryOperator {
  kEqual,
  kNotEqual,
  kStrictEqual,
  kStrictNotEqual,
  kLessThan,
  kLessEqual,
  kGreaterThan,
  kGreaterEqual,
  kLeftShift,
  kRightShift,
  kUnsignedRightShift,
  kAdd,
  kSubtract,
  kMultiply,
  kDivide,
  kMod,
  kExp,
  kBitwiseOr,
  kBitwiseXor,
  kBitwiseAnd,
  kIn,
  kInstanceOf,
  kPipeline,
};

absl::string_view JsBinaryOperatorToString(JsBinaryOperator binary_operator);
absl::StatusOr<JsBinaryOperator> StringToJsBinaryOperator(absl::string_view s);

enum class JsAssignmentOperator {
  kAssign,
  kAddAssign,
  kSubtractAssign,
  kMultiplyAssign,
  kDivideAssign,
  kModAssign,
  kExpAssign,
  kLeftShiftAssign,
  kRightShiftAssign,
  kUnsignedRightShiftAssign,
  kBitwiseOrAssign,
  kBitwiseXorAssign,
  kBitwiseAndAssign,
  kOrAssign,
  kAndAssign,
  kNullishCoalesceAssign,
};

absl::string_view JsAssignmentOperatorToString(JsAssignmentOperator assignment_operator);
absl::StatusOr<JsAssignmentOperator> StringToJsAssignmentOperator(absl::string_view s);

enum class JsLogicalOperator {
  kOr,
  kAnd,
  kNullishCoalesce,
};

absl::string_view JsLogicalOperatorToString(JsLogicalOperator logical_operator);
absl::StatusOr<JsLogicalOperator> StringToJsLogicalOperator(absl::string_view s);

class JsPosition {
 public:
  explicit JsPosition(
      int64_t line,
      int64_t column);

  void Serialize(std::ostream& os) const;

  static absl::StatusOr<std::unique_ptr<JsPosition>> FromJson(const nlohmann::json& json);

  int64_t line() const;
  void set_line(int64_t line);

  int64_t column() const;
  void set_column(int64_t column);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<int64_t> GetLine(const nlohmann::json& json);
  static absl::StatusOr<int64_t> GetColumn(const nlohmann::json& json);

 private:
  int64_t line_;
  int64_t column_;
};

class JsSourceLocation {
 public:
  explicit JsSourceLocation(
      std::unique_ptr<JsPosition> start,
      std::unique_ptr<JsPosition> end,
      std::optional<std::string> identifier_name);

  void Serialize(std::ostream& os) const;

  static absl::StatusOr<std::unique_ptr<JsSourceLocation>> FromJson(const nlohmann::json& json);

  JsPosition* start();
  const JsPosition* start() const;
  void set_start(std::unique_ptr<JsPosition> start);

  JsPosition* end();
  const JsPosition* end() const;
  void set_end(std::unique_ptr<JsPosition> end);

  std::optional<absl::string_view> identifier_name() const;
  void set_identifier_name(std::optional<std::string> identifier_name);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsPosition>> GetStart(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsPosition>> GetEnd(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::string>> GetIdentifierName(const nlohmann::json& json);

 private:
  std::unique_ptr<JsPosition> start_;
  std::unique_ptr<JsPosition> end_;
  std::optional<std::string> identifier_name_;
};

enum class JsCommentType {
  kCommentBlock,
  kCommentLine,
};

absl::string_view JsCommentTypeToString(JsCommentType comment_type);
absl::StatusOr<JsCommentType> StringToJsCommentType(absl::string_view s);

class JsComment {
 public:
  explicit JsComment(
      std::unique_ptr<JsSourceLocation> loc,
      std::string value,
      int64_t start,
      int64_t end);

  virtual ~JsComment() = default;

  virtual JsCommentType comment_type() const = 0;

  virtual void Serialize(std::ostream& os) const = 0;

  static absl::StatusOr<std::unique_ptr<JsComment>> FromJson(const nlohmann::json& json);

  JsSourceLocation* loc();
  const JsSourceLocation* loc() const;
  void set_loc(std::unique_ptr<JsSourceLocation> loc);

  absl::string_view value() const;
  void set_value(std::string value);

  int64_t start() const;
  void set_start(int64_t start);

  int64_t end() const;
  void set_end(int64_t end);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsSourceLocation>> GetLoc(const nlohmann::json& json);
  static absl::StatusOr<std::string> GetValue(const nlohmann::json& json);
  static absl::StatusOr<int64_t> GetStart(const nlohmann::json& json);
  static absl::StatusOr<int64_t> GetEnd(const nlohmann::json& json);

 private:
  std::unique_ptr<JsSourceLocation> loc_;
  std::string value_;
  int64_t start_;
  int64_t end_;
};

class JsCommentBlock : public virtual JsComment {
 public:
  explicit JsCommentBlock(
      std::unique_ptr<JsSourceLocation> loc,
      std::string value,
      int64_t start,
      int64_t end);

  JsCommentType comment_type() const override {
    return JsCommentType::kCommentBlock;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsCommentBlock>> FromJson(const nlohmann::json& json);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;
};

class JsCommentLine : public virtual JsComment {
 public:
  explicit JsCommentLine(
      std::unique_ptr<JsSourceLocation> loc,
      std::string value,
      int64_t start,
      int64_t end);

  JsCommentType comment_type() const override {
    return JsCommentType::kCommentLine;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsCommentLine>> FromJson(const nlohmann::json& json);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;
};

class JsSymbolId {
 public:
  explicit JsSymbolId(
      std::string name,
      std::optional<int64_t> def_scope_uid);

  void Serialize(std::ostream& os) const;

  static absl::StatusOr<std::unique_ptr<JsSymbolId>> FromJson(const nlohmann::json& json);

  absl::string_view name() const;
  void set_name(std::string name);

  std::optional<int64_t> def_scope_uid() const;
  void set_def_scope_uid(std::optional<int64_t> def_scope_uid);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::string> GetName(const nlohmann::json& json);
  static absl::StatusOr<std::optional<int64_t>> GetDefScopeUid(const nlohmann::json& json);

 private:
  std::string name_;
  std::optional<int64_t> def_scope_uid_;
};

enum class JsNodeType {
  kFile,
  kPrivateName,
  kProgram,
  kFunctionDeclaration,
  kObjectMethod,
  kFunctionExpression,
  kClassMethod,
  kClassPrivateMethod,
  kArrowFunctionExpression,
  kExpressionStatement,
  kBlockStatement,
  kEmptyStatement,
  kDebuggerStatement,
  kWithStatement,
  kReturnStatement,
  kLabeledStatement,
  kBreakStatement,
  kContinueStatement,
  kIfStatement,
  kSwitchStatement,
  kThrowStatement,
  kTryStatement,
  kWhileStatement,
  kDoWhileStatement,
  kForStatement,
  kForInStatement,
  kForOfStatement,
  kVariableDeclaration,
  kClassDeclaration,
  kSwitchCase,
  kCatchClause,
  kVariableDeclarator,
  kDirective,
  kDirectiveLiteral,
  kInterpreterDirective,
  kIdentifier,
  kRegExpLiteral,
  kNullLiteral,
  kStringLiteral,
  kBooleanLiteral,
  kNumericLiteral,
  kBigIntLiteral,
  kThisExpression,
  kYieldExpression,
  kAwaitExpression,
  kArrayExpression,
  kObjectExpression,
  kUnaryExpression,
  kUpdateExpression,
  kBinaryExpression,
  kAssignmentExpression,
  kLogicalExpression,
  kMemberExpression,
  kOptionalMemberExpression,
  kConditionalExpression,
  kCallExpression,
  kOptionalCallExpression,
  kNewExpression,
  kSequenceExpression,
  kParenthesizedExpression,
  kTemplateLiteral,
  kTaggedTemplateExpression,
  kClassExpression,
  kMetaProperty,
  kObjectPattern,
  kArrayPattern,
  kRestElement,
  kAssignmentPattern,
  kSuper,
  kImport,
  kObjectProperty,
  kSpreadElement,
  kTemplateElement,
  kClassBody,
  kClassProperty,
  kClassPrivateProperty,
  kImportDeclaration,
  kExportNamedDeclaration,
  kExportDefaultDeclaration,
  kExportAllDeclaration,
  kImportSpecifier,
  kImportDefaultSpecifier,
  kImportNamespaceSpecifier,
  kExportSpecifier,
  kImportAttribute,
};

absl::string_view JsNodeTypeToString(JsNodeType node_type);
absl::StatusOr<JsNodeType> StringToJsNodeType(absl::string_view s);

class JsNode {
 public:
  explicit JsNode(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols);

  virtual ~JsNode() = default;

  virtual JsNodeType node_type() const = 0;

  virtual void Serialize(std::ostream& os) const = 0;

  static absl::StatusOr<std::unique_ptr<JsNode>> FromJson(const nlohmann::json& json);

  std::optional<JsSourceLocation*> loc();
  std::optional<const JsSourceLocation*> loc() const;
  void set_loc(std::optional<std::unique_ptr<JsSourceLocation>> loc);

  std::optional<int64_t> start() const;
  void set_start(std::optional<int64_t> start);

  std::optional<int64_t> end() const;
  void set_end(std::optional<int64_t> end);

  std::optional<std::vector<std::unique_ptr<JsComment>>*> leading_comments();
  std::optional<const std::vector<std::unique_ptr<JsComment>>*> leading_comments() const;
  void set_leading_comments(std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments);

  std::optional<std::vector<std::unique_ptr<JsComment>>*> trailing_comments();
  std::optional<const std::vector<std::unique_ptr<JsComment>>*> trailing_comments() const;
  void set_trailing_comments(std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments);

  std::optional<std::vector<std::unique_ptr<JsComment>>*> inner_comments();
  std::optional<const std::vector<std::unique_ptr<JsComment>>*> inner_comments() const;
  void set_inner_comments(std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments);

  std::optional<int64_t> scope_uid() const;
  void set_scope_uid(std::optional<int64_t> scope_uid);

  std::optional<JsSymbolId*> referenced_symbol();
  std::optional<const JsSymbolId*> referenced_symbol() const;
  void set_referenced_symbol(std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol);

  std::optional<std::vector<std::unique_ptr<JsSymbolId>>*> defined_symbols();
  std::optional<const std::vector<std::unique_ptr<JsSymbolId>>*> defined_symbols() const;
  void set_defined_symbols(std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::optional<std::unique_ptr<JsSourceLocation>>> GetLoc(const nlohmann::json& json);
  static absl::StatusOr<std::optional<int64_t>> GetStart(const nlohmann::json& json);
  static absl::StatusOr<std::optional<int64_t>> GetEnd(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::vector<std::unique_ptr<JsComment>>>> GetLeadingComments(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::vector<std::unique_ptr<JsComment>>>> GetTrailingComments(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::vector<std::unique_ptr<JsComment>>>> GetInnerComments(const nlohmann::json& json);
  static absl::StatusOr<std::optional<int64_t>> GetScopeUid(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::unique_ptr<JsSymbolId>>> GetReferencedSymbol(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::vector<std::unique_ptr<JsSymbolId>>>> GetDefinedSymbols(const nlohmann::json& json);

 private:
  std::optional<std::unique_ptr<JsSourceLocation>> loc_;
  std::optional<int64_t> start_;
  std::optional<int64_t> end_;
  std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments_;
  std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments_;
  std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments_;
  std::optional<int64_t> scope_uid_;
  std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol_;
  std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols_;
};

class JsInterpreterDirective : public virtual JsNode {
 public:
  explicit JsInterpreterDirective(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::string value);

  JsNodeType node_type() const override {
    return JsNodeType::kInterpreterDirective;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsInterpreterDirective>> FromJson(const nlohmann::json& json);

  absl::string_view value() const;
  void set_value(std::string value);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::string> GetValue(const nlohmann::json& json);

 private:
  std::string value_;
};

class JsStatement : public virtual JsNode {
 public:
  explicit JsStatement(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols);

  static absl::StatusOr<std::unique_ptr<JsStatement>> FromJson(const nlohmann::json& json);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;
};

class JsModuleDeclaration : public virtual JsNode {
 public:
  explicit JsModuleDeclaration(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols);

  static absl::StatusOr<std::unique_ptr<JsModuleDeclaration>> FromJson(const nlohmann::json& json);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;
};

class JsDirectiveLiteralExtra {
 public:
  explicit JsDirectiveLiteralExtra(
      std::string raw,
      std::string raw_value);

  void Serialize(std::ostream& os) const;

  static absl::StatusOr<std::unique_ptr<JsDirectiveLiteralExtra>> FromJson(const nlohmann::json& json);

  absl::string_view raw() const;
  void set_raw(std::string raw);

  absl::string_view raw_value() const;
  void set_raw_value(std::string raw_value);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::string> GetRaw(const nlohmann::json& json);
  static absl::StatusOr<std::string> GetRawValue(const nlohmann::json& json);

 private:
  std::string raw_;
  std::string raw_value_;
};

class JsDirectiveLiteral : public virtual JsNode {
 public:
  explicit JsDirectiveLiteral(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::string value,
      std::optional<std::unique_ptr<JsDirectiveLiteralExtra>> extra);

  JsNodeType node_type() const override {
    return JsNodeType::kDirectiveLiteral;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsDirectiveLiteral>> FromJson(const nlohmann::json& json);

  absl::string_view value() const;
  void set_value(std::string value);

  std::optional<JsDirectiveLiteralExtra*> extra();
  std::optional<const JsDirectiveLiteralExtra*> extra() const;
  void set_extra(std::optional<std::unique_ptr<JsDirectiveLiteralExtra>> extra);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::string> GetValue(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::unique_ptr<JsDirectiveLiteralExtra>>> GetExtra(const nlohmann::json& json);

 private:
  std::string value_;
  std::optional<std::unique_ptr<JsDirectiveLiteralExtra>> extra_;
};

class JsDirective : public virtual JsNode {
 public:
  explicit JsDirective(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsDirectiveLiteral> value);

  JsNodeType node_type() const override {
    return JsNodeType::kDirective;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsDirective>> FromJson(const nlohmann::json& json);

  JsDirectiveLiteral* value();
  const JsDirectiveLiteral* value() const;
  void set_value(std::unique_ptr<JsDirectiveLiteral> value);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsDirectiveLiteral>> GetValue(const nlohmann::json& json);

 private:
  std::unique_ptr<JsDirectiveLiteral> value_;
};

class JsProgram : public virtual JsNode {
 public:
  explicit JsProgram(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::optional<std::unique_ptr<JsInterpreterDirective>> interpreter,
      std::string source_type,
      std::vector<std::variant<std::unique_ptr<JsStatement>, std::unique_ptr<JsModuleDeclaration>>> body,
      std::vector<std::unique_ptr<JsDirective>> directives);

  JsNodeType node_type() const override {
    return JsNodeType::kProgram;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsProgram>> FromJson(const nlohmann::json& json);

  std::optional<JsInterpreterDirective*> interpreter();
  std::optional<const JsInterpreterDirective*> interpreter() const;
  void set_interpreter(std::optional<std::unique_ptr<JsInterpreterDirective>> interpreter);

  absl::string_view source_type() const;
  void set_source_type(std::string source_type);

  std::vector<std::variant<std::unique_ptr<JsStatement>, std::unique_ptr<JsModuleDeclaration>>>* body();
  const std::vector<std::variant<std::unique_ptr<JsStatement>, std::unique_ptr<JsModuleDeclaration>>>* body() const;
  void set_body(std::vector<std::variant<std::unique_ptr<JsStatement>, std::unique_ptr<JsModuleDeclaration>>> body);

  std::vector<std::unique_ptr<JsDirective>>* directives();
  const std::vector<std::unique_ptr<JsDirective>>* directives() const;
  void set_directives(std::vector<std::unique_ptr<JsDirective>> directives);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::optional<std::unique_ptr<JsInterpreterDirective>>> GetInterpreter(const nlohmann::json& json);
  static absl::StatusOr<std::string> GetSourceType(const nlohmann::json& json);
  static absl::StatusOr<std::vector<std::variant<std::unique_ptr<JsStatement>, std::unique_ptr<JsModuleDeclaration>>>> GetBody(const nlohmann::json& json);
  static absl::StatusOr<std::vector<std::unique_ptr<JsDirective>>> GetDirectives(const nlohmann::json& json);

 private:
  std::optional<std::unique_ptr<JsInterpreterDirective>> interpreter_;
  std::string source_type_;
  std::vector<std::variant<std::unique_ptr<JsStatement>, std::unique_ptr<JsModuleDeclaration>>> body_;
  std::vector<std::unique_ptr<JsDirective>> directives_;
};

class JsFile : public virtual JsNode {
 public:
  explicit JsFile(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsProgram> program);

  JsNodeType node_type() const override {
    return JsNodeType::kFile;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsFile>> FromJson(const nlohmann::json& json);

  JsProgram* program();
  const JsProgram* program() const;
  void set_program(std::unique_ptr<JsProgram> program);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsProgram>> GetProgram(const nlohmann::json& json);

 private:
  std::unique_ptr<JsProgram> program_;
};

class JsExpression : public virtual JsNode {
 public:
  explicit JsExpression(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols);

  static absl::StatusOr<std::unique_ptr<JsExpression>> FromJson(const nlohmann::json& json);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;
};

class JsPattern : public virtual JsNode {
 public:
  explicit JsPattern(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols);

  static absl::StatusOr<std::unique_ptr<JsPattern>> FromJson(const nlohmann::json& json);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;
};

class JsLVal : public virtual JsNode {
 public:
  explicit JsLVal(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols);

  static absl::StatusOr<std::unique_ptr<JsLVal>> FromJson(const nlohmann::json& json);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;
};

class JsIdentifier : public virtual JsExpression, public virtual JsPattern, public virtual JsLVal {
 public:
  explicit JsIdentifier(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::string name);

  JsNodeType node_type() const override {
    return JsNodeType::kIdentifier;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsIdentifier>> FromJson(const nlohmann::json& json);

  absl::string_view name() const;
  void set_name(std::string name);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::string> GetName(const nlohmann::json& json);

 private:
  std::string name_;
};

class JsPrivateName : public virtual JsNode {
 public:
  explicit JsPrivateName(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsIdentifier> id);

  JsNodeType node_type() const override {
    return JsNodeType::kPrivateName;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsPrivateName>> FromJson(const nlohmann::json& json);

  JsIdentifier* id();
  const JsIdentifier* id() const;
  void set_id(std::unique_ptr<JsIdentifier> id);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsIdentifier>> GetId(const nlohmann::json& json);

 private:
  std::unique_ptr<JsIdentifier> id_;
};

class JsLiteral : public virtual JsExpression {
 public:
  explicit JsLiteral(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols);

  static absl::StatusOr<std::unique_ptr<JsLiteral>> FromJson(const nlohmann::json& json);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;
};

class JsRegExpLiteralExtra {
 public:
  explicit JsRegExpLiteralExtra(
      std::string raw);

  void Serialize(std::ostream& os) const;

  static absl::StatusOr<std::unique_ptr<JsRegExpLiteralExtra>> FromJson(const nlohmann::json& json);

  absl::string_view raw() const;
  void set_raw(std::string raw);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::string> GetRaw(const nlohmann::json& json);

 private:
  std::string raw_;
};

class JsRegExpLiteral : public virtual JsLiteral {
 public:
  explicit JsRegExpLiteral(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::string pattern,
      std::string flags,
      std::optional<std::unique_ptr<JsRegExpLiteralExtra>> extra);

  JsNodeType node_type() const override {
    return JsNodeType::kRegExpLiteral;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsRegExpLiteral>> FromJson(const nlohmann::json& json);

  absl::string_view pattern() const;
  void set_pattern(std::string pattern);

  absl::string_view flags() const;
  void set_flags(std::string flags);

  std::optional<JsRegExpLiteralExtra*> extra();
  std::optional<const JsRegExpLiteralExtra*> extra() const;
  void set_extra(std::optional<std::unique_ptr<JsRegExpLiteralExtra>> extra);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::string> GetPattern(const nlohmann::json& json);
  static absl::StatusOr<std::string> GetFlags(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::unique_ptr<JsRegExpLiteralExtra>>> GetExtra(const nlohmann::json& json);

 private:
  std::string pattern_;
  std::string flags_;
  std::optional<std::unique_ptr<JsRegExpLiteralExtra>> extra_;
};

class JsNullLiteral : public virtual JsLiteral {
 public:
  explicit JsNullLiteral(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols);

  JsNodeType node_type() const override {
    return JsNodeType::kNullLiteral;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsNullLiteral>> FromJson(const nlohmann::json& json);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;
};

class JsStringLiteralExtra {
 public:
  explicit JsStringLiteralExtra(
      std::string raw,
      std::string raw_value);

  void Serialize(std::ostream& os) const;

  static absl::StatusOr<std::unique_ptr<JsStringLiteralExtra>> FromJson(const nlohmann::json& json);

  absl::string_view raw() const;
  void set_raw(std::string raw);

  absl::string_view raw_value() const;
  void set_raw_value(std::string raw_value);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::string> GetRaw(const nlohmann::json& json);
  static absl::StatusOr<std::string> GetRawValue(const nlohmann::json& json);

 private:
  std::string raw_;
  std::string raw_value_;
};

class JsStringLiteral : public virtual JsLiteral {
 public:
  explicit JsStringLiteral(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::string value,
      std::optional<std::unique_ptr<JsStringLiteralExtra>> extra);

  JsNodeType node_type() const override {
    return JsNodeType::kStringLiteral;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsStringLiteral>> FromJson(const nlohmann::json& json);

  absl::string_view value() const;
  void set_value(std::string value);

  std::optional<JsStringLiteralExtra*> extra();
  std::optional<const JsStringLiteralExtra*> extra() const;
  void set_extra(std::optional<std::unique_ptr<JsStringLiteralExtra>> extra);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::string> GetValue(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::unique_ptr<JsStringLiteralExtra>>> GetExtra(const nlohmann::json& json);

 private:
  std::string value_;
  std::optional<std::unique_ptr<JsStringLiteralExtra>> extra_;
};

class JsBooleanLiteral : public virtual JsLiteral {
 public:
  explicit JsBooleanLiteral(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      bool value);

  JsNodeType node_type() const override {
    return JsNodeType::kBooleanLiteral;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsBooleanLiteral>> FromJson(const nlohmann::json& json);

  bool value() const;
  void set_value(bool value);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<bool> GetValue(const nlohmann::json& json);

 private:
  bool value_;
};

class JsNumericLiteralExtra {
 public:
  explicit JsNumericLiteralExtra(
      std::string raw,
      double raw_value);

  void Serialize(std::ostream& os) const;

  static absl::StatusOr<std::unique_ptr<JsNumericLiteralExtra>> FromJson(const nlohmann::json& json);

  absl::string_view raw() const;
  void set_raw(std::string raw);

  double raw_value() const;
  void set_raw_value(double raw_value);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::string> GetRaw(const nlohmann::json& json);
  static absl::StatusOr<double> GetRawValue(const nlohmann::json& json);

 private:
  std::string raw_;
  double raw_value_;
};

class JsNumericLiteral : public virtual JsLiteral {
 public:
  explicit JsNumericLiteral(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      double value,
      std::optional<std::unique_ptr<JsNumericLiteralExtra>> extra);

  JsNodeType node_type() const override {
    return JsNodeType::kNumericLiteral;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsNumericLiteral>> FromJson(const nlohmann::json& json);

  double value() const;
  void set_value(double value);

  std::optional<JsNumericLiteralExtra*> extra();
  std::optional<const JsNumericLiteralExtra*> extra() const;
  void set_extra(std::optional<std::unique_ptr<JsNumericLiteralExtra>> extra);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<double> GetValue(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::unique_ptr<JsNumericLiteralExtra>>> GetExtra(const nlohmann::json& json);

 private:
  double value_;
  std::optional<std::unique_ptr<JsNumericLiteralExtra>> extra_;
};

class JsBigIntLiteralExtra {
 public:
  explicit JsBigIntLiteralExtra(
      std::string raw,
      std::string raw_value);

  void Serialize(std::ostream& os) const;

  static absl::StatusOr<std::unique_ptr<JsBigIntLiteralExtra>> FromJson(const nlohmann::json& json);

  absl::string_view raw() const;
  void set_raw(std::string raw);

  absl::string_view raw_value() const;
  void set_raw_value(std::string raw_value);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::string> GetRaw(const nlohmann::json& json);
  static absl::StatusOr<std::string> GetRawValue(const nlohmann::json& json);

 private:
  std::string raw_;
  std::string raw_value_;
};

class JsBigIntLiteral : public virtual JsLiteral {
 public:
  explicit JsBigIntLiteral(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::string value,
      std::optional<std::unique_ptr<JsBigIntLiteralExtra>> extra);

  JsNodeType node_type() const override {
    return JsNodeType::kBigIntLiteral;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsBigIntLiteral>> FromJson(const nlohmann::json& json);

  absl::string_view value() const;
  void set_value(std::string value);

  std::optional<JsBigIntLiteralExtra*> extra();
  std::optional<const JsBigIntLiteralExtra*> extra() const;
  void set_extra(std::optional<std::unique_ptr<JsBigIntLiteralExtra>> extra);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::string> GetValue(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::unique_ptr<JsBigIntLiteralExtra>>> GetExtra(const nlohmann::json& json);

 private:
  std::string value_;
  std::optional<std::unique_ptr<JsBigIntLiteralExtra>> extra_;
};

class JsFunction : public virtual JsNode {
 public:
  explicit JsFunction(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::optional<std::unique_ptr<JsIdentifier>> id,
      std::vector<std::unique_ptr<JsPattern>> params,
      bool generator,
      bool async);

  static absl::StatusOr<std::unique_ptr<JsFunction>> FromJson(const nlohmann::json& json);

  std::optional<JsIdentifier*> id();
  std::optional<const JsIdentifier*> id() const;
  void set_id(std::optional<std::unique_ptr<JsIdentifier>> id);

  std::vector<std::unique_ptr<JsPattern>>* params();
  const std::vector<std::unique_ptr<JsPattern>>* params() const;
  void set_params(std::vector<std::unique_ptr<JsPattern>> params);

  bool generator() const;
  void set_generator(bool generator);

  bool async() const;
  void set_async(bool async);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::optional<std::unique_ptr<JsIdentifier>>> GetId(const nlohmann::json& json);
  static absl::StatusOr<std::vector<std::unique_ptr<JsPattern>>> GetParams(const nlohmann::json& json);
  static absl::StatusOr<bool> GetGenerator(const nlohmann::json& json);
  static absl::StatusOr<bool> GetAsync(const nlohmann::json& json);

 private:
  std::optional<std::unique_ptr<JsIdentifier>> id_;
  std::vector<std::unique_ptr<JsPattern>> params_;
  bool generator_;
  bool async_;
};

class JsBlockStatement : public virtual JsStatement {
 public:
  explicit JsBlockStatement(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::vector<std::unique_ptr<JsStatement>> body,
      std::vector<std::unique_ptr<JsDirective>> directives);

  JsNodeType node_type() const override {
    return JsNodeType::kBlockStatement;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsBlockStatement>> FromJson(const nlohmann::json& json);

  std::vector<std::unique_ptr<JsStatement>>* body();
  const std::vector<std::unique_ptr<JsStatement>>* body() const;
  void set_body(std::vector<std::unique_ptr<JsStatement>> body);

  std::vector<std::unique_ptr<JsDirective>>* directives();
  const std::vector<std::unique_ptr<JsDirective>>* directives() const;
  void set_directives(std::vector<std::unique_ptr<JsDirective>> directives);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::vector<std::unique_ptr<JsStatement>>> GetBody(const nlohmann::json& json);
  static absl::StatusOr<std::vector<std::unique_ptr<JsDirective>>> GetDirectives(const nlohmann::json& json);

 private:
  std::vector<std::unique_ptr<JsStatement>> body_;
  std::vector<std::unique_ptr<JsDirective>> directives_;
};

class JsBlockStatementFunction : public virtual JsFunction {
 public:
  explicit JsBlockStatementFunction(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::optional<std::unique_ptr<JsIdentifier>> id,
      std::vector<std::unique_ptr<JsPattern>> params,
      bool generator,
      bool async,
      std::unique_ptr<JsBlockStatement> body);

  static absl::StatusOr<std::unique_ptr<JsBlockStatementFunction>> FromJson(const nlohmann::json& json);

  JsBlockStatement* body();
  const JsBlockStatement* body() const;
  void set_body(std::unique_ptr<JsBlockStatement> body);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsBlockStatement>> GetBody(const nlohmann::json& json);

 private:
  std::unique_ptr<JsBlockStatement> body_;
};

class JsExpressionStatement : public virtual JsStatement {
 public:
  explicit JsExpressionStatement(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsExpression> expression);

  JsNodeType node_type() const override {
    return JsNodeType::kExpressionStatement;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsExpressionStatement>> FromJson(const nlohmann::json& json);

  JsExpression* expression();
  const JsExpression* expression() const;
  void set_expression(std::unique_ptr<JsExpression> expression);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetExpression(const nlohmann::json& json);

 private:
  std::unique_ptr<JsExpression> expression_;
};

class JsEmptyStatement : public virtual JsStatement {
 public:
  explicit JsEmptyStatement(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols);

  JsNodeType node_type() const override {
    return JsNodeType::kEmptyStatement;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsEmptyStatement>> FromJson(const nlohmann::json& json);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;
};

class JsDebuggerStatement : public virtual JsStatement {
 public:
  explicit JsDebuggerStatement(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols);

  JsNodeType node_type() const override {
    return JsNodeType::kDebuggerStatement;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsDebuggerStatement>> FromJson(const nlohmann::json& json);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;
};

class JsWithStatement : public virtual JsStatement {
 public:
  explicit JsWithStatement(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsExpression> object,
      std::unique_ptr<JsStatement> body);

  JsNodeType node_type() const override {
    return JsNodeType::kWithStatement;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsWithStatement>> FromJson(const nlohmann::json& json);

  JsExpression* object();
  const JsExpression* object() const;
  void set_object(std::unique_ptr<JsExpression> object);

  JsStatement* body();
  const JsStatement* body() const;
  void set_body(std::unique_ptr<JsStatement> body);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetObject(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsStatement>> GetBody(const nlohmann::json& json);

 private:
  std::unique_ptr<JsExpression> object_;
  std::unique_ptr<JsStatement> body_;
};

class JsReturnStatement : public virtual JsStatement {
 public:
  explicit JsReturnStatement(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::optional<std::unique_ptr<JsExpression>> argument);

  JsNodeType node_type() const override {
    return JsNodeType::kReturnStatement;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsReturnStatement>> FromJson(const nlohmann::json& json);

  std::optional<JsExpression*> argument();
  std::optional<const JsExpression*> argument() const;
  void set_argument(std::optional<std::unique_ptr<JsExpression>> argument);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::optional<std::unique_ptr<JsExpression>>> GetArgument(const nlohmann::json& json);

 private:
  std::optional<std::unique_ptr<JsExpression>> argument_;
};

class JsLabeledStatement : public virtual JsStatement {
 public:
  explicit JsLabeledStatement(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsIdentifier> label,
      std::unique_ptr<JsStatement> body);

  JsNodeType node_type() const override {
    return JsNodeType::kLabeledStatement;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsLabeledStatement>> FromJson(const nlohmann::json& json);

  JsIdentifier* label();
  const JsIdentifier* label() const;
  void set_label(std::unique_ptr<JsIdentifier> label);

  JsStatement* body();
  const JsStatement* body() const;
  void set_body(std::unique_ptr<JsStatement> body);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsIdentifier>> GetLabel(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsStatement>> GetBody(const nlohmann::json& json);

 private:
  std::unique_ptr<JsIdentifier> label_;
  std::unique_ptr<JsStatement> body_;
};

class JsBreakStatement : public virtual JsStatement {
 public:
  explicit JsBreakStatement(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::optional<std::unique_ptr<JsIdentifier>> label);

  JsNodeType node_type() const override {
    return JsNodeType::kBreakStatement;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsBreakStatement>> FromJson(const nlohmann::json& json);

  std::optional<JsIdentifier*> label();
  std::optional<const JsIdentifier*> label() const;
  void set_label(std::optional<std::unique_ptr<JsIdentifier>> label);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::optional<std::unique_ptr<JsIdentifier>>> GetLabel(const nlohmann::json& json);

 private:
  std::optional<std::unique_ptr<JsIdentifier>> label_;
};

class JsContinueStatement : public virtual JsStatement {
 public:
  explicit JsContinueStatement(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::optional<std::unique_ptr<JsIdentifier>> label);

  JsNodeType node_type() const override {
    return JsNodeType::kContinueStatement;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsContinueStatement>> FromJson(const nlohmann::json& json);

  std::optional<JsIdentifier*> label();
  std::optional<const JsIdentifier*> label() const;
  void set_label(std::optional<std::unique_ptr<JsIdentifier>> label);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::optional<std::unique_ptr<JsIdentifier>>> GetLabel(const nlohmann::json& json);

 private:
  std::optional<std::unique_ptr<JsIdentifier>> label_;
};

class JsIfStatement : public virtual JsStatement {
 public:
  explicit JsIfStatement(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsExpression> test,
      std::unique_ptr<JsStatement> consequent,
      std::optional<std::unique_ptr<JsStatement>> alternate);

  JsNodeType node_type() const override {
    return JsNodeType::kIfStatement;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsIfStatement>> FromJson(const nlohmann::json& json);

  JsExpression* test();
  const JsExpression* test() const;
  void set_test(std::unique_ptr<JsExpression> test);

  JsStatement* consequent();
  const JsStatement* consequent() const;
  void set_consequent(std::unique_ptr<JsStatement> consequent);

  std::optional<JsStatement*> alternate();
  std::optional<const JsStatement*> alternate() const;
  void set_alternate(std::optional<std::unique_ptr<JsStatement>> alternate);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetTest(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsStatement>> GetConsequent(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::unique_ptr<JsStatement>>> GetAlternate(const nlohmann::json& json);

 private:
  std::unique_ptr<JsExpression> test_;
  std::unique_ptr<JsStatement> consequent_;
  std::optional<std::unique_ptr<JsStatement>> alternate_;
};

class JsSwitchCase : public virtual JsNode {
 public:
  explicit JsSwitchCase(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::optional<std::unique_ptr<JsExpression>> test,
      std::vector<std::unique_ptr<JsStatement>> consequent);

  JsNodeType node_type() const override {
    return JsNodeType::kSwitchCase;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsSwitchCase>> FromJson(const nlohmann::json& json);

  std::optional<JsExpression*> test();
  std::optional<const JsExpression*> test() const;
  void set_test(std::optional<std::unique_ptr<JsExpression>> test);

  std::vector<std::unique_ptr<JsStatement>>* consequent();
  const std::vector<std::unique_ptr<JsStatement>>* consequent() const;
  void set_consequent(std::vector<std::unique_ptr<JsStatement>> consequent);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::optional<std::unique_ptr<JsExpression>>> GetTest(const nlohmann::json& json);
  static absl::StatusOr<std::vector<std::unique_ptr<JsStatement>>> GetConsequent(const nlohmann::json& json);

 private:
  std::optional<std::unique_ptr<JsExpression>> test_;
  std::vector<std::unique_ptr<JsStatement>> consequent_;
};

class JsSwitchStatement : public virtual JsStatement {
 public:
  explicit JsSwitchStatement(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsExpression> discriminant,
      std::vector<std::unique_ptr<JsSwitchCase>> cases);

  JsNodeType node_type() const override {
    return JsNodeType::kSwitchStatement;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsSwitchStatement>> FromJson(const nlohmann::json& json);

  JsExpression* discriminant();
  const JsExpression* discriminant() const;
  void set_discriminant(std::unique_ptr<JsExpression> discriminant);

  std::vector<std::unique_ptr<JsSwitchCase>>* cases();
  const std::vector<std::unique_ptr<JsSwitchCase>>* cases() const;
  void set_cases(std::vector<std::unique_ptr<JsSwitchCase>> cases);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetDiscriminant(const nlohmann::json& json);
  static absl::StatusOr<std::vector<std::unique_ptr<JsSwitchCase>>> GetCases(const nlohmann::json& json);

 private:
  std::unique_ptr<JsExpression> discriminant_;
  std::vector<std::unique_ptr<JsSwitchCase>> cases_;
};

class JsThrowStatement : public virtual JsStatement {
 public:
  explicit JsThrowStatement(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsExpression> argument);

  JsNodeType node_type() const override {
    return JsNodeType::kThrowStatement;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsThrowStatement>> FromJson(const nlohmann::json& json);

  JsExpression* argument();
  const JsExpression* argument() const;
  void set_argument(std::unique_ptr<JsExpression> argument);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetArgument(const nlohmann::json& json);

 private:
  std::unique_ptr<JsExpression> argument_;
};

class JsCatchClause : public virtual JsNode {
 public:
  explicit JsCatchClause(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::optional<std::unique_ptr<JsPattern>> param,
      std::unique_ptr<JsBlockStatement> body);

  JsNodeType node_type() const override {
    return JsNodeType::kCatchClause;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsCatchClause>> FromJson(const nlohmann::json& json);

  std::optional<JsPattern*> param();
  std::optional<const JsPattern*> param() const;
  void set_param(std::optional<std::unique_ptr<JsPattern>> param);

  JsBlockStatement* body();
  const JsBlockStatement* body() const;
  void set_body(std::unique_ptr<JsBlockStatement> body);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::optional<std::unique_ptr<JsPattern>>> GetParam(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsBlockStatement>> GetBody(const nlohmann::json& json);

 private:
  std::optional<std::unique_ptr<JsPattern>> param_;
  std::unique_ptr<JsBlockStatement> body_;
};

class JsTryStatement : public virtual JsStatement {
 public:
  explicit JsTryStatement(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsBlockStatement> block,
      std::optional<std::unique_ptr<JsCatchClause>> handler,
      std::optional<std::unique_ptr<JsBlockStatement>> finalizer);

  JsNodeType node_type() const override {
    return JsNodeType::kTryStatement;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsTryStatement>> FromJson(const nlohmann::json& json);

  JsBlockStatement* block();
  const JsBlockStatement* block() const;
  void set_block(std::unique_ptr<JsBlockStatement> block);

  std::optional<JsCatchClause*> handler();
  std::optional<const JsCatchClause*> handler() const;
  void set_handler(std::optional<std::unique_ptr<JsCatchClause>> handler);

  std::optional<JsBlockStatement*> finalizer();
  std::optional<const JsBlockStatement*> finalizer() const;
  void set_finalizer(std::optional<std::unique_ptr<JsBlockStatement>> finalizer);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsBlockStatement>> GetBlock(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::unique_ptr<JsCatchClause>>> GetHandler(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::unique_ptr<JsBlockStatement>>> GetFinalizer(const nlohmann::json& json);

 private:
  std::unique_ptr<JsBlockStatement> block_;
  std::optional<std::unique_ptr<JsCatchClause>> handler_;
  std::optional<std::unique_ptr<JsBlockStatement>> finalizer_;
};

class JsWhileStatement : public virtual JsStatement {
 public:
  explicit JsWhileStatement(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsExpression> test,
      std::unique_ptr<JsStatement> body);

  JsNodeType node_type() const override {
    return JsNodeType::kWhileStatement;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsWhileStatement>> FromJson(const nlohmann::json& json);

  JsExpression* test();
  const JsExpression* test() const;
  void set_test(std::unique_ptr<JsExpression> test);

  JsStatement* body();
  const JsStatement* body() const;
  void set_body(std::unique_ptr<JsStatement> body);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetTest(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsStatement>> GetBody(const nlohmann::json& json);

 private:
  std::unique_ptr<JsExpression> test_;
  std::unique_ptr<JsStatement> body_;
};

class JsDoWhileStatement : public virtual JsStatement {
 public:
  explicit JsDoWhileStatement(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsStatement> body,
      std::unique_ptr<JsExpression> test);

  JsNodeType node_type() const override {
    return JsNodeType::kDoWhileStatement;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsDoWhileStatement>> FromJson(const nlohmann::json& json);

  JsStatement* body();
  const JsStatement* body() const;
  void set_body(std::unique_ptr<JsStatement> body);

  JsExpression* test();
  const JsExpression* test() const;
  void set_test(std::unique_ptr<JsExpression> test);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsStatement>> GetBody(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetTest(const nlohmann::json& json);

 private:
  std::unique_ptr<JsStatement> body_;
  std::unique_ptr<JsExpression> test_;
};

class JsDeclaration : public virtual JsStatement {
 public:
  explicit JsDeclaration(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols);

  static absl::StatusOr<std::unique_ptr<JsDeclaration>> FromJson(const nlohmann::json& json);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;
};

class JsVariableDeclarator : public virtual JsNode {
 public:
  explicit JsVariableDeclarator(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsLVal> id,
      std::optional<std::unique_ptr<JsExpression>> init);

  JsNodeType node_type() const override {
    return JsNodeType::kVariableDeclarator;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsVariableDeclarator>> FromJson(const nlohmann::json& json);

  JsLVal* id();
  const JsLVal* id() const;
  void set_id(std::unique_ptr<JsLVal> id);

  std::optional<JsExpression*> init();
  std::optional<const JsExpression*> init() const;
  void set_init(std::optional<std::unique_ptr<JsExpression>> init);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsLVal>> GetId(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::unique_ptr<JsExpression>>> GetInit(const nlohmann::json& json);

 private:
  std::unique_ptr<JsLVal> id_;
  std::optional<std::unique_ptr<JsExpression>> init_;
};

class JsVariableDeclaration : public virtual JsDeclaration {
 public:
  explicit JsVariableDeclaration(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::vector<std::unique_ptr<JsVariableDeclarator>> declarations,
      std::string kind);

  JsNodeType node_type() const override {
    return JsNodeType::kVariableDeclaration;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsVariableDeclaration>> FromJson(const nlohmann::json& json);

  std::vector<std::unique_ptr<JsVariableDeclarator>>* declarations();
  const std::vector<std::unique_ptr<JsVariableDeclarator>>* declarations() const;
  void set_declarations(std::vector<std::unique_ptr<JsVariableDeclarator>> declarations);

  absl::string_view kind() const;
  void set_kind(std::string kind);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::vector<std::unique_ptr<JsVariableDeclarator>>> GetDeclarations(const nlohmann::json& json);
  static absl::StatusOr<std::string> GetKind(const nlohmann::json& json);

 private:
  std::vector<std::unique_ptr<JsVariableDeclarator>> declarations_;
  std::string kind_;
};

class JsForStatement : public virtual JsStatement {
 public:
  explicit JsForStatement(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::optional<std::variant<std::unique_ptr<JsVariableDeclaration>, std::unique_ptr<JsExpression>>> init,
      std::optional<std::unique_ptr<JsExpression>> test,
      std::optional<std::unique_ptr<JsExpression>> update,
      std::unique_ptr<JsStatement> body);

  JsNodeType node_type() const override {
    return JsNodeType::kForStatement;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsForStatement>> FromJson(const nlohmann::json& json);

  std::optional<std::variant<JsVariableDeclaration*, JsExpression*>> init();
  std::optional<std::variant<const JsVariableDeclaration*, const JsExpression*>> init() const;
  void set_init(std::optional<std::variant<std::unique_ptr<JsVariableDeclaration>, std::unique_ptr<JsExpression>>> init);

  std::optional<JsExpression*> test();
  std::optional<const JsExpression*> test() const;
  void set_test(std::optional<std::unique_ptr<JsExpression>> test);

  std::optional<JsExpression*> update();
  std::optional<const JsExpression*> update() const;
  void set_update(std::optional<std::unique_ptr<JsExpression>> update);

  JsStatement* body();
  const JsStatement* body() const;
  void set_body(std::unique_ptr<JsStatement> body);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::optional<std::variant<std::unique_ptr<JsVariableDeclaration>, std::unique_ptr<JsExpression>>>> GetInit(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::unique_ptr<JsExpression>>> GetTest(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::unique_ptr<JsExpression>>> GetUpdate(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsStatement>> GetBody(const nlohmann::json& json);

 private:
  std::optional<std::variant<std::unique_ptr<JsVariableDeclaration>, std::unique_ptr<JsExpression>>> init_;
  std::optional<std::unique_ptr<JsExpression>> test_;
  std::optional<std::unique_ptr<JsExpression>> update_;
  std::unique_ptr<JsStatement> body_;
};

class JsForInStatement : public virtual JsStatement {
 public:
  explicit JsForInStatement(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::variant<std::unique_ptr<JsVariableDeclaration>, std::unique_ptr<JsLVal>> left,
      std::unique_ptr<JsExpression> right,
      std::unique_ptr<JsStatement> body);

  JsNodeType node_type() const override {
    return JsNodeType::kForInStatement;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsForInStatement>> FromJson(const nlohmann::json& json);

  std::variant<JsVariableDeclaration*, JsLVal*> left();
  std::variant<const JsVariableDeclaration*, const JsLVal*> left() const;
  void set_left(std::variant<std::unique_ptr<JsVariableDeclaration>, std::unique_ptr<JsLVal>> left);

  JsExpression* right();
  const JsExpression* right() const;
  void set_right(std::unique_ptr<JsExpression> right);

  JsStatement* body();
  const JsStatement* body() const;
  void set_body(std::unique_ptr<JsStatement> body);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::variant<std::unique_ptr<JsVariableDeclaration>, std::unique_ptr<JsLVal>>> GetLeft(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetRight(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsStatement>> GetBody(const nlohmann::json& json);

 private:
  std::variant<std::unique_ptr<JsVariableDeclaration>, std::unique_ptr<JsLVal>> left_;
  std::unique_ptr<JsExpression> right_;
  std::unique_ptr<JsStatement> body_;
};

class JsForOfStatement : public virtual JsStatement {
 public:
  explicit JsForOfStatement(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::variant<std::unique_ptr<JsVariableDeclaration>, std::unique_ptr<JsLVal>> left,
      std::unique_ptr<JsExpression> right,
      std::unique_ptr<JsStatement> body,
      bool await);

  JsNodeType node_type() const override {
    return JsNodeType::kForOfStatement;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsForOfStatement>> FromJson(const nlohmann::json& json);

  std::variant<JsVariableDeclaration*, JsLVal*> left();
  std::variant<const JsVariableDeclaration*, const JsLVal*> left() const;
  void set_left(std::variant<std::unique_ptr<JsVariableDeclaration>, std::unique_ptr<JsLVal>> left);

  JsExpression* right();
  const JsExpression* right() const;
  void set_right(std::unique_ptr<JsExpression> right);

  JsStatement* body();
  const JsStatement* body() const;
  void set_body(std::unique_ptr<JsStatement> body);

  bool await() const;
  void set_await(bool await);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::variant<std::unique_ptr<JsVariableDeclaration>, std::unique_ptr<JsLVal>>> GetLeft(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetRight(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsStatement>> GetBody(const nlohmann::json& json);
  static absl::StatusOr<bool> GetAwait(const nlohmann::json& json);

 private:
  std::variant<std::unique_ptr<JsVariableDeclaration>, std::unique_ptr<JsLVal>> left_;
  std::unique_ptr<JsExpression> right_;
  std::unique_ptr<JsStatement> body_;
  bool await_;
};

class JsFunctionDeclaration : public virtual JsBlockStatementFunction, public virtual JsDeclaration {
 public:
  explicit JsFunctionDeclaration(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::optional<std::unique_ptr<JsIdentifier>> id,
      std::vector<std::unique_ptr<JsPattern>> params,
      bool generator,
      bool async,
      std::unique_ptr<JsBlockStatement> body);

  JsNodeType node_type() const override {
    return JsNodeType::kFunctionDeclaration;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsFunctionDeclaration>> FromJson(const nlohmann::json& json);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;
};

class JsSuper : public virtual JsNode {
 public:
  explicit JsSuper(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols);

  JsNodeType node_type() const override {
    return JsNodeType::kSuper;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsSuper>> FromJson(const nlohmann::json& json);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;
};

class JsImport : public virtual JsNode {
 public:
  explicit JsImport(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols);

  JsNodeType node_type() const override {
    return JsNodeType::kImport;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsImport>> FromJson(const nlohmann::json& json);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;
};

class JsThisExpression : public virtual JsExpression {
 public:
  explicit JsThisExpression(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols);

  JsNodeType node_type() const override {
    return JsNodeType::kThisExpression;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsThisExpression>> FromJson(const nlohmann::json& json);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;
};

class JsArrowFunctionExpression : public virtual JsFunction, public virtual JsExpression {
 public:
  explicit JsArrowFunctionExpression(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::optional<std::unique_ptr<JsIdentifier>> id,
      std::vector<std::unique_ptr<JsPattern>> params,
      bool generator,
      bool async,
      std::variant<std::unique_ptr<JsBlockStatement>, std::unique_ptr<JsExpression>> body);

  JsNodeType node_type() const override {
    return JsNodeType::kArrowFunctionExpression;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsArrowFunctionExpression>> FromJson(const nlohmann::json& json);

  std::variant<JsBlockStatement*, JsExpression*> body();
  std::variant<const JsBlockStatement*, const JsExpression*> body() const;
  void set_body(std::variant<std::unique_ptr<JsBlockStatement>, std::unique_ptr<JsExpression>> body);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::variant<std::unique_ptr<JsBlockStatement>, std::unique_ptr<JsExpression>>> GetBody(const nlohmann::json& json);

 private:
  std::variant<std::unique_ptr<JsBlockStatement>, std::unique_ptr<JsExpression>> body_;
};

class JsYieldExpression : public virtual JsExpression {
 public:
  explicit JsYieldExpression(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::optional<std::unique_ptr<JsExpression>> argument,
      bool delegate);

  JsNodeType node_type() const override {
    return JsNodeType::kYieldExpression;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsYieldExpression>> FromJson(const nlohmann::json& json);

  std::optional<JsExpression*> argument();
  std::optional<const JsExpression*> argument() const;
  void set_argument(std::optional<std::unique_ptr<JsExpression>> argument);

  bool delegate() const;
  void set_delegate(bool delegate);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::optional<std::unique_ptr<JsExpression>>> GetArgument(const nlohmann::json& json);
  static absl::StatusOr<bool> GetDelegate(const nlohmann::json& json);

 private:
  std::optional<std::unique_ptr<JsExpression>> argument_;
  bool delegate_;
};

class JsAwaitExpression : public virtual JsExpression {
 public:
  explicit JsAwaitExpression(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::optional<std::unique_ptr<JsExpression>> argument);

  JsNodeType node_type() const override {
    return JsNodeType::kAwaitExpression;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsAwaitExpression>> FromJson(const nlohmann::json& json);

  std::optional<JsExpression*> argument();
  std::optional<const JsExpression*> argument() const;
  void set_argument(std::optional<std::unique_ptr<JsExpression>> argument);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::optional<std::unique_ptr<JsExpression>>> GetArgument(const nlohmann::json& json);

 private:
  std::optional<std::unique_ptr<JsExpression>> argument_;
};

class JsSpreadElement : public virtual JsNode {
 public:
  explicit JsSpreadElement(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsExpression> argument);

  JsNodeType node_type() const override {
    return JsNodeType::kSpreadElement;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsSpreadElement>> FromJson(const nlohmann::json& json);

  JsExpression* argument();
  const JsExpression* argument() const;
  void set_argument(std::unique_ptr<JsExpression> argument);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetArgument(const nlohmann::json& json);

 private:
  std::unique_ptr<JsExpression> argument_;
};

class JsArrayExpression : public virtual JsExpression {
 public:
  explicit JsArrayExpression(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::vector<std::optional<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>>> elements);

  JsNodeType node_type() const override {
    return JsNodeType::kArrayExpression;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsArrayExpression>> FromJson(const nlohmann::json& json);

  std::vector<std::optional<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>>>* elements();
  const std::vector<std::optional<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>>>* elements() const;
  void set_elements(std::vector<std::optional<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>>> elements);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::vector<std::optional<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>>>> GetElements(const nlohmann::json& json);

 private:
  std::vector<std::optional<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>>> elements_;
};

class JsObjectMember : public virtual JsNode {
 public:
  explicit JsObjectMember(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsExpression> key,
      bool computed);

  static absl::StatusOr<std::unique_ptr<JsObjectMember>> FromJson(const nlohmann::json& json);

  JsExpression* key();
  const JsExpression* key() const;
  void set_key(std::unique_ptr<JsExpression> key);

  bool computed() const;
  void set_computed(bool computed);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetKey(const nlohmann::json& json);
  static absl::StatusOr<bool> GetComputed(const nlohmann::json& json);

 private:
  std::unique_ptr<JsExpression> key_;
  bool computed_;
};

class JsObjectProperty : public virtual JsObjectMember {
 public:
  explicit JsObjectProperty(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsExpression> key,
      bool computed,
      bool shorthand,
      std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsPattern>> value);

  JsNodeType node_type() const override {
    return JsNodeType::kObjectProperty;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsObjectProperty>> FromJson(const nlohmann::json& json);

  bool shorthand() const;
  void set_shorthand(bool shorthand);

  std::variant<JsExpression*, JsPattern*> value();
  std::variant<const JsExpression*, const JsPattern*> value() const;
  void set_value(std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsPattern>> value);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<bool> GetShorthand(const nlohmann::json& json);
  static absl::StatusOr<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsPattern>>> GetValue(const nlohmann::json& json);

 private:
  bool shorthand_;
  std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsPattern>> value_;
};

class JsObjectMethod : public virtual JsObjectMember, public virtual JsBlockStatementFunction {
 public:
  explicit JsObjectMethod(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsExpression> key,
      bool computed,
      std::optional<std::unique_ptr<JsIdentifier>> id,
      std::vector<std::unique_ptr<JsPattern>> params,
      bool generator,
      bool async,
      std::unique_ptr<JsBlockStatement> body,
      std::string kind);

  JsNodeType node_type() const override {
    return JsNodeType::kObjectMethod;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsObjectMethod>> FromJson(const nlohmann::json& json);

  absl::string_view kind() const;
  void set_kind(std::string kind);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::string> GetKind(const nlohmann::json& json);

 private:
  std::string kind_;
};

class JsObjectExpression : public virtual JsExpression {
 public:
  explicit JsObjectExpression(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::vector<std::variant<std::unique_ptr<JsObjectProperty>, std::unique_ptr<JsObjectMethod>, std::unique_ptr<JsSpreadElement>>> properties_);

  JsNodeType node_type() const override {
    return JsNodeType::kObjectExpression;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsObjectExpression>> FromJson(const nlohmann::json& json);

  std::vector<std::variant<std::unique_ptr<JsObjectProperty>, std::unique_ptr<JsObjectMethod>, std::unique_ptr<JsSpreadElement>>>* properties_();
  const std::vector<std::variant<std::unique_ptr<JsObjectProperty>, std::unique_ptr<JsObjectMethod>, std::unique_ptr<JsSpreadElement>>>* properties_() const;
  void set_properties_(std::vector<std::variant<std::unique_ptr<JsObjectProperty>, std::unique_ptr<JsObjectMethod>, std::unique_ptr<JsSpreadElement>>> properties_);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::vector<std::variant<std::unique_ptr<JsObjectProperty>, std::unique_ptr<JsObjectMethod>, std::unique_ptr<JsSpreadElement>>>> GetProperties(const nlohmann::json& json);

 private:
  std::vector<std::variant<std::unique_ptr<JsObjectProperty>, std::unique_ptr<JsObjectMethod>, std::unique_ptr<JsSpreadElement>>> properties__;
};

class JsFunctionExpression : public virtual JsBlockStatementFunction, public virtual JsExpression {
 public:
  explicit JsFunctionExpression(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::optional<std::unique_ptr<JsIdentifier>> id,
      std::vector<std::unique_ptr<JsPattern>> params,
      bool generator,
      bool async,
      std::unique_ptr<JsBlockStatement> body);

  JsNodeType node_type() const override {
    return JsNodeType::kFunctionExpression;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsFunctionExpression>> FromJson(const nlohmann::json& json);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;
};

class JsUnaryExpression : public virtual JsExpression {
 public:
  explicit JsUnaryExpression(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      JsUnaryOperator operator_,
      bool prefix,
      std::unique_ptr<JsExpression> argument);

  JsNodeType node_type() const override {
    return JsNodeType::kUnaryExpression;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsUnaryExpression>> FromJson(const nlohmann::json& json);

  JsUnaryOperator operator_() const;
  void set_operator_(JsUnaryOperator operator_);

  bool prefix() const;
  void set_prefix(bool prefix);

  JsExpression* argument();
  const JsExpression* argument() const;
  void set_argument(std::unique_ptr<JsExpression> argument);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<JsUnaryOperator> GetOperator(const nlohmann::json& json);
  static absl::StatusOr<bool> GetPrefix(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetArgument(const nlohmann::json& json);

 private:
  JsUnaryOperator operator__;
  bool prefix_;
  std::unique_ptr<JsExpression> argument_;
};

class JsUpdateExpression : public virtual JsExpression {
 public:
  explicit JsUpdateExpression(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      JsUpdateOperator operator_,
      std::unique_ptr<JsLVal> argument,
      bool prefix);

  JsNodeType node_type() const override {
    return JsNodeType::kUpdateExpression;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsUpdateExpression>> FromJson(const nlohmann::json& json);

  JsUpdateOperator operator_() const;
  void set_operator_(JsUpdateOperator operator_);

  JsLVal* argument();
  const JsLVal* argument() const;
  void set_argument(std::unique_ptr<JsLVal> argument);

  bool prefix() const;
  void set_prefix(bool prefix);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<JsUpdateOperator> GetOperator(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsLVal>> GetArgument(const nlohmann::json& json);
  static absl::StatusOr<bool> GetPrefix(const nlohmann::json& json);

 private:
  JsUpdateOperator operator__;
  std::unique_ptr<JsLVal> argument_;
  bool prefix_;
};

class JsBinaryExpression : public virtual JsExpression {
 public:
  explicit JsBinaryExpression(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      JsBinaryOperator operator_,
      std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsPrivateName>> left,
      std::unique_ptr<JsExpression> right);

  JsNodeType node_type() const override {
    return JsNodeType::kBinaryExpression;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsBinaryExpression>> FromJson(const nlohmann::json& json);

  JsBinaryOperator operator_() const;
  void set_operator_(JsBinaryOperator operator_);

  std::variant<JsExpression*, JsPrivateName*> left();
  std::variant<const JsExpression*, const JsPrivateName*> left() const;
  void set_left(std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsPrivateName>> left);

  JsExpression* right();
  const JsExpression* right() const;
  void set_right(std::unique_ptr<JsExpression> right);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<JsBinaryOperator> GetOperator(const nlohmann::json& json);
  static absl::StatusOr<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsPrivateName>>> GetLeft(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetRight(const nlohmann::json& json);

 private:
  JsBinaryOperator operator__;
  std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsPrivateName>> left_;
  std::unique_ptr<JsExpression> right_;
};

class JsAssignmentExpression : public virtual JsExpression {
 public:
  explicit JsAssignmentExpression(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      JsAssignmentOperator operator_,
      std::unique_ptr<JsLVal> left,
      std::unique_ptr<JsExpression> right);

  JsNodeType node_type() const override {
    return JsNodeType::kAssignmentExpression;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsAssignmentExpression>> FromJson(const nlohmann::json& json);

  JsAssignmentOperator operator_() const;
  void set_operator_(JsAssignmentOperator operator_);

  JsLVal* left();
  const JsLVal* left() const;
  void set_left(std::unique_ptr<JsLVal> left);

  JsExpression* right();
  const JsExpression* right() const;
  void set_right(std::unique_ptr<JsExpression> right);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<JsAssignmentOperator> GetOperator(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsLVal>> GetLeft(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetRight(const nlohmann::json& json);

 private:
  JsAssignmentOperator operator__;
  std::unique_ptr<JsLVal> left_;
  std::unique_ptr<JsExpression> right_;
};

class JsLogicalExpression : public virtual JsExpression {
 public:
  explicit JsLogicalExpression(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      JsLogicalOperator operator_,
      std::unique_ptr<JsExpression> left,
      std::unique_ptr<JsExpression> right);

  JsNodeType node_type() const override {
    return JsNodeType::kLogicalExpression;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsLogicalExpression>> FromJson(const nlohmann::json& json);

  JsLogicalOperator operator_() const;
  void set_operator_(JsLogicalOperator operator_);

  JsExpression* left();
  const JsExpression* left() const;
  void set_left(std::unique_ptr<JsExpression> left);

  JsExpression* right();
  const JsExpression* right() const;
  void set_right(std::unique_ptr<JsExpression> right);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<JsLogicalOperator> GetOperator(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetLeft(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetRight(const nlohmann::json& json);

 private:
  JsLogicalOperator operator__;
  std::unique_ptr<JsExpression> left_;
  std::unique_ptr<JsExpression> right_;
};

class JsMemberExpression : public virtual JsExpression, public virtual JsPattern, public virtual JsLVal {
 public:
  explicit JsMemberExpression(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSuper>> object,
      std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsPrivateName>> property,
      bool computed);

  JsNodeType node_type() const override {
    return JsNodeType::kMemberExpression;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsMemberExpression>> FromJson(const nlohmann::json& json);

  std::variant<JsExpression*, JsSuper*> object();
  std::variant<const JsExpression*, const JsSuper*> object() const;
  void set_object(std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSuper>> object);

  std::variant<JsExpression*, JsPrivateName*> property();
  std::variant<const JsExpression*, const JsPrivateName*> property() const;
  void set_property(std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsPrivateName>> property);

  bool computed() const;
  void set_computed(bool computed);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSuper>>> GetObject(const nlohmann::json& json);
  static absl::StatusOr<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsPrivateName>>> GetProperty(const nlohmann::json& json);
  static absl::StatusOr<bool> GetComputed(const nlohmann::json& json);

 private:
  std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSuper>> object_;
  std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsPrivateName>> property_;
  bool computed_;
};

class JsOptionalMemberExpression : public virtual JsExpression {
 public:
  explicit JsOptionalMemberExpression(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsExpression> object,
      std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsPrivateName>> property,
      bool computed,
      bool optional);

  JsNodeType node_type() const override {
    return JsNodeType::kOptionalMemberExpression;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsOptionalMemberExpression>> FromJson(const nlohmann::json& json);

  JsExpression* object();
  const JsExpression* object() const;
  void set_object(std::unique_ptr<JsExpression> object);

  std::variant<JsExpression*, JsPrivateName*> property();
  std::variant<const JsExpression*, const JsPrivateName*> property() const;
  void set_property(std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsPrivateName>> property);

  bool computed() const;
  void set_computed(bool computed);

  bool optional() const;
  void set_optional(bool optional);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetObject(const nlohmann::json& json);
  static absl::StatusOr<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsPrivateName>>> GetProperty(const nlohmann::json& json);
  static absl::StatusOr<bool> GetComputed(const nlohmann::json& json);
  static absl::StatusOr<bool> GetOptional(const nlohmann::json& json);

 private:
  std::unique_ptr<JsExpression> object_;
  std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsPrivateName>> property_;
  bool computed_;
  bool optional_;
};

class JsConditionalExpression : public virtual JsExpression {
 public:
  explicit JsConditionalExpression(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsExpression> test,
      std::unique_ptr<JsExpression> alternate,
      std::unique_ptr<JsExpression> consequent);

  JsNodeType node_type() const override {
    return JsNodeType::kConditionalExpression;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsConditionalExpression>> FromJson(const nlohmann::json& json);

  JsExpression* test();
  const JsExpression* test() const;
  void set_test(std::unique_ptr<JsExpression> test);

  JsExpression* alternate();
  const JsExpression* alternate() const;
  void set_alternate(std::unique_ptr<JsExpression> alternate);

  JsExpression* consequent();
  const JsExpression* consequent() const;
  void set_consequent(std::unique_ptr<JsExpression> consequent);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetTest(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetAlternate(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetConsequent(const nlohmann::json& json);

 private:
  std::unique_ptr<JsExpression> test_;
  std::unique_ptr<JsExpression> alternate_;
  std::unique_ptr<JsExpression> consequent_;
};

class JsCallExpression : public virtual JsExpression {
 public:
  explicit JsCallExpression(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSuper>, std::unique_ptr<JsImport>> callee,
      std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>> arguments);

  JsNodeType node_type() const override {
    return JsNodeType::kCallExpression;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsCallExpression>> FromJson(const nlohmann::json& json);

  std::variant<JsExpression*, JsSuper*, JsImport*> callee();
  std::variant<const JsExpression*, const JsSuper*, const JsImport*> callee() const;
  void set_callee(std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSuper>, std::unique_ptr<JsImport>> callee);

  std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>>* arguments();
  const std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>>* arguments() const;
  void set_arguments(std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>> arguments);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSuper>, std::unique_ptr<JsImport>>> GetCallee(const nlohmann::json& json);
  static absl::StatusOr<std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>>> GetArguments(const nlohmann::json& json);

 private:
  std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSuper>, std::unique_ptr<JsImport>> callee_;
  std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>> arguments_;
};

class JsOptionalCallExpression : public virtual JsExpression {
 public:
  explicit JsOptionalCallExpression(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsExpression> callee,
      std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>> arguments,
      bool optional);

  JsNodeType node_type() const override {
    return JsNodeType::kOptionalCallExpression;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsOptionalCallExpression>> FromJson(const nlohmann::json& json);

  JsExpression* callee();
  const JsExpression* callee() const;
  void set_callee(std::unique_ptr<JsExpression> callee);

  std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>>* arguments();
  const std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>>* arguments() const;
  void set_arguments(std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>> arguments);

  bool optional() const;
  void set_optional(bool optional);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetCallee(const nlohmann::json& json);
  static absl::StatusOr<std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>>> GetArguments(const nlohmann::json& json);
  static absl::StatusOr<bool> GetOptional(const nlohmann::json& json);

 private:
  std::unique_ptr<JsExpression> callee_;
  std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>> arguments_;
  bool optional_;
};

class JsNewExpression : public virtual JsExpression {
 public:
  explicit JsNewExpression(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSuper>, std::unique_ptr<JsImport>> callee,
      std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>> arguments);

  JsNodeType node_type() const override {
    return JsNodeType::kNewExpression;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsNewExpression>> FromJson(const nlohmann::json& json);

  std::variant<JsExpression*, JsSuper*, JsImport*> callee();
  std::variant<const JsExpression*, const JsSuper*, const JsImport*> callee() const;
  void set_callee(std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSuper>, std::unique_ptr<JsImport>> callee);

  std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>>* arguments();
  const std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>>* arguments() const;
  void set_arguments(std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>> arguments);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSuper>, std::unique_ptr<JsImport>>> GetCallee(const nlohmann::json& json);
  static absl::StatusOr<std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>>> GetArguments(const nlohmann::json& json);

 private:
  std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSuper>, std::unique_ptr<JsImport>> callee_;
  std::vector<std::variant<std::unique_ptr<JsExpression>, std::unique_ptr<JsSpreadElement>>> arguments_;
};

class JsSequenceExpression : public virtual JsExpression {
 public:
  explicit JsSequenceExpression(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::vector<std::unique_ptr<JsExpression>> expressions);

  JsNodeType node_type() const override {
    return JsNodeType::kSequenceExpression;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsSequenceExpression>> FromJson(const nlohmann::json& json);

  std::vector<std::unique_ptr<JsExpression>>* expressions();
  const std::vector<std::unique_ptr<JsExpression>>* expressions() const;
  void set_expressions(std::vector<std::unique_ptr<JsExpression>> expressions);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::vector<std::unique_ptr<JsExpression>>> GetExpressions(const nlohmann::json& json);

 private:
  std::vector<std::unique_ptr<JsExpression>> expressions_;
};

class JsParenthesizedExpression : public virtual JsExpression, public virtual JsPattern, public virtual JsLVal {
 public:
  explicit JsParenthesizedExpression(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsExpression> expression);

  JsNodeType node_type() const override {
    return JsNodeType::kParenthesizedExpression;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsParenthesizedExpression>> FromJson(const nlohmann::json& json);

  JsExpression* expression();
  const JsExpression* expression() const;
  void set_expression(std::unique_ptr<JsExpression> expression);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetExpression(const nlohmann::json& json);

 private:
  std::unique_ptr<JsExpression> expression_;
};

class JsTemplateElementValue {
 public:
  explicit JsTemplateElementValue(
      std::optional<std::string> cooked,
      std::string raw);

  void Serialize(std::ostream& os) const;

  static absl::StatusOr<std::unique_ptr<JsTemplateElementValue>> FromJson(const nlohmann::json& json);

  std::optional<absl::string_view> cooked() const;
  void set_cooked(std::optional<std::string> cooked);

  absl::string_view raw() const;
  void set_raw(std::string raw);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::optional<std::string>> GetCooked(const nlohmann::json& json);
  static absl::StatusOr<std::string> GetRaw(const nlohmann::json& json);

 private:
  std::optional<std::string> cooked_;
  std::string raw_;
};

class JsTemplateElement : public virtual JsNode {
 public:
  explicit JsTemplateElement(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      bool tail,
      std::unique_ptr<JsTemplateElementValue> value);

  JsNodeType node_type() const override {
    return JsNodeType::kTemplateElement;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsTemplateElement>> FromJson(const nlohmann::json& json);

  bool tail() const;
  void set_tail(bool tail);

  JsTemplateElementValue* value();
  const JsTemplateElementValue* value() const;
  void set_value(std::unique_ptr<JsTemplateElementValue> value);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<bool> GetTail(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsTemplateElementValue>> GetValue(const nlohmann::json& json);

 private:
  bool tail_;
  std::unique_ptr<JsTemplateElementValue> value_;
};

class JsTemplateLiteral : public virtual JsExpression {
 public:
  explicit JsTemplateLiteral(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::vector<std::unique_ptr<JsTemplateElement>> quasis,
      std::vector<std::unique_ptr<JsExpression>> expressions);

  JsNodeType node_type() const override {
    return JsNodeType::kTemplateLiteral;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsTemplateLiteral>> FromJson(const nlohmann::json& json);

  std::vector<std::unique_ptr<JsTemplateElement>>* quasis();
  const std::vector<std::unique_ptr<JsTemplateElement>>* quasis() const;
  void set_quasis(std::vector<std::unique_ptr<JsTemplateElement>> quasis);

  std::vector<std::unique_ptr<JsExpression>>* expressions();
  const std::vector<std::unique_ptr<JsExpression>>* expressions() const;
  void set_expressions(std::vector<std::unique_ptr<JsExpression>> expressions);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::vector<std::unique_ptr<JsTemplateElement>>> GetQuasis(const nlohmann::json& json);
  static absl::StatusOr<std::vector<std::unique_ptr<JsExpression>>> GetExpressions(const nlohmann::json& json);

 private:
  std::vector<std::unique_ptr<JsTemplateElement>> quasis_;
  std::vector<std::unique_ptr<JsExpression>> expressions_;
};

class JsTaggedTemplateExpression : public virtual JsExpression {
 public:
  explicit JsTaggedTemplateExpression(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsExpression> tag,
      std::unique_ptr<JsTemplateLiteral> quasi);

  JsNodeType node_type() const override {
    return JsNodeType::kTaggedTemplateExpression;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsTaggedTemplateExpression>> FromJson(const nlohmann::json& json);

  JsExpression* tag();
  const JsExpression* tag() const;
  void set_tag(std::unique_ptr<JsExpression> tag);

  JsTemplateLiteral* quasi();
  const JsTemplateLiteral* quasi() const;
  void set_quasi(std::unique_ptr<JsTemplateLiteral> quasi);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetTag(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsTemplateLiteral>> GetQuasi(const nlohmann::json& json);

 private:
  std::unique_ptr<JsExpression> tag_;
  std::unique_ptr<JsTemplateLiteral> quasi_;
};

class JsRestElement : public virtual JsPattern, public virtual JsLVal {
 public:
  explicit JsRestElement(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsLVal> argument);

  JsNodeType node_type() const override {
    return JsNodeType::kRestElement;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsRestElement>> FromJson(const nlohmann::json& json);

  JsLVal* argument();
  const JsLVal* argument() const;
  void set_argument(std::unique_ptr<JsLVal> argument);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsLVal>> GetArgument(const nlohmann::json& json);

 private:
  std::unique_ptr<JsLVal> argument_;
};

class JsObjectPattern : public virtual JsPattern, public virtual JsLVal {
 public:
  explicit JsObjectPattern(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::vector<std::variant<std::unique_ptr<JsObjectProperty>, std::unique_ptr<JsRestElement>>> properties_);

  JsNodeType node_type() const override {
    return JsNodeType::kObjectPattern;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsObjectPattern>> FromJson(const nlohmann::json& json);

  std::vector<std::variant<std::unique_ptr<JsObjectProperty>, std::unique_ptr<JsRestElement>>>* properties_();
  const std::vector<std::variant<std::unique_ptr<JsObjectProperty>, std::unique_ptr<JsRestElement>>>* properties_() const;
  void set_properties_(std::vector<std::variant<std::unique_ptr<JsObjectProperty>, std::unique_ptr<JsRestElement>>> properties_);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::vector<std::variant<std::unique_ptr<JsObjectProperty>, std::unique_ptr<JsRestElement>>>> GetProperties(const nlohmann::json& json);

 private:
  std::vector<std::variant<std::unique_ptr<JsObjectProperty>, std::unique_ptr<JsRestElement>>> properties__;
};

class JsArrayPattern : public virtual JsPattern, public virtual JsLVal {
 public:
  explicit JsArrayPattern(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::vector<std::optional<std::unique_ptr<JsPattern>>> elements);

  JsNodeType node_type() const override {
    return JsNodeType::kArrayPattern;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsArrayPattern>> FromJson(const nlohmann::json& json);

  std::vector<std::optional<std::unique_ptr<JsPattern>>>* elements();
  const std::vector<std::optional<std::unique_ptr<JsPattern>>>* elements() const;
  void set_elements(std::vector<std::optional<std::unique_ptr<JsPattern>>> elements);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::vector<std::optional<std::unique_ptr<JsPattern>>>> GetElements(const nlohmann::json& json);

 private:
  std::vector<std::optional<std::unique_ptr<JsPattern>>> elements_;
};

class JsAssignmentPattern : public virtual JsPattern, public virtual JsLVal {
 public:
  explicit JsAssignmentPattern(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsPattern> left,
      std::unique_ptr<JsExpression> right);

  JsNodeType node_type() const override {
    return JsNodeType::kAssignmentPattern;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsAssignmentPattern>> FromJson(const nlohmann::json& json);

  JsPattern* left();
  const JsPattern* left() const;
  void set_left(std::unique_ptr<JsPattern> left);

  JsExpression* right();
  const JsExpression* right() const;
  void set_right(std::unique_ptr<JsExpression> right);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsPattern>> GetLeft(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetRight(const nlohmann::json& json);

 private:
  std::unique_ptr<JsPattern> left_;
  std::unique_ptr<JsExpression> right_;
};

class JsClassMethod : public virtual JsBlockStatementFunction {
 public:
  explicit JsClassMethod(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::optional<std::unique_ptr<JsIdentifier>> id,
      std::vector<std::unique_ptr<JsPattern>> params,
      bool generator,
      bool async,
      std::unique_ptr<JsBlockStatement> body,
      std::unique_ptr<JsExpression> key,
      std::string kind,
      bool computed,
      bool static_);

  JsNodeType node_type() const override {
    return JsNodeType::kClassMethod;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsClassMethod>> FromJson(const nlohmann::json& json);

  JsExpression* key();
  const JsExpression* key() const;
  void set_key(std::unique_ptr<JsExpression> key);

  absl::string_view kind() const;
  void set_kind(std::string kind);

  bool computed() const;
  void set_computed(bool computed);

  bool static_() const;
  void set_static_(bool static_);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetKey(const nlohmann::json& json);
  static absl::StatusOr<std::string> GetKind(const nlohmann::json& json);
  static absl::StatusOr<bool> GetComputed(const nlohmann::json& json);
  static absl::StatusOr<bool> GetStatic(const nlohmann::json& json);

 private:
  std::unique_ptr<JsExpression> key_;
  std::string kind_;
  bool computed_;
  bool static__;
};

class JsClassPrivateMethod : public virtual JsBlockStatementFunction {
 public:
  explicit JsClassPrivateMethod(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::optional<std::unique_ptr<JsIdentifier>> id,
      std::vector<std::unique_ptr<JsPattern>> params,
      bool generator,
      bool async,
      std::unique_ptr<JsBlockStatement> body,
      std::unique_ptr<JsPrivateName> key,
      std::string kind,
      bool static_,
      std::optional<bool> computed);

  JsNodeType node_type() const override {
    return JsNodeType::kClassPrivateMethod;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsClassPrivateMethod>> FromJson(const nlohmann::json& json);

  JsPrivateName* key();
  const JsPrivateName* key() const;
  void set_key(std::unique_ptr<JsPrivateName> key);

  absl::string_view kind() const;
  void set_kind(std::string kind);

  bool static_() const;
  void set_static_(bool static_);

  std::optional<bool> computed() const;
  void set_computed(std::optional<bool> computed);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsPrivateName>> GetKey(const nlohmann::json& json);
  static absl::StatusOr<std::string> GetKind(const nlohmann::json& json);
  static absl::StatusOr<bool> GetStatic(const nlohmann::json& json);
  static absl::StatusOr<std::optional<bool>> GetComputed(const nlohmann::json& json);

 private:
  std::unique_ptr<JsPrivateName> key_;
  std::string kind_;
  bool static__;
  std::optional<bool> computed_;
};

class JsClassProperty : public virtual JsNode {
 public:
  explicit JsClassProperty(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsExpression> key,
      std::optional<std::unique_ptr<JsExpression>> value,
      bool static_,
      bool computed);

  JsNodeType node_type() const override {
    return JsNodeType::kClassProperty;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsClassProperty>> FromJson(const nlohmann::json& json);

  JsExpression* key();
  const JsExpression* key() const;
  void set_key(std::unique_ptr<JsExpression> key);

  std::optional<JsExpression*> value();
  std::optional<const JsExpression*> value() const;
  void set_value(std::optional<std::unique_ptr<JsExpression>> value);

  bool static_() const;
  void set_static_(bool static_);

  bool computed() const;
  void set_computed(bool computed);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsExpression>> GetKey(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::unique_ptr<JsExpression>>> GetValue(const nlohmann::json& json);
  static absl::StatusOr<bool> GetStatic(const nlohmann::json& json);
  static absl::StatusOr<bool> GetComputed(const nlohmann::json& json);

 private:
  std::unique_ptr<JsExpression> key_;
  std::optional<std::unique_ptr<JsExpression>> value_;
  bool static__;
  bool computed_;
};

class JsClassPrivateProperty : public virtual JsNode {
 public:
  explicit JsClassPrivateProperty(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsPrivateName> key,
      std::optional<std::unique_ptr<JsExpression>> value,
      bool static_);

  JsNodeType node_type() const override {
    return JsNodeType::kClassPrivateProperty;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsClassPrivateProperty>> FromJson(const nlohmann::json& json);

  JsPrivateName* key();
  const JsPrivateName* key() const;
  void set_key(std::unique_ptr<JsPrivateName> key);

  std::optional<JsExpression*> value();
  std::optional<const JsExpression*> value() const;
  void set_value(std::optional<std::unique_ptr<JsExpression>> value);

  bool static_() const;
  void set_static_(bool static_);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsPrivateName>> GetKey(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::unique_ptr<JsExpression>>> GetValue(const nlohmann::json& json);
  static absl::StatusOr<bool> GetStatic(const nlohmann::json& json);

 private:
  std::unique_ptr<JsPrivateName> key_;
  std::optional<std::unique_ptr<JsExpression>> value_;
  bool static__;
};

class JsClassBody : public virtual JsNode {
 public:
  explicit JsClassBody(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::vector<std::variant<std::unique_ptr<JsClassMethod>, std::unique_ptr<JsClassPrivateMethod>, std::unique_ptr<JsClassProperty>, std::unique_ptr<JsClassPrivateProperty>>> body);

  JsNodeType node_type() const override {
    return JsNodeType::kClassBody;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsClassBody>> FromJson(const nlohmann::json& json);

  std::vector<std::variant<std::unique_ptr<JsClassMethod>, std::unique_ptr<JsClassPrivateMethod>, std::unique_ptr<JsClassProperty>, std::unique_ptr<JsClassPrivateProperty>>>* body();
  const std::vector<std::variant<std::unique_ptr<JsClassMethod>, std::unique_ptr<JsClassPrivateMethod>, std::unique_ptr<JsClassProperty>, std::unique_ptr<JsClassPrivateProperty>>>* body() const;
  void set_body(std::vector<std::variant<std::unique_ptr<JsClassMethod>, std::unique_ptr<JsClassPrivateMethod>, std::unique_ptr<JsClassProperty>, std::unique_ptr<JsClassPrivateProperty>>> body);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::vector<std::variant<std::unique_ptr<JsClassMethod>, std::unique_ptr<JsClassPrivateMethod>, std::unique_ptr<JsClassProperty>, std::unique_ptr<JsClassPrivateProperty>>>> GetBody(const nlohmann::json& json);

 private:
  std::vector<std::variant<std::unique_ptr<JsClassMethod>, std::unique_ptr<JsClassPrivateMethod>, std::unique_ptr<JsClassProperty>, std::unique_ptr<JsClassPrivateProperty>>> body_;
};

class JsClass : public virtual JsNode {
 public:
  explicit JsClass(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::optional<std::unique_ptr<JsExpression>> super_class,
      std::unique_ptr<JsClassBody> body);

  static absl::StatusOr<std::unique_ptr<JsClass>> FromJson(const nlohmann::json& json);

  std::optional<JsExpression*> super_class();
  std::optional<const JsExpression*> super_class() const;
  void set_super_class(std::optional<std::unique_ptr<JsExpression>> super_class);

  JsClassBody* body();
  const JsClassBody* body() const;
  void set_body(std::unique_ptr<JsClassBody> body);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::optional<std::unique_ptr<JsExpression>>> GetSuperClass(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsClassBody>> GetBody(const nlohmann::json& json);

 private:
  std::optional<std::unique_ptr<JsExpression>> super_class_;
  std::unique_ptr<JsClassBody> body_;
};

class JsClassDeclaration : public virtual JsClass, public virtual JsDeclaration {
 public:
  explicit JsClassDeclaration(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::optional<std::unique_ptr<JsExpression>> super_class,
      std::unique_ptr<JsClassBody> body,
      std::optional<std::unique_ptr<JsIdentifier>> id);

  JsNodeType node_type() const override {
    return JsNodeType::kClassDeclaration;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsClassDeclaration>> FromJson(const nlohmann::json& json);

  std::optional<JsIdentifier*> id();
  std::optional<const JsIdentifier*> id() const;
  void set_id(std::optional<std::unique_ptr<JsIdentifier>> id);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::optional<std::unique_ptr<JsIdentifier>>> GetId(const nlohmann::json& json);

 private:
  std::optional<std::unique_ptr<JsIdentifier>> id_;
};

class JsClassExpression : public virtual JsClass, public virtual JsExpression {
 public:
  explicit JsClassExpression(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::optional<std::unique_ptr<JsExpression>> super_class,
      std::unique_ptr<JsClassBody> body,
      std::optional<std::unique_ptr<JsIdentifier>> id);

  JsNodeType node_type() const override {
    return JsNodeType::kClassExpression;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsClassExpression>> FromJson(const nlohmann::json& json);

  std::optional<JsIdentifier*> id();
  std::optional<const JsIdentifier*> id() const;
  void set_id(std::optional<std::unique_ptr<JsIdentifier>> id);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::optional<std::unique_ptr<JsIdentifier>>> GetId(const nlohmann::json& json);

 private:
  std::optional<std::unique_ptr<JsIdentifier>> id_;
};

class JsMetaProperty : public virtual JsExpression {
 public:
  explicit JsMetaProperty(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsIdentifier> meta,
      std::unique_ptr<JsIdentifier> property);

  JsNodeType node_type() const override {
    return JsNodeType::kMetaProperty;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsMetaProperty>> FromJson(const nlohmann::json& json);

  JsIdentifier* meta();
  const JsIdentifier* meta() const;
  void set_meta(std::unique_ptr<JsIdentifier> meta);

  JsIdentifier* property();
  const JsIdentifier* property() const;
  void set_property(std::unique_ptr<JsIdentifier> property);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsIdentifier>> GetMeta(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsIdentifier>> GetProperty(const nlohmann::json& json);

 private:
  std::unique_ptr<JsIdentifier> meta_;
  std::unique_ptr<JsIdentifier> property_;
};

class JsModuleSpecifier : public virtual JsNode {
 public:
  explicit JsModuleSpecifier(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols);

  static absl::StatusOr<std::unique_ptr<JsModuleSpecifier>> FromJson(const nlohmann::json& json);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;
};

class JsImportSpecifier : public virtual JsModuleSpecifier {
 public:
  explicit JsImportSpecifier(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::variant<std::unique_ptr<JsIdentifier>, std::unique_ptr<JsStringLiteral>> imported,
      std::unique_ptr<JsIdentifier> local);

  JsNodeType node_type() const override {
    return JsNodeType::kImportSpecifier;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsImportSpecifier>> FromJson(const nlohmann::json& json);

  std::variant<JsIdentifier*, JsStringLiteral*> imported();
  std::variant<const JsIdentifier*, const JsStringLiteral*> imported() const;
  void set_imported(std::variant<std::unique_ptr<JsIdentifier>, std::unique_ptr<JsStringLiteral>> imported);

  JsIdentifier* local();
  const JsIdentifier* local() const;
  void set_local(std::unique_ptr<JsIdentifier> local);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::variant<std::unique_ptr<JsIdentifier>, std::unique_ptr<JsStringLiteral>>> GetImported(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsIdentifier>> GetLocal(const nlohmann::json& json);

 private:
  std::variant<std::unique_ptr<JsIdentifier>, std::unique_ptr<JsStringLiteral>> imported_;
  std::unique_ptr<JsIdentifier> local_;
};

class JsImportDefaultSpecifier : public virtual JsModuleSpecifier {
 public:
  explicit JsImportDefaultSpecifier(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsIdentifier> local);

  JsNodeType node_type() const override {
    return JsNodeType::kImportDefaultSpecifier;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsImportDefaultSpecifier>> FromJson(const nlohmann::json& json);

  JsIdentifier* local();
  const JsIdentifier* local() const;
  void set_local(std::unique_ptr<JsIdentifier> local);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsIdentifier>> GetLocal(const nlohmann::json& json);

 private:
  std::unique_ptr<JsIdentifier> local_;
};

class JsImportNamespaceSpecifier : public virtual JsModuleSpecifier {
 public:
  explicit JsImportNamespaceSpecifier(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsIdentifier> local);

  JsNodeType node_type() const override {
    return JsNodeType::kImportNamespaceSpecifier;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsImportNamespaceSpecifier>> FromJson(const nlohmann::json& json);

  JsIdentifier* local();
  const JsIdentifier* local() const;
  void set_local(std::unique_ptr<JsIdentifier> local);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsIdentifier>> GetLocal(const nlohmann::json& json);

 private:
  std::unique_ptr<JsIdentifier> local_;
};

class JsImportAttribute : public virtual JsNode {
 public:
  explicit JsImportAttribute(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsIdentifier> key,
      std::unique_ptr<JsStringLiteral> value);

  JsNodeType node_type() const override {
    return JsNodeType::kImportAttribute;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsImportAttribute>> FromJson(const nlohmann::json& json);

  JsIdentifier* key();
  const JsIdentifier* key() const;
  void set_key(std::unique_ptr<JsIdentifier> key);

  JsStringLiteral* value();
  const JsStringLiteral* value() const;
  void set_value(std::unique_ptr<JsStringLiteral> value);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsIdentifier>> GetKey(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsStringLiteral>> GetValue(const nlohmann::json& json);

 private:
  std::unique_ptr<JsIdentifier> key_;
  std::unique_ptr<JsStringLiteral> value_;
};

class JsImportDeclaration : public virtual JsModuleDeclaration {
 public:
  explicit JsImportDeclaration(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::vector<std::variant<std::unique_ptr<JsImportSpecifier>, std::unique_ptr<JsImportDefaultSpecifier>, std::unique_ptr<JsImportNamespaceSpecifier>>> specifiers,
      std::unique_ptr<JsStringLiteral> source,
      std::optional<std::unique_ptr<JsImportAttribute>> assertions);

  JsNodeType node_type() const override {
    return JsNodeType::kImportDeclaration;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsImportDeclaration>> FromJson(const nlohmann::json& json);

  std::vector<std::variant<std::unique_ptr<JsImportSpecifier>, std::unique_ptr<JsImportDefaultSpecifier>, std::unique_ptr<JsImportNamespaceSpecifier>>>* specifiers();
  const std::vector<std::variant<std::unique_ptr<JsImportSpecifier>, std::unique_ptr<JsImportDefaultSpecifier>, std::unique_ptr<JsImportNamespaceSpecifier>>>* specifiers() const;
  void set_specifiers(std::vector<std::variant<std::unique_ptr<JsImportSpecifier>, std::unique_ptr<JsImportDefaultSpecifier>, std::unique_ptr<JsImportNamespaceSpecifier>>> specifiers);

  JsStringLiteral* source();
  const JsStringLiteral* source() const;
  void set_source(std::unique_ptr<JsStringLiteral> source);

  std::optional<JsImportAttribute*> assertions();
  std::optional<const JsImportAttribute*> assertions() const;
  void set_assertions(std::optional<std::unique_ptr<JsImportAttribute>> assertions);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::vector<std::variant<std::unique_ptr<JsImportSpecifier>, std::unique_ptr<JsImportDefaultSpecifier>, std::unique_ptr<JsImportNamespaceSpecifier>>>> GetSpecifiers(const nlohmann::json& json);
  static absl::StatusOr<std::unique_ptr<JsStringLiteral>> GetSource(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::unique_ptr<JsImportAttribute>>> GetAssertions(const nlohmann::json& json);

 private:
  std::vector<std::variant<std::unique_ptr<JsImportSpecifier>, std::unique_ptr<JsImportDefaultSpecifier>, std::unique_ptr<JsImportNamespaceSpecifier>>> specifiers_;
  std::unique_ptr<JsStringLiteral> source_;
  std::optional<std::unique_ptr<JsImportAttribute>> assertions_;
};

class JsExportSpecifier : public virtual JsModuleSpecifier {
 public:
  explicit JsExportSpecifier(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::variant<std::unique_ptr<JsIdentifier>, std::unique_ptr<JsStringLiteral>> exported,
      std::optional<std::variant<std::unique_ptr<JsIdentifier>, std::unique_ptr<JsStringLiteral>>> local);

  JsNodeType node_type() const override {
    return JsNodeType::kExportSpecifier;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsExportSpecifier>> FromJson(const nlohmann::json& json);

  std::variant<JsIdentifier*, JsStringLiteral*> exported();
  std::variant<const JsIdentifier*, const JsStringLiteral*> exported() const;
  void set_exported(std::variant<std::unique_ptr<JsIdentifier>, std::unique_ptr<JsStringLiteral>> exported);

  std::optional<std::variant<JsIdentifier*, JsStringLiteral*>> local();
  std::optional<std::variant<const JsIdentifier*, const JsStringLiteral*>> local() const;
  void set_local(std::optional<std::variant<std::unique_ptr<JsIdentifier>, std::unique_ptr<JsStringLiteral>>> local);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::variant<std::unique_ptr<JsIdentifier>, std::unique_ptr<JsStringLiteral>>> GetExported(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::variant<std::unique_ptr<JsIdentifier>, std::unique_ptr<JsStringLiteral>>>> GetLocal(const nlohmann::json& json);

 private:
  std::variant<std::unique_ptr<JsIdentifier>, std::unique_ptr<JsStringLiteral>> exported_;
  std::optional<std::variant<std::unique_ptr<JsIdentifier>, std::unique_ptr<JsStringLiteral>>> local_;
};

class JsExportNamedDeclaration : public virtual JsModuleDeclaration {
 public:
  explicit JsExportNamedDeclaration(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::optional<std::unique_ptr<JsDeclaration>> declaration,
      std::vector<std::unique_ptr<JsExportSpecifier>> specifiers,
      std::optional<std::unique_ptr<JsStringLiteral>> source,
      std::optional<std::vector<std::unique_ptr<JsImportAttribute>>> assertions);

  JsNodeType node_type() const override {
    return JsNodeType::kExportNamedDeclaration;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsExportNamedDeclaration>> FromJson(const nlohmann::json& json);

  std::optional<JsDeclaration*> declaration();
  std::optional<const JsDeclaration*> declaration() const;
  void set_declaration(std::optional<std::unique_ptr<JsDeclaration>> declaration);

  std::vector<std::unique_ptr<JsExportSpecifier>>* specifiers();
  const std::vector<std::unique_ptr<JsExportSpecifier>>* specifiers() const;
  void set_specifiers(std::vector<std::unique_ptr<JsExportSpecifier>> specifiers);

  std::optional<JsStringLiteral*> source();
  std::optional<const JsStringLiteral*> source() const;
  void set_source(std::optional<std::unique_ptr<JsStringLiteral>> source);

  std::optional<std::vector<std::unique_ptr<JsImportAttribute>>*> assertions();
  std::optional<const std::vector<std::unique_ptr<JsImportAttribute>>*> assertions() const;
  void set_assertions(std::optional<std::vector<std::unique_ptr<JsImportAttribute>>> assertions);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::optional<std::unique_ptr<JsDeclaration>>> GetDeclaration(const nlohmann::json& json);
  static absl::StatusOr<std::vector<std::unique_ptr<JsExportSpecifier>>> GetSpecifiers(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::unique_ptr<JsStringLiteral>>> GetSource(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::vector<std::unique_ptr<JsImportAttribute>>>> GetAssertions(const nlohmann::json& json);

 private:
  std::optional<std::unique_ptr<JsDeclaration>> declaration_;
  std::vector<std::unique_ptr<JsExportSpecifier>> specifiers_;
  std::optional<std::unique_ptr<JsStringLiteral>> source_;
  std::optional<std::vector<std::unique_ptr<JsImportAttribute>>> assertions_;
};

class JsExportDefaultDeclaration : public virtual JsModuleDeclaration {
 public:
  explicit JsExportDefaultDeclaration(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::variant<std::unique_ptr<JsFunctionDeclaration>, std::unique_ptr<JsClassDeclaration>, std::unique_ptr<JsExpression>> declaration);

  JsNodeType node_type() const override {
    return JsNodeType::kExportDefaultDeclaration;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsExportDefaultDeclaration>> FromJson(const nlohmann::json& json);

  std::variant<JsFunctionDeclaration*, JsClassDeclaration*, JsExpression*> declaration();
  std::variant<const JsFunctionDeclaration*, const JsClassDeclaration*, const JsExpression*> declaration() const;
  void set_declaration(std::variant<std::unique_ptr<JsFunctionDeclaration>, std::unique_ptr<JsClassDeclaration>, std::unique_ptr<JsExpression>> declaration);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::variant<std::unique_ptr<JsFunctionDeclaration>, std::unique_ptr<JsClassDeclaration>, std::unique_ptr<JsExpression>>> GetDeclaration(const nlohmann::json& json);

 private:
  std::variant<std::unique_ptr<JsFunctionDeclaration>, std::unique_ptr<JsClassDeclaration>, std::unique_ptr<JsExpression>> declaration_;
};

class JsExportAllDeclaration : public virtual JsModuleDeclaration {
 public:
  explicit JsExportAllDeclaration(
      std::optional<std::unique_ptr<JsSourceLocation>> loc,
      std::optional<int64_t> start,
      std::optional<int64_t> end,
      std::optional<std::vector<std::unique_ptr<JsComment>>> leading_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> trailing_comments,
      std::optional<std::vector<std::unique_ptr<JsComment>>> inner_comments,
      std::optional<int64_t> scope_uid,
      std::optional<std::unique_ptr<JsSymbolId>> referenced_symbol,
      std::optional<std::vector<std::unique_ptr<JsSymbolId>>> defined_symbols,
      std::unique_ptr<JsStringLiteral> source,
      std::optional<std::vector<std::unique_ptr<JsImportAttribute>>> assertions);

  JsNodeType node_type() const override {
    return JsNodeType::kExportAllDeclaration;
  }

  void Serialize(std::ostream& os) const override;

  static absl::StatusOr<std::unique_ptr<JsExportAllDeclaration>> FromJson(const nlohmann::json& json);

  JsStringLiteral* source();
  const JsStringLiteral* source() const;
  void set_source(std::unique_ptr<JsStringLiteral> source);

  std::optional<std::vector<std::unique_ptr<JsImportAttribute>>*> assertions();
  std::optional<const std::vector<std::unique_ptr<JsImportAttribute>>*> assertions() const;
  void set_assertions(std::optional<std::vector<std::unique_ptr<JsImportAttribute>>> assertions);

 protected:
  // Internal function used by Serialize().
  // Sets the fields defined in this class.
  // Does not set fields defined in ancestors.
  void SerializeFields(std::ostream& os, bool &needs_comma) const;

  // Internal functions used by FromJson().
  // Extracts a field from a JSON object.
  static absl::StatusOr<std::unique_ptr<JsStringLiteral>> GetSource(const nlohmann::json& json);
  static absl::StatusOr<std::optional<std::vector<std::unique_ptr<JsImportAttribute>>>> GetAssertions(const nlohmann::json& json);

 private:
  std::unique_ptr<JsStringLiteral> source_;
  std::optional<std::vector<std::unique_ptr<JsImportAttribute>>> assertions_;
};

// clang-format on
// NOLINTEND(whitespace/line_length)
// IWYU pragma: end_keep

}  // namespace maldoca

#endif  // MALDOCA_JS_AST_AST_GENERATED_H_
